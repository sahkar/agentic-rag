[
  {
    "subject": "Processors",
    "predicate": "use",
    "object": "the open RISC-V instruction set architecture (ISA)"
  },
  {
    "subject": "Processors using the open RISC-V instruction set architecture (ISA)",
    "predicate": "are finding",
    "object": "increasing adoption in the embedded world"
  },
  {
    "subject": "Robert Balas",
    "predicate": "is",
    "object": "graduate student member, IEEE"
  },
  {
    "subject": "Alessandro Ottaviano",
    "predicate": "is",
    "object": "graduate student member, IEEE"
  },
  {
    "subject": "Luca Benini",
    "predicate": "is",
    "object": "fellow, IEEE"
  },
  {
    "subject": "We",
    "predicate": "implement",
    "object": "a CLIC for the CV32E40P"
  },
  {
    "subject": "CV32E40P",
    "predicate": "is",
    "object": "an industrially supported open-source 32-bit microcontroller unit (MCU)-class RISC-V core"
  },
  {
    "subject": "We",
    "predicate": "enhance",
    "object": "CV32E40P with FastIRQ"
  },
  {
    "subject": "FastIRQ",
    "predicate": "is",
    "object": "a custom extension"
  },
  {
    "subject": "FastIRQ",
    "predicate": "provides",
    "object": "interrupt latency as low as six cycles"
  },
  {
    "subject": "CV32RT",
    "predicate": "is",
    "object": "a 32-bit RISC-V core"
  },
  {
    "subject": "CV32RT",
    "predicate": "extends",
    "object": "the interrupt handling capabilities of CV32E40P"
  },
  {
    "subject": "CV32E40P",
    "predicate": "is",
    "object": "an industrially supported open-source core"
  },
  {
    "subject": "CV32RT",
    "predicate": "achieves",
    "object": "best-in-class interrupt latency"
  },
  {
    "subject": "CV32RT",
    "predicate": "achieves",
    "object": "fast context switching"
  },
  {
    "subject": "CV32RT",
    "predicate": "competes against",
    "object": "commercial off-the-shelf (COTS) processor vendors"
  },
  {
    "subject": "CV32RT",
    "predicate": "paves the road for",
    "object": "RISC-V architectures in time-critical systems"
  },
  {
    "subject": "We",
    "predicate": "replace",
    "object": "the CV32E40P interrupt controller with an implementation of the RISC-V CLIC specification"
  },
  {
    "subject": "The RISC-V CLIC specification",
    "predicate": "provides",
    "object": "the core with key features"
  },
  {
    "subject": "Key features",
    "predicate": "include",
    "object": "prioritization by level and priority"
  },
  {
    "subject": "Key features",
    "predicate": "include",
    "object": "selective hardware vectoring (SHV)"
  },
  {
    "subject": "Key features",
    "predicate": "include",
    "object": "non-nested interrupt optimization tail-chaining through the XNXTI 15 control and status register (CSR)"
  },
  {
    "subject": "XNXTI 15 control and status register (CSR)",
    "predicate": "is",
    "object": "directly a RISC-V standard extension"
  },
  {
    "subject": "We",
    "predicate": "give",
    "object": "a brief overview of the full-system platform used to design and implement the proposed interrupt extension in Section II-A"
  },
  {
    "subject": "We",
    "predicate": "motivate and explain",
    "object": "the relevant target metrics in Section II-B3"
  },
  {
    "subject": "We",
    "predicate": "describe",
    "object": "the current status of interrupt handling in RISC-V in Section II-C"
  },
  {
    "subject": "RISC-V system platform",
    "predicate": "relies on",
    "object": "the CV32E40P core"
  },
  {
    "subject": "CV32E40P core",
    "predicate": "is abbreviated to",
    "object": "CV32"
  },
  {
    "subject": "CV32E40P core",
    "predicate": "is",
    "object": "an open-source, industry-grade, 32-bit, in-order, four-stage RISC-V core"
  },
  {
    "subject": "CV32E40P core",
    "predicate": "is used as",
    "object": "the basis for implementing our extensions"
  },
  {
    "subject": "CV32 core",
    "predicate": "is",
    "object": "the baseline"
  },
  {
    "subject": "native CLINT interrupt controller",
    "predicate": "is replaced with",
    "object": "CLIC"
  },
  {
    "subject": "CLIC",
    "predicate": "is referred to as",
    "object": "CV32RTCLIC"
  },
  {
    "subject": "FASTIRQ",
    "predicate": "is introduced into",
    "object": "core microarchitecture"
  },
  {
    "subject": "FASTIRQ",
    "predicate": "is the extension proposed in",
    "object": "this work"
  },
  {
    "subject": "FASTIRQ",
    "predicate": "is referred to as",
    "object": "CV32RTFASTIRQ"
  },
  {
    "subject": "CV32RTCLIC",
    "predicate": "implements",
    "object": "CLIC interrupt controller"
  },
  {
    "subject": "CLIC interrupt controller",
    "predicate": "is implemented in",
    "object": "CV32RTCLIC"
  },
  {
    "subject": "CLIC interrupt controller",
    "predicate": "is according to",
    "object": "draft specification"
  },
  {
    "subject": "draft specification",
    "predicate": "is to be included in",
    "object": "RISC-V privileged specification"
  },
  {
    "subject": "Our proposed FastIRQ extension",
    "predicate": "addresses",
    "object": "weaknesses of various flavors of RISC-V core-specific interrupt controllers"
  },
  {
    "subject": "Our proposed FastIRQ extension",
    "predicate": "extends",
    "object": "the CLIC base capabilities"
  },
  {
    "subject": "Our proposed FastIRQ extension",
    "predicate": "provides",
    "object": "a mechanism to lower interrupt latency"
  },
  {
    "subject": "Our proposed FastIRQ extension",
    "predicate": "keeps",
    "object": "HW vectored interrupts"
  },
  {
    "subject": "Our proposed FastIRQ extension",
    "predicate": "allows",
    "object": "skipping of redundant context restore operations"
  },
  {
    "subject": "We",
    "predicate": "present",
    "object": "FASTIRQ, a fast interrupt extension for RISC-V embedded systems"
  },
  {
    "subject": "the extension",
    "predicate": "is implemented on",
    "object": "CV32RT"
  },
  {
    "subject": "CV32RT",
    "predicate": "is",
    "object": "a 32-bit, in-order, single-issue core"
  },
  {
    "subject": "CV32RT",
    "predicate": "is designed with",
    "object": "the RISC-V CLIC fast interrupt controller"
  },
  {
    "subject": "27 B. MAO, N. TAN, T. CHONG, AND L. LI",
    "predicate": "authored",
    "object": "A CLIC EXTENSION BASED FAST INTERRUPT SYSTEM FOR EMBEDDED RISC-V PROCESSORS"
  },
  {
    "subject": "A CLIC EXTENSION BASED FAST INTERRUPT SYSTEM FOR EMBEDDED RISC-V PROCESSORS",
    "predicate": "published in",
    "object": "PROC."
  },
  {
    "subject": "Many embedded use cases",
    "predicate": "have",
    "object": "real-time constraints"
  },
  {
    "subject": "Many embedded use cases",
    "predicate": "require",
    "object": "flexible, predictable, and fast reactive handling of incoming events"
  },
  {
    "subject": "RISC-V processors",
    "predicate": "are lagging in",
    "object": "this area"
  },
  {
    "subject": "RISC-V processors",
    "predicate": "are lagging compared to",
    "object": "more mature proprietary architectures"
  },
  {
    "subject": "more mature proprietary architectures",
    "predicate": "include",
    "object": "ARM Cortex-M and TriCore"
  },
  {
    "subject": "ARM Cortex-M and TriCore",
    "predicate": "have been",
    "object": "tuned for years"
  },
  {
    "subject": "THE DEFAULT INTERRUPT CONTROLLER",
    "predicate": "is standardized by",
    "object": "RISC-V"
  },
  {
    "subject": "THE DEFAULT INTERRUPT CONTROLLER",
    "predicate": "is called",
    "object": "THE CORE LOCAL INTERRUPTOR (CLINT)"
  },
  {
    "subject": "THE CORE LOCAL INTERRUPTOR (CLINT)",
    "predicate": "lacks",
    "object": "configurability in prioritization and preemption of interrupts"
  },
  {
    "subject": "The RISC-V community",
    "predicate": "has been developing",
    "object": "an extension to the privileged specifications 14"
  },
  {
    "subject": "The extension to the privileged specifications 14",
    "predicate": "is",
    "object": "the RISC-V Core Local Interrupt Controller (CLIC) 15"
  },
  {
    "subject": "The RISC-V Core Local Interrupt Controller (CLIC) 15",
    "predicate": "is",
    "object": "currently under ratification by the community"
  },
  {
    "subject": "The RISC-V Core Local Interrupt Controller (CLIC) 15",
    "predicate": "is developed to handle",
    "object": "real-time scenarios"
  },
  {
    "subject": "CLICS",
    "predicate": "are",
    "object": "local to each hardware thread (HART)"
  },
  {
    "subject": "PLICS",
    "predicate": "are",
    "object": "platform level interrupt controllers"
  },
  {
    "subject": "PLICS",
    "predicate": "are",
    "object": "centralized interrupt controllers"
  },
  {
    "subject": "PLICS",
    "predicate": "are capable of",
    "object": "managing multiple HARTs"
  },
  {
    "subject": "Platform-level interrupt controllers",
    "predicate": "include",
    "object": "RISC-V PLIC"
  },
  {
    "subject": "Platform-level interrupt controllers",
    "predicate": "include",
    "object": "Advanced PLIC (APLIC)"
  },
  {
    "subject": "Platform-level interrupt controllers",
    "predicate": "include",
    "object": "RISC-V Incoming Message Signaled Interrupt Controller (IMSIC)"
  },
  {
    "subject": "RISC-V PLIC and Advanced PLIC (APLIC)",
    "predicate": "are used for",
    "object": "wire-based interrupt communication"
  },
  {
    "subject": "RISC-V Incoming Message Signaled Interrupt Controller (IMSIC)",
    "predicate": "is used for",
    "object": "message-signaled interrupt communication"
  },
  {
    "subject": "Platform-level interrupt controllers",
    "predicate": "are not designed to",
    "object": "distribute time-critical interrupts to the running harts"
  },
  {
    "subject": "B. CORE-LOCAL INTERRUPT CONTROLLERS (CLICS)",
    "predicate": "are specialized in",
    "object": "providing fast interrupt-handling capabilities in real-time embedded application domains"
  },
  {
    "subject": "WE",
    "predicate": "call",
    "object": "CV32RT OUR ENHANCED CORE"
  },
  {
    "subject": "CV32RT",
    "predicate": "is",
    "object": "the first fully open-source RV32 core with competitive interrupt-handling features compared to the ARM Cortex-M series and TriCore"
  },
  {
    "subject": "We",
    "predicate": "integrate",
    "object": "CV32RT within an open-source system on chip (SoC)"
  },
  {
    "subject": "We",
    "predicate": "evaluate",
    "object": "CV32RT interrupt handling capabilities"
  },
  {
    "subject": "The extension",
    "predicate": "introduces",
    "object": "negligible area overhead in a modern technology node"
  },
  {
    "subject": "The extension",
    "predicate": "provides",
    "object": "performance benefits"
  },
  {
    "subject": "various CV32RT versions",
    "predicate": "perform in terms of",
    "object": "interrupt latency and context switch times"
  },
  {
    "subject": "these additions",
    "predicate": "incur",
    "object": "overhead in terms of area and timing"
  },
  {
    "subject": "THE PROPOSED EXTENSIONS",
    "predicate": "are demonstrated to improve",
    "object": "TASK CONTEXT SWITCHING IN REAL-TIME OPERATING SYSTEMS (RTOSS)"
  },
  {
    "subject": "INDEX TERMS",
    "predicate": "include",
    "object": "CONTEXT SWITCHING"
  },
  {
    "subject": "INDEX TERMS",
    "predicate": "include",
    "object": "EMBEDDED"
  },
  {
    "subject": "INDEX TERMS",
    "predicate": "include",
    "object": "INTERRUPT LATENCY"
  },
  {
    "subject": "INDEX TERMS",
    "predicate": "include",
    "object": "MICROCONTROLLER UNIT (MCU)"
  },
  {
    "subject": "INDEX TERMS",
    "predicate": "include",
    "object": "REAL-TIME"
  },
  {
    "subject": "INDEX TERMS",
    "predicate": "include",
    "object": "RISC-V"
  },
  {
    "subject": "Several markets",
    "predicate": "rely on",
    "object": "real-time AN SW-based solution"
  },
  {
    "subject": "The automotive industry",
    "predicate": "employs",
    "object": "hundreds of electronic control units (ECUs)"
  },
  {
    "subject": "Electronic control units (ECUs)",
    "predicate": "are used for",
    "object": "real-time applications"
  },
  {
    "subject": "Real-time applications",
    "predicate": "include",
    "object": "electronic engine control"
  },
  {
    "subject": "Real-time applications",
    "predicate": "include",
    "object": "gearbox control"
  },
  {
    "subject": "Real-time applications",
    "predicate": "include",
    "object": "cruise control"
  },
  {
    "subject": "Real-time applications",
    "predicate": "include",
    "object": "anti-lock brake systems"
  },
  {
    "subject": "Real-time applications",
    "predicate": "include",
    "object": "many other tasks"
  },
  {
    "subject": "General-purpose operating systems (GPOSS)",
    "predicate": "are typically tuned for",
    "object": "average throughput"
  },
  {
    "subject": "DATE OF PUBLICATION",
    "predicate": "is",
    "object": "21 MARCH 2024"
  },
  {
    "subject": "DATE OF CURRENT VERSION",
    "predicate": "is",
    "object": "23 MAY 2024"
  },
  {
    "subject": "THIS WORK",
    "predicate": "was supported in part by",
    "object": "THE HORIZON KEY DIGITAL TECHNOLOGIES JOINT UNDERTAKING (KDT JU) PROGRAMME"
  },
  {
    "subject": "THE HORIZON KEY DIGITAL TECHNOLOGIES JOINT UNDERTAKING (KDT JU) PROGRAMME",
    "predicate": "supported through",
    "object": "THE TRISTAN PROJECT"
  },
  {
    "subject": "THE TRISTAN PROJECT",
    "predicate": "was under grant",
    "object": "101095947"
  },
  {
    "subject": "Robert Balas",
    "predicate": "is with",
    "object": "Integrated Systems Laboratory (IIS), ETH Zurich, 8092 Zurich, Switzerland"
  },
  {
    "subject": "Alessandro Ottaviano",
    "predicate": "is with",
    "object": "Integrated Systems Laboratory (IIS), ETH Zurich, 8092 Zurich, Switzerland"
  },
  {
    "subject": "Robert Balas",
    "predicate": "email",
    "object": "balas@iis.ee.ethz.ch"
  },
  {
    "subject": "Alessandro Ottaviano",
    "predicate": "email",
    "object": "aottaviano@iis.ee.ethz.ch"
  },
  {
    "subject": "Luca Benini",
    "predicate": "is with",
    "object": "the Integrated Systems Laboratory (IIS), ETH Zurich, Zurich, Switzerland"
  },
  {
    "subject": "Luca Benini",
    "predicate": "is with",
    "object": "the Department of Electrical, Electronic and Information Engineering (DEI), University of Bologna, 40126 Bologna, Italy"
  },
  {
    "subject": "color versions of one or more figures in this article",
    "predicate": "are available at",
    "object": "https://doi.org/10.1109/TVLSI.2024.3377130"
  },
  {
    "subject": "DIGITAL OBJECT IDENTIFIER",
    "predicate": "is",
    "object": "10.1109TVLSI.2024.3377130"
  },
  {
    "subject": "The development of Linux",
    "predicate": "is focused on",
    "object": "average performance"
  },
  {
    "subject": "Linux",
    "predicate": "is",
    "object": "a popular open-source GPOS kernel"
  },
  {
    "subject": "Linux",
    "predicate": "is less suitable to be used for",
    "object": "real-time applications"
  },
  {
    "subject": "Extensions and modifications",
    "predicate": "aim at",
    "object": "improving determinism and latencies of critical operations in Linux"
  },
  {
    "subject": "Extensions and modifications",
    "predicate": "have been",
    "object": "proposed and implemented"
  },
  {
    "subject": "Extensions and modifications",
    "predicate": "do not guarantee",
    "object": "strict bounds on maximum latencies of operations"
  },
  {
    "subject": "Extensions and modifications",
    "predicate": "lack",
    "object": "industry-grade maturity to be employed in hard real-time scenarios"
  },
  {
    "subject": "REAL-TIME OPERATING SYSTEMS (RTOSS) KERNELS",
    "predicate": "are",
    "object": "special-purpose operating systems (OSS)"
  },
  {
    "subject": "REAL-TIME OPERATING SYSTEMS (RTOSS) KERNELS",
    "predicate": "are designed to provide",
    "object": "real-time guarantees"
  },
  {
    "subject": "real-time guarantees",
    "predicate": "include",
    "object": "task scheduling according to a given expected completion deadline"
  },
  {
    "subject": "real-time guarantees",
    "predicate": "include",
    "object": "deterministic latencies of various operations"
  },
  {
    "subject": "A. STANKOVIC",
    "predicate": "authored",
    "object": "SCHEDULING ALGORITHMS AND OPERATING SYSTEMS SUPPORT FOR REAL-TIME SYSTEMS"
  },
  {
    "subject": "SCHEDULING ALGORITHMS AND OPERATING SYSTEMS SUPPORT FOR REAL-TIME SYSTEMS",
    "predicate": "published in",
    "object": "PROC."
  },
  {
    "subject": "The RTOS scheduler",
    "predicate": "might add",
    "object": "a significant overhead"
  },
  {
    "subject": "The significant overhead",
    "predicate": "is due to",
    "object": "the combined effect of both the context switches required to handle the transition from a foreground to a background task and the amount of time elapsed from the source event that causes the preemption and the first instruction of the awakened task"
  },
  {
    "subject": "The amount of time elapsed from the source event that causes the preemption and the first instruction of the awakened task",
    "predicate": "is known as",
    "object": "interrupt latency"
  },
  {
    "subject": "The significant overhead",
    "predicate": "thus increases",
    "object": "the worst case execution time (WCET)"
  },
  {
    "subject": "The cost of saving and restoring the task state during a context switch",
    "predicate": "is",
    "object": "a significant concern"
  },
  {
    "subject": "The cost of saving and restoring the task state during a context switch",
    "predicate": "remains",
    "object": "relatively high"
  },
  {
    "subject": "LONG CONTEXT SWITCH TIMES",
    "predicate": "reduce",
    "object": "AVAILABLE TASK UTILIZATION"
  },
  {
    "subject": "LONG CONTEXT SWITCH TIMES",
    "predicate": "reduce",
    "object": "THE MINIMUM VIABLE SWITCHING GRANULARITY"
  },
  {
    "subject": "process state",
    "predicate": "needs to be saved on",
    "object": "context switch"
  },
  {
    "subject": "process state",
    "predicate": "includes",
    "object": "program counter"
  },
  {
    "subject": "process state",
    "predicate": "includes",
    "object": "register files (RFs)"
  },
  {
    "subject": "process state",
    "predicate": "includes",
    "object": "status registers"
  },
  {
    "subject": "process state",
    "predicate": "includes",
    "object": "address space mapping"
  },
  {
    "subject": "A significant number of memory access operations",
    "predicate": "need to be performed",
    "object": "to store the state of the preempted task"
  },
  {
    "subject": "A significant number of memory access operations",
    "predicate": "need to be performed",
    "object": "to restore the state of the new task to be executed"
  },
  {
    "subject": "a switch into an interrupt context from normal program execution",
    "predicate": "happens each time",
    "object": "an asynchronous event is triggered from an IO peripheral device"
  },
  {
    "subject": "high overhead generated by the receiving of packets",
    "predicate": "can be seen in",
    "object": "continuous floods"
  },
  {
    "subject": "high overhead generated by the receiving of packets",
    "predicate": "can be seen in",
    "object": "short transmission bursts"
  },
  {
    "subject": "high overhead generated by the receiving of packets",
    "predicate": "reaches up to",
    "object": "50 task lateness"
  },
  {
    "subject": "task lateness",
    "predicate": "is",
    "object": "the additional time a task takes to finish than its deadline allows"
  },
  {
    "subject": "task lateness",
    "predicate": "will start to accumulate over",
    "object": "iterations from the critical network load increase per packet per second"
  },
  {
    "subject": "HW-induced interrupt latency",
    "predicate": "is",
    "object": "only one part of the problem"
  },
  {
    "subject": "SW-induced interrupt latency",
    "predicate": "is",
    "object": "part of the problem"
  },
  {
    "subject": "INTERRUPT LATENCY",
    "predicate": "is broken down into",
    "object": "SW-dependent contributions"
  },
  {
    "subject": "INTERRUPT LATENCY",
    "predicate": "is broken down into",
    "object": "HW-dependent contributions"
  },
  {
    "subject": "Personal use",
    "predicate": "is",
    "object": "permitted"
  },
  {
    "subject": "Republication redistribution",
    "predicate": "requires",
    "object": "IEEE permission"
  },
  {
    "subject": "AUTHORIZED LICENSED USE",
    "predicate": "is limited to",
    "object": "CALIFORNIA POLYTECHNIC STATE UNIVERSITY SAN LUIS OBISPO"
  },
  {
    "subject": "THE CLIC DESIGN",
    "predicate": "proposed in authorized licensed use limited to",
    "object": "CALIFORNIA POLYTECHNIC STATE UNIVERSITY SAN LUIS OBISPO"
  },
  {
    "subject": "interrupt state",
    "predicate": "gets pushed",
    "object": "this"
  },
  {
    "subject": "The latter",
    "predicate": "reduces",
    "object": "the execution time of the authorized licensed use limited to California Polytechnic State University San Luis Obispo"
  },
  {
    "subject": "document",
    "predicate": "was downloaded on",
    "object": "May 28, 2025 at 17:50:39 UTC"
  },
  {
    "subject": "document",
    "predicate": "was downloaded from",
    "object": "IEEE Xplore"
  },
  {
    "subject": "CV32RT",
    "predicate": "enables",
    "object": "fast interrupt and context switching"
  },
  {
    "subject": "fast interrupt and context switching",
    "predicate": "is introduced by",
    "object": "the GPOSRTOS scheduler and the user code"
  },
  {
    "subject": "fast interrupt and context switching",
    "predicate": "primarily impacts",
    "object": "the capability of the system to provide timely responses to asynchronous events"
  },
  {
    "subject": "Table I",
    "predicate": "describes",
    "object": "nested interrupt preemption scheme according to RISC-V CLIC"
  },
  {
    "subject": "CV32RTFASTIRQ",
    "predicate": "optimizes",
    "object": "interrupt latency in the non-nested interrupt case"
  },
  {
    "subject": "CV32RTFASTIRQ",
    "predicate": "optimizes",
    "object": "interrupt latency in the nested interrupt case"
  },
  {
    "subject": "CV32RTFASTIRQ",
    "predicate": "combines",
    "object": "bank switching and the nested interrupt case with an automatic context-saving mechanism in the background"
  },
  {
    "subject": "CV32RTFASTIRQ",
    "predicate": "is",
    "object": "FAST INTERRUPT EXTENSION"
  },
  {
    "subject": "CV32RTFASTIRQ",
    "predicate": "has",
    "object": "automatic hardware context saving and bank switching"
  },
  {
    "subject": "block diagram",
    "predicate": "of",
    "object": "CV32RTFASTIRQ"
  },
  {
    "subject": "pointer",
    "predicate": "is set",
    "object": "appropriately before triggering an SW interrupt"
  },
  {
    "subject": "SW interrupt",
    "predicate": "is triggered by",
    "object": "write to CLICS memory map"
  },
  {
    "subject": "CV32RT",
    "predicate": "enables",
    "object": "fast interrupt and context switching 1043 instruction in machine mode (i.e., EMRET)"
  },
  {
    "subject": "EMRET",
    "predicate": "is able to",
    "object": "skip redundant context saving and restoring sequences"
  },
  {
    "subject": "EMRET",
    "predicate": "achieves this by",
    "object": "directly jumping to the next available interrupt handler"
  },
  {
    "subject": "Low interrupt latency and context switch time",
    "predicate": "are",
    "object": "crucial metrics"
  },
  {
    "subject": "Crucial metrics",
    "predicate": "apply to",
    "object": "a wide range of platforms"
  },
  {
    "subject": "Platforms",
    "predicate": "range from",
    "object": "commodity MCU-class embedded systems to more advanced and complex application-class mixed criticality systems (MCSS)"
  },
  {
    "subject": "Timesafety-critical and non-critical applications",
    "predicate": "coexist on",
    "object": "different isolated partitions of the same HW platform"
  },
  {
    "subject": "response and context switch time minimization",
    "predicate": "become",
    "object": "a challenge to be tackled at the HWSW interface"
  },
  {
    "subject": "SW programming techniques and HW interrupt controller architectures",
    "predicate": "can cooperate",
    "object": "to ensure minimal response time"
  },
  {
    "subject": "commercial vendors and IP providers",
    "predicate": "offer",
    "object": "such features as in-house solutions"
  },
  {
    "subject": "such features as in-house solutions",
    "predicate": "are",
    "object": "often proprietary"
  },
  {
    "subject": "such features as in-house solutions",
    "predicate": "are",
    "object": "tightly coupled with the vendors instruction set architecture (ISA), target HW family, and associated SW stack"
  },
  {
    "subject": "RISC-V ecosystem",
    "predicate": "has been offering",
    "object": "a modular, free, and open-source ISA"
  },
  {
    "subject": "RISC-V ecosystem",
    "predicate": "is becoming",
    "object": "the de facto lingua franca of computing"
  },
  {
    "subject": "RISC-V support for fast interrupt and context switch handling",
    "predicate": "is not mature enough to compete with",
    "object": "incumbent proprietary architectures"
  },
  {
    "subject": "RISC-V support for fast interrupt and context switch handling",
    "predicate": "lacks",
    "object": "flexible interrupt prioritization"
  },
  {
    "subject": "RISC-V support for fast interrupt and context switch handling",
    "predicate": "lacks",
    "object": "preemption mechanisms"
  },
  {
    "subject": "RISC-V support for fast interrupt and context switch handling",
    "predicate": "lacks",
    "object": "low interrupt latency"
  },
  {
    "subject": "interrupt handlers",
    "predicate": "support",
    "object": "nesting"
  },
  {
    "subject": "interrupt handlers",
    "predicate": "support",
    "object": "calling of C-functions within it"
  },
  {
    "subject": "calling of C-functions within interrupt handlers",
    "predicate": "involves",
    "object": "saving and restoring state following the C-ABI"
  },
  {
    "subject": "various flavors of RISC-V core-specific interrupt controllers",
    "predicate": "have",
    "object": "interrupt latency"
  },
  {
    "subject": "our design",
    "predicate": "can achieve",
    "object": "interrupt latencies of six clock cycles"
  },
  {
    "subject": "our design",
    "predicate": "can achieve",
    "object": "efficient back-to-back interrupt handling in 12 cycles"
  },
  {
    "subject": "interrupt latencies of six clock cycles and efficient back-to-back interrupt handling in 12 cycles",
    "predicate": "is as low as",
    "object": "the fastest available approaches currently implemented in the RISC-V landscape"
  },
  {
    "subject": "the fastest available approaches currently implemented in the RISC-V landscape",
    "predicate": "are",
    "object": "fully open-source"
  },
  {
    "subject": "the fastest available approaches currently implemented in the RISC-V landscape",
    "predicate": "are",
    "object": "competitive against closed-source and proprietary commercial solutions"
  },
  {
    "subject": "We",
    "predicate": "make available",
    "object": "the implementation under a permissive open-source license"
  },
  {
    "subject": "We",
    "predicate": "design",
    "object": "a fast interrupt extension (FASTIRQ)"
  },
  {
    "subject": "FASTIRQ",
    "predicate": "accelerates",
    "object": "both nested and non-nested interrupt case scenarios"
  },
  {
    "subject": "FASTIRQ",
    "predicate": "reduces",
    "object": "interrupt latency"
  },
  {
    "subject": "FASTIRQ",
    "predicate": "reduces interrupt latency by",
    "object": "hiding the latency through memory banks and a background-saving mechanism"
  },
  {
    "subject": "CLINT",
    "predicate": "have",
    "object": "about 33 cycles interrupt latency"
  },
  {
    "subject": "CLIC",
    "predicate": "have",
    "object": "about 33 cycles interrupt latency"
  },
  {
    "subject": "FASTIRQ extension",
    "predicate": "is able to reduce interrupt latency to",
    "object": "six cycles"
  },
  {
    "subject": "THE SAME MECHANISM",
    "predicate": "allows",
    "object": "one to accelerate context switching through HWSW cooperation"
  },
  {
    "subject": "We",
    "predicate": "propose",
    "object": "Early MRET (EMRET)"
  },
  {
    "subject": "Early MRET (EMRET)",
    "predicate": "is",
    "object": "a novel instruction"
  },
  {
    "subject": "Early MRET (EMRET)",
    "predicate": "optimizes",
    "object": "tail-chaining"
  },
  {
    "subject": "Early MRET (EMRET)",
    "predicate": "optimizes tail-chaining compared to",
    "object": "the baseline strategy proposed in the CLIC standard (i.e., XNXTI)"
  },
  {
    "subject": "Early MRET (EMRET)",
    "predicate": "optimizes tail-chaining compared to",
    "object": "its enhancement from 18 (JALXNXTI)"
  },
  {
    "subject": "We",
    "predicate": "compare",
    "object": "CV32RT with leading COTS systems in both nested and non-nested interrupt scenarios"
  },
  {
    "subject": "THE PROPOSED SOLUTION",
    "predicate": "PROMOTES",
    "object": "RISC-V AS A COMPETITIVE CANDIDATE FOR BUILDING THE NEXT GENERATION OF TIME-CRITICAL SYSTEMS"
  },
  {
    "subject": "THIS CORE",
    "predicate": "is embedded in",
    "object": "CONTROLPULP 19"
  },
  {
    "subject": "CONTROLPULP 19",
    "predicate": "is",
    "object": "a SoC specialized in running real-time workloads"
  },
  {
    "subject": "The manager core",
    "predicate": "is responsible for",
    "object": "scheduling tasks"
  },
  {
    "subject": "The manager core",
    "predicate": "is responsible for",
    "object": "communicating with the peripherals"
  },
  {
    "subject": "The manager core",
    "predicate": "is responsible for",
    "object": "offloading tasks to the accelerator subsystem"
  },
  {
    "subject": "The manager core",
    "predicate": "is responsible for",
    "object": "being responsive to asynchronous external events"
  },
  {
    "subject": "asynchronous external events",
    "predicate": "include",
    "object": "interrupts"
  },
  {
    "subject": "CONTROLPULP",
    "predicate": "hosts",
    "object": "a set of scratchpad memories (SPMs)"
  },
  {
    "subject": "scratchpad memories (SPMs)",
    "predicate": "guarantee",
    "object": "single-cycle access time from the CV32 manager core"
  },
  {
    "subject": "this design choice",
    "predicate": "enables",
    "object": "deterministic memory access latency for both data load, store, and instruction fetch"
  },
  {
    "subject": "this design choice",
    "predicate": "bounds",
    "object": "the worst case latency when handling unpredictable events"
  },
  {
    "subject": "Applications",
    "predicate": "run on top of",
    "object": "FreeRTOS 20"
  },
  {
    "subject": "FreeRTOS 20",
    "predicate": "is",
    "object": "an open-source, priority-based preemptive RTOS"
  },
  {
    "subject": "FreeRTOS 20",
    "predicate": "runs in",
    "object": "the manager core"
  },
  {
    "subject": "Tasks",
    "predicate": "are scheduled and run from",
    "object": "the manager core"
  },
  {
    "subject": "interrupt sources",
    "predicate": "can signal",
    "object": "interrupts"
  },
  {
    "subject": "interrupt sources",
    "predicate": "signal interrupts through",
    "object": "a level change of the interrupt line"
  },
  {
    "subject": "a level change of the interrupt line",
    "predicate": "is called",
    "object": "an edge-triggered interrupt"
  },
  {
    "subject": "interrupt sources",
    "predicate": "signal interrupts through",
    "object": "the logic level itself"
  },
  {
    "subject": "the logic level itself",
    "predicate": "is called",
    "object": "a level-triggered interrupt"
  },
  {
    "subject": "nested interrupts",
    "predicate": "entails",
    "object": "preemption of a low-level interrupt by a high-level interrupt"
  },
  {
    "subject": "Transition",
    "predicate": "is between",
    "object": "different interrupt levels"
  },
  {
    "subject": "the latter",
    "predicate": "requires",
    "object": "the receiving side of the interrupt to clear the source often through accessing appropriate HW registers"
  },
  {
    "subject": "the former",
    "predicate": "is",
    "object": "unidirectional notification without confirmation"
  },
  {
    "subject": "Interrupts",
    "predicate": "are",
    "object": "asynchronous events"
  },
  {
    "subject": "Interrupts",
    "predicate": "alter",
    "object": "the normal program order execution"
  },
  {
    "subject": "Interrupts",
    "predicate": "require",
    "object": "a switch to a different context to handle the event"
  },
  {
    "subject": "A processor",
    "predicate": "supports",
    "object": "vectored interrupts"
  },
  {
    "subject": "Each interrupt",
    "predicate": "traps to",
    "object": "a specific interrupt service routine (ISR)"
  },
  {
    "subject": "Trapping to a specific ISR",
    "predicate": "is according to",
    "object": "an interrupt vector table"
  },
  {
    "subject": "Vectored interrupts",
    "predicate": "grant",
    "object": "fast interrupt response"
  },
  {
    "subject": "Vectored interrupts",
    "predicate": "have",
    "object": "increased code size"
  },
  {
    "subject": "interrupt vectoring",
    "predicate": "is supported",
    "object": "to improve interrupt latencies"
  },
  {
    "subject": "NON-VECTORED OR DIRECT INTERRUPTS",
    "predicate": "trap to",
    "object": "a SHARED ISR"
  },
  {
    "subject": "THE LATTER APPROACH",
    "predicate": "trades off",
    "object": "code size for a slower interrupt response"
  },
  {
    "subject": "the overhead of resolving the interruption cause and jumping to the correct ISR",
    "predicate": "are handled in",
    "object": "explicit instructions"
  },
  {
    "subject": "the interrupt table",
    "predicate": "can be made",
    "object": "much more compact"
  },
  {
    "subject": "multiple sources",
    "predicate": "determine",
    "object": "interrupt latency in a system"
  },
  {
    "subject": "underlying HW",
    "predicate": "is a source of",
    "object": "interrupt latency"
  },
  {
    "subject": "scheduler or OS",
    "predicate": "is a source of",
    "object": "interrupt latency"
  },
  {
    "subject": "application running on top",
    "predicate": "is a source of",
    "object": "interrupt latency"
  },
  {
    "subject": "we",
    "predicate": "focus on",
    "object": "minimizing the latency imposed by the HW"
  },
  {
    "subject": "interrupt latency",
    "predicate": "means",
    "object": "its HW-contributed part"
  },
  {
    "subject": "THE LATTER",
    "predicate": "consists of",
    "object": "restoring the interrupt context and the regular interrupt latency"
  },
  {
    "subject": "Interrupt latency",
    "predicate": "is defined as",
    "object": "the time it takes from an interrupt edge arriving at the HW, usually the interrupt controller, to the execution of the first instruction of the corresponding interrupt handler routine"
  },
  {
    "subject": "interrupt latency",
    "predicate": "is measured as",
    "object": "the number of cycles it takes for an interrupt to arrive at the interrupt controller input to the first instruction of an interrupt handler that allows the calling of a C-function"
  },
  {
    "subject": "we",
    "predicate": "have to delineate",
    "object": "what exactly constitutes the first instruction of the interrupt handler"
  },
  {
    "subject": "each HW configuration",
    "predicate": "has",
    "object": "a handwritten optimized interrupt handler"
  },
  {
    "subject": "handwritten optimized interrupt handler",
    "predicate": "stores",
    "object": "all required general-purpose and machine-specific registers for nesting interrupts"
  },
  {
    "subject": "the first instruction",
    "predicate": "is",
    "object": "the one after all necessary interrupt context has been saved on the stack to be able to call a function"
  },
  {
    "subject": "interrupt handler and interrupt context saving code",
    "predicate": "can be interleaved",
    "object": "true"
  },
  {
    "subject": "some of the context saving code",
    "predicate": "can be removed",
    "object": "true"
  },
  {
    "subject": "some of the context saving code",
    "predicate": "might be",
    "object": "redundant"
  },
  {
    "subject": "THE ACTIVE INTERRUPT HANDLERS CONTEXT",
    "predicate": "MUST BE RESTORED ON",
    "object": "INTERRUPT RETURN"
  },
  {
    "subject": "THE ACTIVE INTERRUPT HANDLERS CONTEXT",
    "predicate": "IS IMMEDIATELY SAVED AGAIN DUE TO",
    "object": "THE NEXT PENDING INTERRUPT FIRING"
  },
  {
    "subject": "restoring the pre-interrupt context",
    "predicate": "is handled in",
    "object": "SW for the nested interrupt case"
  },
  {
    "subject": "context switching time",
    "predicate": "determines",
    "object": "the responsiveness of the architecture in swapping from one execution context to another"
  },
  {
    "subject": "Preemption",
    "predicate": "refers to",
    "object": "an event such as an interrupt request"
  },
  {
    "subject": "An interrupt request",
    "predicate": "temporarily interrupts",
    "object": "a current task"
  },
  {
    "subject": "The purpose of preemption",
    "predicate": "is",
    "object": "resuming its execution later"
  },
  {
    "subject": "The simplest case for preemption",
    "predicate": "occurs with",
    "object": "non-nested interrupt handlers"
  },
  {
    "subject": "Interrupts",
    "predicate": "are globally disabled during",
    "object": "the execution of an ISR"
  },
  {
    "subject": "A more complex case for preemption",
    "predicate": "occurs with",
    "object": "nested interrupt handlers"
  },
  {
    "subject": "Nested interrupt handlers",
    "predicate": "handle",
    "object": "the case of multiple interrupts at a time"
  },
  {
    "subject": "THIS SITUATION",
    "predicate": "does not result in",
    "object": "PREEMPTION"
  },
  {
    "subject": "THIS SITUATION",
    "predicate": "causes",
    "object": "PENDING INTERRUPTS TO BE SERVICED IN SEQUENCE ACCORDING TO INCREASING PRIORITY"
  },
  {
    "subject": "LEVELPRIORITY arbitration",
    "predicate": "is",
    "object": "SW-driven"
  },
  {
    "subject": "SW-driven LEVELPRIORITY arbitration",
    "predicate": "uses",
    "object": "priority simplestandard interrupt handlers"
  },
  {
    "subject": "highest priority interrupt identification code",
    "predicate": "is not executed",
    "object": null
  },
  {
    "subject": "LEVELPRIORITY arbitration logic",
    "predicate": "is designed within",
    "object": "interrupt controller"
  },
  {
    "subject": "highest LEVELPRIORITY interrupt",
    "predicate": "is",
    "object": "pending but disabled"
  },
  {
    "subject": "highest LEVELPRIORITY interrupt",
    "predicate": "is not propagated to",
    "object": "core"
  },
  {
    "subject": "A levelpriority interrupt scheme",
    "predicate": "introduces",
    "object": "additional masking of incoming interrupts of equal or lower levelpriority than the executing ISR"
  },
  {
    "subject": "A levelpriority interrupt scheme",
    "predicate": "introduces",
    "object": "additional masking of incoming interrupts sometimes larger than a configurable levelpriority threshold"
  },
  {
    "subject": "A levelpriority interrupt scheme",
    "predicate": "can be",
    "object": "either software or hardware driven"
  },
  {
    "subject": "this scenario",
    "predicate": "is not ideal for",
    "object": "real-time and complex embedded systems"
  },
  {
    "subject": "interrupts",
    "predicate": "are served",
    "object": "sequentially"
  },
  {
    "subject": "A HIGH-PRIORITY INTERRUPT",
    "predicate": "has to wait for",
    "object": "A LOWER-PRIORITY INTERRUPT TO FINISH"
  },
  {
    "subject": "interrupts",
    "predicate": "are enabled",
    "object": "globally within the scope of an executing ISR"
  },
  {
    "subject": "interrupt handler",
    "predicate": "is entered",
    "object": "global interrupts are disabled"
  },
  {
    "subject": "ISR",
    "predicate": "need to be",
    "object": "carefully designed"
  },
  {
    "subject": "ISR",
    "predicate": "are designed to ensure",
    "object": "they are reentrant"
  },
  {
    "subject": "THE NESTING",
    "predicate": "allows",
    "object": "higher priority interrupts to preempt a current lower priority ISR executing"
  },
  {
    "subject": "Back-to-back interrupts",
    "predicate": "are",
    "object": "interrupts that need to be served sequentially"
  },
  {
    "subject": "Back-to-back interrupts",
    "predicate": "can happen",
    "object": "whenever there are multiple interrupts pending"
  },
  {
    "subject": "The transition from one interrupt to the next one",
    "predicate": "causes",
    "object": "a redundant sequence of context restores and context saves"
  },
  {
    "subject": "Redundant context restore sequences",
    "predicate": "negatively impact",
    "object": "interrupt latency on higher interrupt loads"
  },
  {
    "subject": "Redundant context restore with non-nested or nested horizontal interrupts",
    "predicate": "can introduce",
    "object": "unwanted additional interrupt latency"
  },
  {
    "subject": "REDUNDANT CONTEXT RESTORE",
    "predicate": "applies to",
    "object": "TWO NON-PREEMPTIVE INTERRUPTS"
  },
  {
    "subject": "TWO NON-PREEMPTIVE INTERRUPTS",
    "predicate": "example",
    "object": "TWO INTERRUPTS WITH SAME LEVEL BUT DIFFERENT PRIORITIES"
  },
  {
    "subject": "TAIL-CHAINING",
    "predicate": "used to",
    "object": "OPTIMIZE IT"
  },
  {
    "subject": "interrupt context restore and store sequence between back-to-back interrupts",
    "predicate": "can be considered",
    "object": "redundant"
  },
  {
    "subject": "REDUNDANT CONTEXT RESTORING SEQUENCES",
    "predicate": "contains",
    "object": "FULL INTERRUPT EXIT CODE SEQUENCE"
  },
  {
    "subject": "Redundant context restore with non-nested interrupts",
    "predicate": "is addressed by",
    "object": "chaining two back-to-back interrupts and bypassing the superfluous restore-save operation"
  },
  {
    "subject": "SECTION III-D",
    "predicate": "explores",
    "object": "the optimizations implemented in this work to address this scenario"
  },
  {
    "subject": "The privileged specification 14",
    "predicate": "defines",
    "object": "a simple interrupt scheme with a set of timer and inter-processor interrupts"
  },
  {
    "subject": "The simple interrupt scheme",
    "predicate": "is in",
    "object": "the RISC-V ecosystem"
  },
  {
    "subject": "pending and enabled interrupts",
    "predicate": "are masked",
    "object": "according to a threshold value representing an interrupt level"
  },
  {
    "subject": "threshold value representing an interrupt level",
    "predicate": "is configured through",
    "object": "a CSR"
  },
  {
    "subject": "32-bit cores",
    "predicate": "define",
    "object": "a fixed priority interrupt scheme"
  },
  {
    "subject": "fixed priority interrupt scheme",
    "predicate": "has",
    "object": "16 predefined or reserved interrupts"
  },
  {
    "subject": "fixed priority interrupt scheme",
    "predicate": "has",
    "object": "16 implementation-defined interrupts"
  },
  {
    "subject": "16 predefined or reserved interrupts and 16 implementation-defined interrupts",
    "predicate": "can be",
    "object": "optionally vectored"
  },
  {
    "subject": "THE CLINT ITSELF",
    "predicate": "supports",
    "object": "prioritization of interrupts based on privilege mode"
  },
  {
    "subject": "CLINT-MODE",
    "predicate": "has",
    "object": "inflexible interrupt scheme"
  },
  {
    "subject": "inflexible interrupt scheme of the CLINT-MODE",
    "predicate": "causes",
    "object": "much more work to be done in managing interrupt mask (SOMEIRQMASK) and other machine state"
  },
  {
    "subject": "interrupts with lower priority than the current interrupt running",
    "predicate": "can fire",
    "object": "in CLINT-mode when global interrupts are re-enabled"
  },
  {
    "subject": "the Clint",
    "predicate": "lacks",
    "object": "fine-grained control over interrupt prioritization"
  },
  {
    "subject": "PLIC 22",
    "predicate": "can be attached to",
    "object": "the CLINT"
  },
  {
    "subject": "PLIC 22",
    "predicate": "increases",
    "object": "the number of custom interrupts"
  },
  {
    "subject": "an interrupt request IRQ2",
    "predicate": "is being serviced",
    "object": ""
  },
  {
    "subject": "another request IRQ1",
    "predicate": "is enabled and pending",
    "object": ""
  },
  {
    "subject": "an active interrupt handler",
    "predicate": "is servicing",
    "object": "IRQ2"
  },
  {
    "subject": "IRQ1",
    "predicate": "is",
    "object": "pending"
  },
  {
    "subject": "interrupts that are assigned a higher level",
    "predicate": "can pre-empt",
    "object": "lower-level interrupts"
  },
  {
    "subject": "A single hart",
    "predicate": "can correspond to",
    "object": "multiple targets"
  },
  {
    "subject": "each interrupt",
    "predicate": "can be assigned",
    "object": "a priority"
  },
  {
    "subject": "each target",
    "predicate": "can select",
    "object": "a threshold"
  },
  {
    "subject": "interrupts",
    "predicate": "are disabled",
    "object": "below the threshold"
  },
  {
    "subject": "INTERRUPT SELECTION",
    "predicate": "is driven by",
    "object": "the CLIC in HW"
  },
  {
    "subject": "the CLIC in HW",
    "predicate": "propagates",
    "object": "the highest level, highest priority pending interrupt to the cores interface"
  },
  {
    "subject": "Interrupt priority",
    "predicate": "serves as",
    "object": "a tie-breaker for the case of multiple interrupts pending with the same level"
  },
  {
    "subject": "enabled interrupts and their level and priority information",
    "predicate": "are sent to",
    "object": "prioritization logic"
  },
  {
    "subject": "prioritization logic",
    "predicate": "uses",
    "object": "a binary arbitration tree"
  },
  {
    "subject": "a binary arbitration tree",
    "predicate": "selects",
    "object": "the highest-level interrupt"
  },
  {
    "subject": "interrupts",
    "predicate": "can be assigned",
    "object": "a priority"
  },
  {
    "subject": "interrupts",
    "predicate": "can be assigned",
    "object": "a level"
  },
  {
    "subject": "The priorities",
    "predicate": "allow",
    "object": "concurrent pending interrupts to be taken in the order preferred by the programmer"
  },
  {
    "subject": "The level information",
    "predicate": "enables",
    "object": "pre-emption of same-privilege level interrupts"
  },
  {
    "subject": "same-privilege level interrupts",
    "predicate": "are also called",
    "object": "horizontal interrupts"
  },
  {
    "subject": "THIS SCHEME",
    "predicate": "allows",
    "object": "interrupts to be divided according to their priorities on the PLIC-level"
  },
  {
    "subject": "THIS SCHEME",
    "predicate": "allows",
    "object": "some flexibility in terms of prioritization"
  },
  {
    "subject": "THIS SCHEME",
    "predicate": "does not address",
    "object": "the flexibility problem on the core local-level"
  },
  {
    "subject": "CLIC 15",
    "predicate": "addresses",
    "object": "these limitations"
  },
  {
    "subject": "CLIC 15",
    "predicate": "allows",
    "object": "interrupts to be prioritized by so-called levels and priorities"
  },
  {
    "subject": "multiple horizontal interrupts",
    "predicate": "have",
    "object": "equal levels and priorities"
  },
  {
    "subject": "the CLIC",
    "predicate": "selects",
    "object": "the highest numbered interrupt (identification number ID 15)"
  },
  {
    "subject": "the highest numbered interrupt (identification number ID 15)",
    "predicate": "is",
    "object": "an arbitrary assignment decided at design time"
  },
  {
    "subject": "this feature",
    "predicate": "is useful for",
    "object": "RTOSs that only want to disable a subset of all interrupts during critical sections"
  },
  {
    "subject": "interrupts that do not interfere with the data accessed in such a critical section",
    "predicate": "can",
    "object": "still fire"
  },
  {
    "subject": "IRQ1",
    "predicate": "preempts",
    "object": "IRQ2"
  },
  {
    "subject": "IRQ1",
    "predicate": "preempts IRQ2 when",
    "object": "its level is higher than both the interrupt threshold and IRQ2's level"
  },
  {
    "subject": "interrupts fired from different privilege modes",
    "predicate": "are referred to as",
    "object": "vertical interrupts"
  },
  {
    "subject": "interrupts fired from the same privilege mode",
    "predicate": "are referred to as",
    "object": "horizontal interrupts"
  },
  {
    "subject": "TABLE I",
    "predicate": "shows",
    "object": "preemption conditions of two nested interrupts IRQ2 and IRQ1 according to the CLIC specification"
  },
  {
    "subject": "THE CLIC SPECIFICATION",
    "predicate": "addresses",
    "object": "the case of redundant context restore (see Section II-B6)"
  },
  {
    "subject": "XNXTI",
    "predicate": "is",
    "object": "a CSR short for next interrupt handler address"
  },
  {
    "subject": "XNXTI and interrupt-enable CSRs",
    "predicate": "are meant for use with",
    "object": "non-vectored interrupts"
  },
  {
    "subject": "READING FROM THIS CSR",
    "predicate": "allows",
    "object": "to fast-track interrupts that arrive late"
  },
  {
    "subject": "READING FROM THIS CSR",
    "predicate": "allows",
    "object": "to avoid redundant context save-restore by running through pending interrupts back-to-back"
  },
  {
    "subject": "the core",
    "predicate": "is within",
    "object": "an active handler"
  },
  {
    "subject": "architecture entering an interrupt context or performing a context switch",
    "predicate": "requires",
    "object": "the HW to store enough information to resume operation correctly after returning from the aforementioned context"
  },
  {
    "subject": "We",
    "predicate": "can improve",
    "object": "interrupt latency and context switch times"
  },
  {
    "subject": "Improving interrupt latency and context switch times",
    "predicate": "can be done by",
    "object": "controlling the amount of state that needs to be preserved to enter and leave an interrupt context"
  },
  {
    "subject": "Improving interrupt latency and context switch times",
    "predicate": "can be done by",
    "object": "increasing the bandwidth and decreasing the latency to memory"
  },
  {
    "subject": "Improving interrupt latency and context switch times",
    "predicate": "can be done by",
    "object": "relying on latency-hiding techniques that defer the effective saving of the state to a later point in time"
  },
  {
    "subject": "CV32RT",
    "predicate": "has",
    "object": "architectural features and HWSW codesign"
  },
  {
    "subject": "proposed architecture",
    "predicate": "tackles",
    "object": "typical case scenarios"
  },
  {
    "subject": "THE BACKGROUND-SAVING MECHANISM",
    "predicate": "UPDATES",
    "object": "THE STACK POINTER"
  },
  {
    "subject": "THE BACKGROUND-SAVING MECHANISM",
    "predicate": "STORES",
    "object": "THE BANK-SWITCHED CONTENTS IN MEMORY"
  },
  {
    "subject": "THE EXECUTION OF THE CORE",
    "predicate": "PROCEEDS",
    "object": "IN PARALLEL"
  },
  {
    "subject": "2",
    "predicate": "provides",
    "object": "an overview of the design"
  },
  {
    "subject": "interrupts",
    "predicate": "arrive at",
    "object": "the gateway"
  },
  {
    "subject": "interrupts",
    "predicate": "are combined with",
    "object": "programmable configuration information"
  },
  {
    "subject": "programmable configuration information",
    "predicate": "is about",
    "object": "each interrupt line"
  },
  {
    "subject": "programmable configuration information",
    "predicate": "consists of",
    "object": "level, priority, enable status, and sensitivity (leveledge)"
  },
  {
    "subject": "THE INTERRUPT PRIORITIZATION MODULE",
    "predicate": "TRAVERSES",
    "object": "THE TREE FROM LEAVES TO THE ROOT"
  },
  {
    "subject": "THE SOUGHT-AFTER MAXIMUM LEVEL AND PRIORITY INTERRUPT",
    "predicate": "IS FOUND",
    "object": "AT THE ROOT"
  },
  {
    "subject": "each tree",
    "predicate": "has",
    "object": "low overhead in terms of area and delay"
  },
  {
    "subject": "overhead in terms of area",
    "predicate": "is",
    "object": "O(N)"
  },
  {
    "subject": "overhead in terms of delay",
    "predicate": "is",
    "object": "O(LOG(N))"
  },
  {
    "subject": "THE INTERRUPT",
    "predicate": "is presented to",
    "object": "THE CORE"
  },
  {
    "subject": "THE INTERRUPT",
    "predicate": "is presented with",
    "object": "A HANDSHAKE-BASED INTERFACE"
  },
  {
    "subject": "The additional kill signal",
    "predicate": "is there to allow for",
    "object": "a handshake to restart"
  },
  {
    "subject": "A handshake",
    "predicate": "allows",
    "object": "a potentially more important interrupt to be presented to the core"
  },
  {
    "subject": "THIS WORK",
    "predicate": "can scale up to",
    "object": "N 4096 LOCAL INTERRUPT SOURCES"
  },
  {
    "subject": "additional pipeline stages",
    "predicate": "can be inserted",
    "object": "in the arbitration tree"
  },
  {
    "subject": "additional pipeline stages",
    "predicate": "can be inserted to",
    "object": "relax timing"
  },
  {
    "subject": "OUR VERSION OF THE CLIC",
    "predicate": "supports",
    "object": "SHV"
  },
  {
    "subject": "OUR VERSION OF THE CLIC",
    "predicate": "supports",
    "object": "THE XNXTI CSR IN THE CORE"
  },
  {
    "subject": "CV32",
    "predicate": "has",
    "object": "interrupt handling capabilities"
  },
  {
    "subject": "interrupt handling capabilities of CV32",
    "predicate": "are improved by",
    "object": "introducing priority and levels management in HW"
  },
  {
    "subject": "critical operations such as interrupt state and context save/restore",
    "predicate": "are not natively covered by",
    "object": "the CLIC"
  },
  {
    "subject": "critical operations such as interrupt state and context save/restore",
    "predicate": "need to be handled in",
    "object": "SW"
  },
  {
    "subject": "CV32FASTIRQ",
    "predicate": "aims at",
    "object": "filling this gap"
  },
  {
    "subject": "THE CLIC",
    "predicate": "addresses",
    "object": "this with the LEVELPRIORITY scheme"
  },
  {
    "subject": "FASTIRQ",
    "predicate": "improves upon",
    "object": "that"
  },
  {
    "subject": "FASTIRQ",
    "predicate": "improves upon that by",
    "object": "moving the interrupt state saving logic in HW"
  },
  {
    "subject": "FASTIRQ",
    "predicate": "improves upon that by",
    "object": "adding EMRET to handle redundant interrupt context sequences"
  },
  {
    "subject": "FASTIRQ",
    "predicate": "is",
    "object": "a wrapper around the cores RF"
  },
  {
    "subject": "We",
    "predicate": "extend",
    "object": "the RF by an additional read port for the background-saving mechanism"
  },
  {
    "subject": "We",
    "predicate": "extend",
    "object": "registers for latching the additional processor state required for proper interrupt nesting"
  },
  {
    "subject": "A new interrupt at the CLIC",
    "predicate": "will be checked",
    "object": "whether the interrupt level exceeds the configured threshold"
  },
  {
    "subject": "THE CORES STATE MACHINE",
    "predicate": "will flush",
    "object": "the pipeline"
  },
  {
    "subject": "THE CORES STATE MACHINE",
    "predicate": "will update",
    "object": "the program counter"
  },
  {
    "subject": "the program counter",
    "predicate": "is updated according to",
    "object": "the vector table entry"
  },
  {
    "subject": "the saving logic",
    "predicate": "triggers",
    "object": "a bank switch"
  },
  {
    "subject": "the bank switch",
    "predicate": "allows",
    "object": "the interrupt context to have a fresh set of registers"
  },
  {
    "subject": "the other bank contents",
    "predicate": "are drained through",
    "object": "a separate port to the main memory"
  },
  {
    "subject": "RF BANKS",
    "predicate": "are switched",
    "object": "on an interrupt"
  },
  {
    "subject": "we",
    "predicate": "need to update",
    "object": "the stack pointer during a bank switch"
  },
  {
    "subject": "we",
    "predicate": "have",
    "object": "a dedicated adder between the two RFs"
  },
  {
    "subject": "THE RISC-V EMBEDDED AND INTEGER ABI",
    "predicate": "dictate",
    "object": "THE STACK POINTER POINTS BELOW THE LAST SAVED REGISTER ON THE STACK"
  },
  {
    "subject": "THE STACK POINTER",
    "predicate": "IS ADJUSTED",
    "object": "APPROPRIATELY TO MAINTAIN ABI INVARIANTS"
  },
  {
    "subject": "the program code running in the interrupt handler",
    "predicate": "could clobber",
    "object": "the values on the stack"
  },
  {
    "subject": "We",
    "predicate": "could do away with",
    "object": "this mechanism for leaf-type interrupts"
  },
  {
    "subject": "Doing away with this mechanism for leaf-type interrupts",
    "predicate": "would require",
    "object": "a new ABI considering a virtual stack pointer offset when generating code for interrupt handlers"
  },
  {
    "subject": "Doing away with this mechanism for leaf-type interrupts",
    "predicate": "would not solve",
    "object": "the nested interrupt case"
  },
  {
    "subject": "interactions",
    "predicate": "exist between",
    "object": "background-saving mechanism and regular loadstore instructions of the core"
  },
  {
    "subject": "interactions",
    "predicate": "could result in",
    "object": "incorrect execution"
  },
  {
    "subject": "A load instruction",
    "predicate": "is trying to update",
    "object": "an architectural register"
  },
  {
    "subject": "The background-saving mechanism",
    "predicate": "is trying to read",
    "object": "the same register"
  },
  {
    "subject": "No conflict",
    "predicate": "arises",
    "object": "when a load instruction is trying to update an architectural register while the background-saving mechanism is trying to read the same register"
  },
  {
    "subject": "Interrupts",
    "predicate": "are injected into",
    "object": "the pipeline"
  },
  {
    "subject": "Interrupts",
    "predicate": "are only acted upon in",
    "object": "the write-back stage of the core"
  },
  {
    "subject": "updates to the RF",
    "predicate": "are resolved",
    "object": "at this point"
  },
  {
    "subject": "the bank switching operation",
    "predicate": "takes place",
    "object": "after updates to the RF are resolved"
  },
  {
    "subject": "the bank switching operation",
    "predicate": "ensures",
    "object": "correctness of the execution"
  },
  {
    "subject": "loads or stores accessing stack memory regions where the background-saving mechanism is writing to",
    "predicate": "need to be",
    "object": "properly resolved"
  },
  {
    "subject": "execution of the handler",
    "predicate": "has to wait",
    "object": "if this happens while the background-saving mechanism is still at work"
  },
  {
    "subject": "we",
    "predicate": "could read",
    "object": "stale data"
  },
  {
    "subject": "we",
    "predicate": "could write",
    "object": "data that is immediately overwritten"
  },
  {
    "subject": "the load-store unit of the core",
    "predicate": "is informed of",
    "object": "the ongoing state being written to memory"
  },
  {
    "subject": "A straightforward solution",
    "predicate": "is to",
    "object": "stall the cores pipeline while the background-saving mechanism is at work"
  },
  {
    "subject": "WE",
    "predicate": "want to issue",
    "object": "A LOAD SOON IN THE INTERRUPT HANDLER"
  },
  {
    "subject": "the load-store unit",
    "predicate": "tries to access",
    "object": "the memory in the range of the stack pointer"
  },
  {
    "subject": "the stack pointer",
    "predicate": "is decremented",
    "object": "on an interrupt"
  },
  {
    "subject": "decrementing the stack pointer",
    "predicate": "makes",
    "object": "space available"
  },
  {
    "subject": "the background-saving mechanism",
    "predicate": "will start storing",
    "object": "the interrupt state word by word"
  },
  {
    "subject": "the address offset of the last word pushed out by the background-saving mechanism",
    "predicate": "is compared against",
    "object": "any incoming load and stores"
  },
  {
    "subject": "LOAD AND STORES THAT TRY TO ACCESS DATA THAT IS NOT YET PUSHED TO MEMORY",
    "predicate": "CAUSE",
    "object": "THE CORES PIPELINE TO STALL"
  },
  {
    "subject": "THIS MECHANISM",
    "predicate": "ensures",
    "object": "THE CORRECTNESS OF LOADS AND STORES ISSUED BY THE CORE"
  },
  {
    "subject": "Accessing stack memory locations during the execution of an interrupt handler",
    "predicate": "happens in",
    "object": "two use cases"
  },
  {
    "subject": "A SYSTEM CALL HANDLER",
    "predicate": "is issued through",
    "object": "the ECALL instruction in RISC-V"
  },
  {
    "subject": "A SYSTEM CALL HANDLER",
    "predicate": "wants to access",
    "object": "user-provided arguments"
  },
  {
    "subject": "most",
    "predicate": "will be passed through",
    "object": "general-purpose registers"
  },
  {
    "subject": "some",
    "predicate": "might be placed on",
    "object": "the stack"
  },
  {
    "subject": "short interrupt handlers",
    "predicate": "want to return before",
    "object": "the full interrupt state has been saved"
  },
  {
    "subject": "each of these cases",
    "predicate": "would potentially engage",
    "object": "the stalling logic outlined in Section III-C3"
  },
  {
    "subject": "engaging the stalling logic outlined in Section III-C3",
    "predicate": "causes",
    "object": "higher interrupt latencies"
  },
  {
    "subject": "a hardware solution",
    "predicate": "would be to add",
    "object": "forwarding logic"
  },
  {
    "subject": "forwarding logic",
    "predicate": "checks in",
    "object": "the load-store unit"
  },
  {
    "subject": "forwarding logic",
    "predicate": "checks",
    "object": "what is being written by the background-saving mechanism"
  },
  {
    "subject": "forwarding logic",
    "predicate": "forwards",
    "object": "these values from the store queue"
  },
  {
    "subject": "these values",
    "predicate": "are forwarded from",
    "object": "the store queue"
  },
  {
    "subject": "these values",
    "predicate": "are forwarded instead of going through",
    "object": "the memory subsystem outside the core"
  },
  {
    "subject": "some register values",
    "predicate": "cannot be forwarded",
    "object": "because they might not have reached the load-store unit yet"
  },
  {
    "subject": "THE APPROACH",
    "predicate": "INCREASES",
    "object": "HW COMPLEXITY"
  },
  {
    "subject": "THE APPROACH",
    "predicate": "REQUIRES",
    "object": "A DYNAMIC ADDRESS LOOKUP INTO A QUEUE-LIKE BUFFER"
  },
  {
    "subject": "We",
    "predicate": "propose",
    "object": "an SW-based solution that does not cause any kind of stalling"
  },
  {
    "subject": "we",
    "predicate": "do not need to engage",
    "object": "the pipeline stalling logic by ordering the loads to access the already stored interrupt state first"
  },
  {
    "subject": "we",
    "predicate": "give",
    "object": "an analysis of the functional improvements"
  },
  {
    "subject": "THE CV32S RF",
    "predicate": "is extended with",
    "object": "additional logic for the background-saving mechanism"
  },
  {
    "subject": "parts of the old memory bank (the interrupt context)",
    "predicate": "are copied to",
    "object": "the cores stack location"
  },
  {
    "subject": "execution",
    "predicate": "can go ahead by using",
    "object": "the new bank"
  },
  {
    "subject": "this design",
    "predicate": "has",
    "object": "a dedicated memory port for the background-saving mechanism"
  },
  {
    "subject": "the dedicated memory port",
    "predicate": "can be shared with",
    "object": "the port from the load-store unit"
  },
  {
    "subject": "we",
    "predicate": "push out",
    "object": "the general-purpose registers X1, X2"
  },
  {
    "subject": "we",
    "predicate": "need to ensure",
    "object": "in the interrupt handler, we use the same order to load words back"
  },
  {
    "subject": "the programmer",
    "predicate": "has to be aware of",
    "object": "that to achieve the best possible latency"
  },
  {
    "subject": "programmer",
    "predicate": "uses",
    "object": "compiler-specific attributes to write his interrupt handlers"
  },
  {
    "subject": "compiler-specific attributes",
    "predicate": "include",
    "object": "attribute((interrupt)) in GCC"
  },
  {
    "subject": "compiler",
    "predicate": "needs to be made aware of",
    "object": "the fact that programmer uses compiler-specific attributes to write his interrupt handlers"
  },
  {
    "subject": "we",
    "predicate": "give an overview of",
    "object": "how nested interrupt handling code works for the basic CLINT-mode, the baseline CLIC, and our FastIRQ extension"
  },
  {
    "subject": "ROUTINES",
    "predicate": "are for",
    "object": "SAVING STATE FOR VECTORED NESTING INTERRUPTS"
  },
  {
    "subject": "SAVING STATE FOR VECTORED NESTING INTERRUPTS",
    "predicate": "uses",
    "object": "CLINT"
  },
  {
    "subject": "SAVING STATE FOR VECTORED NESTING INTERRUPTS",
    "predicate": "uses",
    "object": "CLIC"
  },
  {
    "subject": "SAVING STATE FOR VECTORED NESTING INTERRUPTS",
    "predicate": "uses",
    "object": "PROPOSED FASTIRQ EXTENSION"
  },
  {
    "subject": "reducing the RF size",
    "predicate": "helps",
    "object": "lower context switch times"
  },
  {
    "subject": "reducing the RF size",
    "predicate": "does not affect",
    "object": "the interrupt latency"
  },
  {
    "subject": "the set of caller-save registers",
    "predicate": "remains",
    "object": "the same when using the embedded-application binary interface (EABI)"
  },
  {
    "subject": "OUR IMPLEMENTATION",
    "predicate": "allows",
    "object": "the core to dynamically switch between RV32I and RV32E with FastIRQ depending on the workload"
  },
  {
    "subject": "one",
    "predicate": "could add",
    "object": "additional registers for the seven caller-save registers to save area"
  },
  {
    "subject": "doubling the RF size for the banking logic",
    "predicate": "is alternative to",
    "object": "adding additional registers for the seven caller-save registers to save area"
  },
  {
    "subject": "increased pressure on the RF",
    "predicate": "is",
    "object": "not acceptable"
  },
  {
    "subject": "the interrupt state",
    "predicate": "can be quickly restored by",
    "object": "simply switching register banks"
  },
  {
    "subject": "EMRET",
    "predicate": "is added",
    "object": "to differentiate between a regular return from an interrupt handler using MRET"
  },
  {
    "subject": "THIS INSTRUCTION",
    "predicate": "performs",
    "object": "the same function as MRET"
  },
  {
    "subject": "THIS INSTRUCTION",
    "predicate": "performs",
    "object": "switching register banks"
  },
  {
    "subject": "this situation",
    "predicate": "can be optimized by",
    "object": "directly checking for other interrupts pending on the same level before restoring the executions interrupt context"
  },
  {
    "subject": "THE CLIC",
    "predicate": "offers",
    "object": "an HW-assisted solution to address such a scenario with the XNXTI CSRS"
  },
  {
    "subject": "NUCLEIS ENHANCED CLIC (ECLIC) 18",
    "predicate": "extends",
    "object": "XNXTI"
  },
  {
    "subject": "NUCLEIS ENHANCED CLIC (ECLIC) 18",
    "predicate": "embeds",
    "object": "the jump to the queuing interrupt handler in the XNXTI HW (JALXNXTI)"
  },
  {
    "subject": "NUCLEI SYSTEM TECHNOLOGY ECLIC 39",
    "predicate": "extends",
    "object": "traditional XNXTI"
  },
  {
    "subject": "NUCLEI SYSTEM TECHNOLOGY ECLIC 39",
    "predicate": "extends with",
    "object": "a novel CSR for machine privilege mode, JALMNXTI 18"
  },
  {
    "subject": "JALMNXTI 18",
    "predicate": "is discussed in",
    "object": "this work in Section IV"
  },
  {
    "subject": "some HW",
    "predicate": "refers to",
    "object": "this concept of removing redundant context restores as tail-chaining"
  },
  {
    "subject": "We",
    "predicate": "address",
    "object": "this scenario"
  },
  {
    "subject": "We",
    "predicate": "minimize",
    "object": "interrupt latency"
  },
  {
    "subject": "We",
    "predicate": "hide",
    "object": "latency"
  },
  {
    "subject": "the first instruction",
    "predicate": "will be",
    "object": "re-enabling global interrupts"
  },
  {
    "subject": "A high-level interrupt",
    "predicate": "could preempt",
    "object": "the current running interrupt handler"
  },
  {
    "subject": "MIE",
    "predicate": "has to be manually adjusted",
    "object": "to prevent that corresponding lower-priority interrupts are disabled"
  },
  {
    "subject": "this return path",
    "predicate": "could be handled in",
    "object": "HW by adding an additional write port to the cores RF"
  },
  {
    "subject": "exiting an interrupt handler",
    "predicate": "is",
    "object": "less time-critical"
  },
  {
    "subject": "we",
    "predicate": "mostly care about",
    "object": "how quickly an external event is addressed"
  },
  {
    "subject": "context switches",
    "predicate": "can be divided into",
    "object": "OS-specific and HW-specific parts"
  },
  {
    "subject": "The OS part",
    "predicate": "entails",
    "object": "all contributions to the context switch time that is specific to the OS itself"
  },
  {
    "subject": "The OS part",
    "predicate": "includes",
    "object": "computing the next task to be scheduled"
  },
  {
    "subject": "The OS part",
    "predicate": "includes",
    "object": "bookkeeping operations"
  },
  {
    "subject": "THE REMAINDER",
    "predicate": "is",
    "object": "THE HW-DEPENDENT SAVING AND RESTORING OF THE STATE BELONGING TO THE NEW CONTEXT"
  },
  {
    "subject": "THE IDEA",
    "predicate": "is to use",
    "object": "THE BACKGROUND-SAVING MECHANISM"
  },
  {
    "subject": "THE BACKGROUND-SAVING MECHANISM",
    "predicate": "to accelerate",
    "object": "THE STATE SAVING AND RESTORING PART OF CONTEXT FIG"
  },
  {
    "subject": "HW",
    "predicate": "pushes out",
    "object": "the previous register state to memory in the background"
  },
  {
    "subject": "HW mechanism",
    "predicate": "engages to",
    "object": "swap the registers"
  },
  {
    "subject": "HW mechanism",
    "predicate": "saves",
    "object": "the registers in the background"
  },
  {
    "subject": "we",
    "predicate": "can proceed with",
    "object": "the rest of the context switch routine"
  },
  {
    "subject": "the initial part of the context switch routine",
    "predicate": "changes",
    "object": "for that"
  },
  {
    "subject": "we",
    "predicate": "want to save",
    "object": "the current running tasks state to memory"
  },
  {
    "subject": "we",
    "predicate": "set up",
    "object": "the stack"
  },
  {
    "subject": "Additional RISC-V extensions",
    "predicate": "introduce",
    "object": "more context switching state"
  },
  {
    "subject": "More context switching state",
    "predicate": "run",
    "object": "contrary to the goals of FastIRQ regarding latencies"
  },
  {
    "subject": "adding more state to FastIRQ",
    "predicate": "has no",
    "object": "technical limitations"
  },
  {
    "subject": "the resulting design",
    "predicate": "would incur",
    "object": "a significant increase in area and power"
  },
  {
    "subject": "a dirty bit",
    "predicate": "could help to keep",
    "object": "the fast path competitive"
  },
  {
    "subject": "THIS SECTION",
    "predicate": "GIVES",
    "object": "A FUNCTIONAL AND QUANTITATIVE EVALUATION OF THE VARIOUS FLAVORS OF THE CV32RT"
  },
  {
    "subject": "CLINT",
    "predicate": "is",
    "object": "the first standardized RISC-V interrupt controller"
  },
  {
    "subject": "The interrupt lines",
    "predicate": "have",
    "object": "a hardwired prioritization scheme"
  },
  {
    "subject": "THE BASELINE CLIC",
    "predicate": "ADDRESSES",
    "object": "THESE WEAKNESSES"
  },
  {
    "subject": "A level threshold register per privilege level (XINTTHRESH)",
    "predicate": "controls",
    "object": "the set of allowed horizontal interrupts"
  },
  {
    "subject": "A level threshold register per privilege level (XINTTHRESH)",
    "predicate": "limits",
    "object": "the set of allowed horizontal interrupts to those whose level exceeds the given value in the register"
  },
  {
    "subject": "VECTORING",
    "predicate": "can be",
    "object": "selectively enabled or disabled per interrupt line"
  },
  {
    "subject": "THIS SOLUTION",
    "predicate": "works for",
    "object": "VECTORED INTERRUPTS"
  },
  {
    "subject": "THIS SOLUTION",
    "predicate": "works for",
    "object": "NON-VECTORED INTERRUPTS"
  },
  {
    "subject": "THE OPTIONAL XNXTI EXTENSION",
    "predicate": "allows",
    "object": "multiple horizontal interrupts to be serviced in sequence without redundant context-restoring operations in between"
  },
  {
    "subject": "the first interrupt",
    "predicate": "has to pay",
    "object": "the full latency cost"
  },
  {
    "subject": "XNXTI",
    "predicate": "does not touch",
    "object": "the interrupt context storing part itself"
  },
  {
    "subject": "READING THE XNXTI CSR",
    "predicate": "yields",
    "object": "a pointer to the vector table entry for the next pending and qualifying interrupt"
  },
  {
    "subject": "a pointer to the vector table entry for the next pending and qualifying interrupt",
    "predicate": "allows",
    "object": "a direct jump there"
  },
  {
    "subject": "THIS APPROACH",
    "predicate": "loses",
    "object": "THE LATENCY ADVANTAGE OF HW VECTORING"
  },
  {
    "subject": "THIS APPROACH",
    "predicate": "runs",
    "object": "AN SW EMULATION THEREOF"
  },
  {
    "subject": "we",
    "predicate": "take measurements by running",
    "object": "RTL simulations of the different versions of CV32RT as part of CONTROLPULP"
  },
  {
    "subject": "memory subsystem",
    "predicate": "has",
    "object": "single cycle (zero wait state) access to static random access memory (SRAM)"
  },
  {
    "subject": "The memory bank we are using",
    "predicate": "is not contended by",
    "object": "other bus masters"
  },
  {
    "subject": "interrupt lines",
    "predicate": "have",
    "object": "no additional latencies introduced between interrupt sources and the CLIC"
  },
  {
    "subject": "WE",
    "predicate": "measure",
    "object": "the HW contributed interrupt latency of our FastIRQ extension"
  },
  {
    "subject": "the HW contributed interrupt latency",
    "predicate": "is described in",
    "object": "Section II-B3"
  },
  {
    "subject": "WE",
    "predicate": "compare",
    "object": "the HW contributed interrupt latency of our FastIRQ extension to the CV32 and CV32RT variations"
  },
  {
    "subject": "CV32 and CV32RT variations",
    "predicate": "include",
    "object": "Standard CLIC, XNXTI, JALXNXTI"
  },
  {
    "subject": "all caller-save registers",
    "predicate": "need to be",
    "object": "saved"
  },
  {
    "subject": "Interrupt handler routines that save the interrupt context in SW",
    "predicate": "can only save",
    "object": "the minimum state if the compiler is able to fully inline the handlers function body"
  },
  {
    "subject": "interrupt handler routines that use sw-based mechanisms to save and restore interrupt state",
    "predicate": "can fully inline",
    "object": "the handler code"
  },
  {
    "subject": "interrupt handler routines that use sw-based mechanisms to save and restore interrupt state",
    "predicate": "can save",
    "object": "some caller-save registers"
  },
  {
    "subject": "the compiler",
    "predicate": "permits",
    "object": "fully inlining the handler code and saving some caller-save registers"
  },
  {
    "subject": "we",
    "predicate": "measure",
    "object": "the interrupt latency in the optimal case"
  },
  {
    "subject": "only one caller-save register",
    "predicate": "needs saving for",
    "object": "SW-based interrupt handlers"
  },
  {
    "subject": "INTERRUPTS",
    "predicate": "are injected into",
    "object": "the design at the interrupt controller inputs"
  },
  {
    "subject": "We",
    "predicate": "evaluate",
    "object": "the EABI of RISC-V"
  },
  {
    "subject": "We",
    "predicate": "evaluate",
    "object": "the regular integer ABI of RISC-V"
  },
  {
    "subject": "FOR OUR FASTIRQ EXTENSION",
    "predicate": "this amount of state",
    "object": "is always saved"
  },
  {
    "subject": "the HW",
    "predicate": "does not know a priori",
    "object": "which caller-save registers need to be saved"
  },
  {
    "subject": "TABLE III",
    "predicate": "compares",
    "object": "the main techniques for optimizing interrupt context and task context save/restore with nested and non-nested interrupts employed by industry and academia in the embedded and real-time application domains"
  },
  {
    "subject": "the results",
    "predicate": "are summarized in",
    "object": "FIG."
  },
  {
    "subject": "several designs",
    "predicate": "automatically save and restore",
    "object": "the interrupt context directly in HW"
  },
  {
    "subject": "AUTOMATIC INTERRUPT CONTEXT SAVERESTORE",
    "predicate": "reduces",
    "object": "SW HOUSEKEEPING OVERHEAD BEFORE AND AFTER HANDLING THE INTERRUPT ROUTINE"
  },
  {
    "subject": "AUTOMATIC INTERRUPT CONTEXT SAVERESTORE",
    "predicate": "only partially addresses",
    "object": "THE ACCELERATION OF THE COMPLETE TASK CONTEXT SWITCH"
  },
  {
    "subject": "The presented solutions",
    "predicate": "are effective in",
    "object": "optimizing context, save/restore with HW and SW cooperation"
  },
  {
    "subject": "The presented solutions",
    "predicate": "lack",
    "object": "a cohesive approach to address both interrupt context and task context switch acceleration"
  },
  {
    "subject": "The presented solutions",
    "predicate": "lack",
    "object": "existing RISC-V-based approaches that can close the gap with well-established industry vendors"
  },
  {
    "subject": "INTERRUPT CONTEXT SAVERESTORE",
    "predicate": "takes advantage of",
    "object": "the former"
  },
  {
    "subject": "INTERRUPT CONTEXT SAVERESTORE",
    "predicate": "defers operations to",
    "object": "the HW"
  },
  {
    "subject": "XNXTI and JALXNXTI",
    "predicate": "perform",
    "object": "even worse"
  },
  {
    "subject": "XNXTI",
    "predicate": "require",
    "object": "42 cycles"
  },
  {
    "subject": "JALXNXTI",
    "predicate": "require",
    "object": "35 cycles"
  },
  {
    "subject": "XNXTI and JALXNXTI",
    "predicate": "insert",
    "object": "additional instructions in the code path between the handler and interrupt event"
  },
  {
    "subject": "XNXTI AND JALXNXTI",
    "predicate": "improve upon",
    "object": "this situation"
  },
  {
    "subject": "XNXTI AND JALXNXTI",
    "predicate": "check for",
    "object": "pending interrupts"
  },
  {
    "subject": "XNXTI AND JALXNXTI",
    "predicate": "directly jump to",
    "object": "the respective handlers"
  },
  {
    "subject": "XNXTI",
    "predicate": "returns",
    "object": "a pointer to the address of the next handler"
  },
  {
    "subject": "XNXTI",
    "predicate": "needs",
    "object": "a small code sequence (load, jump, and retry loop)"
  },
  {
    "subject": "JALXNXTI",
    "predicate": "fuses",
    "object": "these operations into one instruction"
  },
  {
    "subject": "fusing these operations into one instruction",
    "predicate": "results in",
    "object": "saving nine cycles"
  },
  {
    "subject": "ARM Cortex-M4",
    "predicate": "has",
    "object": "an interrupt latency of 12 cycles given a single-cycle memory"
  },
  {
    "subject": "ARM Cortex-M4",
    "predicate": "is able to do",
    "object": "the same task in six cycles"
  },
  {
    "subject": "ARM Cortex-M4",
    "predicate": "assumes",
    "object": "it has access to single-cycle memory 24"
  },
  {
    "subject": "we",
    "predicate": "show",
    "object": "the cost in clock cycles of such sequences"
  },
  {
    "subject": "the baseline CLIC",
    "predicate": "takes",
    "object": "68 cycles when using the integer ABI"
  },
  {
    "subject": "the baseline CLIC",
    "predicate": "takes",
    "object": "50 cycles when using the embedded ABI"
  },
  {
    "subject": "no interrupt state",
    "predicate": "is affected",
    "object": ""
  },
  {
    "subject": "THE EMRET MECHANISM OF FASTIRQ",
    "predicate": "works",
    "object": "similarly"
  },
  {
    "subject": "THE EMRET MECHANISM OF FASTIRQ",
    "predicate": "costs",
    "object": "eight clock cycles"
  },
  {
    "subject": "THE EMRET MECHANISM OF FASTIRQ",
    "predicate": "is not restricted to",
    "object": "non-vectored interrupts"
  },
  {
    "subject": "context switch time",
    "predicate": "is shown in",
    "object": "number of clock cycles between two FreeRTOS dummy tasks"
  },
  {
    "subject": "context switch time",
    "predicate": "is compared between",
    "object": "baseline CV32RT and CV32RTFASTIRQ"
  },
  {
    "subject": "Average context switch time",
    "predicate": "is measured in",
    "object": "FreeRTOS for two tasks of various flavors of CV32RT"
  },
  {
    "subject": "all compile time options such as tracing, stack overflow signaling, and the more generic task selection mechanism",
    "predicate": "were turned off",
    "object": "to minimize the context switch code"
  },
  {
    "subject": "We",
    "predicate": "left out",
    "object": "configurations that do not have Fig"
  },
  {
    "subject": "generic Cortex-M4 core",
    "predicate": "has",
    "object": "single-cycle access to memory"
  },
  {
    "subject": "ARM Cortex-M",
    "predicate": "has",
    "object": "16 core registers"
  },
  {
    "subject": "FASTIRQ",
    "predicate": "allows",
    "object": "us to skip ahead the saving of the general-purpose registers"
  },
  {
    "subject": "FASTIRQ",
    "predicate": "triggers",
    "object": "an SW interrupt as part of the save sequence"
  },
  {
    "subject": "THE SW INTERRUPT",
    "predicate": "WILL TRIGGER",
    "object": "THE FASTIRQ MECHANISM"
  },
  {
    "subject": "THE FASTIRQ MECHANISM",
    "predicate": "STARTS",
    "object": "SAVING THE GENERAL-PURPOSE REGISTERS TO MEMORY"
  },
  {
    "subject": "using the I-extension",
    "predicate": "can save up to",
    "object": "31 cycles (19) for a context switch"
  },
  {
    "subject": "using the E-extension",
    "predicate": "can save up to",
    "object": "16 cycles (12) for a context switch"
  },
  {
    "subject": "not using registers that are still being saved by the background-saving mechanism",
    "predicate": "enables",
    "object": "saving cycles for a context switch"
  },
  {
    "subject": "THE FREERTOS WEBSITE 20",
    "predicate": "claims",
    "object": "context switches as low as 96 cycles for a Cortex-M4 implementation"
  },
  {
    "subject": "We",
    "predicate": "synthesize",
    "object": "CV32RT as part of the ControlPULP platform"
  },
  {
    "subject": "SYNOPSYS DESIGN COMPILER 2022.03",
    "predicate": "is used for",
    "object": "synthesizing CV32RT"
  },
  {
    "subject": "SYNOPSYS DESIGN COMPILER 2022.03",
    "predicate": "targets",
    "object": "GlobalFoundries 12LP FinFET technology"
  },
  {
    "subject": "GlobalFoundries 12LP FinFET technology",
    "predicate": "operates at",
    "object": "500 MHz, TT corner, and 25 C"
  },
  {
    "subject": "One gate equivalent (GE) for this technology",
    "predicate": "equals",
    "object": "0.121 m2"
  },
  {
    "subject": "STM32L476RG",
    "predicate": "has",
    "object": "higher latencies due to memory access stalls and other implementation choices in the memory subsystem"
  },
  {
    "subject": "RISC-V E-extension",
    "predicate": "reduces",
    "object": "the available general-purpose registers from 32 to 16"
  },
  {
    "subject": "Reducing the available general-purpose registers from 32 to 16",
    "predicate": "lowers",
    "object": "the context switch state that needs to be saved and restored"
  },
  {
    "subject": "REPORTS",
    "predicate": "the area breakdown of",
    "object": "the CLIC implemented in the proposed with different interrupt sources"
  },
  {
    "subject": "AREA OVERHEAD",
    "predicate": "is related to",
    "object": "CV32RT"
  },
  {
    "subject": "CV32RT",
    "predicate": "has",
    "object": "two main configurations"
  },
  {
    "subject": "FASTIRQ overhead in CV32RTFASTIRQ core",
    "predicate": "results in",
    "object": "a minimal 10 area increase"
  },
  {
    "subject": "area increase",
    "predicate": "is concentrated around",
    "object": "the ID stage"
  },
  {
    "subject": "THE DESIGN",
    "predicate": "has been synthesized in",
    "object": "GF12LP TECHNOLOGY"
  },
  {
    "subject": "GF12LP TECHNOLOGY",
    "predicate": "has frequency",
    "object": "500 MHZ"
  },
  {
    "subject": "GF12LP TECHNOLOGY",
    "predicate": "has corner",
    "object": "TT CORNER"
  },
  {
    "subject": "GF12LP TECHNOLOGY",
    "predicate": "has temperature",
    "object": "25 C"
  },
  {
    "subject": "GF12LP TECHNOLOGY",
    "predicate": "has voltage",
    "object": "0.8 V"
  },
  {
    "subject": "GF12LP TECHNOLOGY",
    "predicate": "has cell type",
    "object": "SUPER LOW VT STANDARD CELLS"
  },
  {
    "subject": "more than half of the resources",
    "predicate": "implement",
    "object": "the configuration registers required to control the CLIC"
  },
  {
    "subject": "the size",
    "predicate": "linearly increases with",
    "object": "the number of input interrupts"
  },
  {
    "subject": "each interrupt",
    "predicate": "is associated with",
    "object": "one 32-bit register"
  },
  {
    "subject": "one 32-bit register",
    "predicate": "incurs",
    "object": "an area overhead of about 176 GE"
  },
  {
    "subject": "The remaining area",
    "predicate": "implements",
    "object": "the gateway and binary tree arbitration logic at the core of the CLIC working principle"
  },
  {
    "subject": "The remaining area",
    "predicate": "implements",
    "object": "additional housekeeping control logic that scales linearly with the number of interrupt sources"
  },
  {
    "subject": "the fraction of the design occupied by the arbitration tree",
    "predicate": "is kept constant",
    "object": "when increasing the number of sources"
  },
  {
    "subject": "this design",
    "predicate": "incurs",
    "object": "a larger area overhead compared to traditional RISC-V CLINT 14"
  },
  {
    "subject": "the gain in flexibility",
    "predicate": "enables",
    "object": "a broader application scope with time-critical systems"
  },
  {
    "subject": "CV32RTFASTIRQ",
    "predicate": "incurs",
    "object": "a 10 overall area increase compared to baseline CLIC only"
  },
  {
    "subject": "INSTRUCTION DECODE (ID) STAGE",
    "predicate": "incurs",
    "object": "an area overhead of 21 compared to CV32RTCLIC"
  },
  {
    "subject": "OTHER HW BLOCKS OF THE CORE",
    "predicate": "remain",
    "object": "primarily unaffected"
  },
  {
    "subject": "ID stage",
    "predicate": "is",
    "object": "the HW block where the additional registers and the automatic stacking/unstacking logic are localized"
  },
  {
    "subject": "A breakdown",
    "predicate": "is shown in",
    "object": "FIG"
  },
  {
    "subject": "additional storage space for automatic context save and restore in HW",
    "predicate": "increases",
    "object": "the area of the RF by about 36 in the proposed implementation"
  },
  {
    "subject": "the logic for managing the shadow registers",
    "predicate": "accounts for",
    "object": "an overhead of 40 on the baseline ID stage controller"
  },
  {
    "subject": "HW overhead coming from the additional EMRET instruction",
    "predicate": "is",
    "object": "negligible"
  },
  {
    "subject": "increased size of the ID stage",
    "predicate": "trades off",
    "object": "the benefits of a simplified programming model that moves several SW operations in HW"
  },
  {
    "subject": "increased size of the ID stage",
    "predicate": "trades off",
    "object": "the benefits of significantly lowered interrupt latency than standard RISC-V"
  },
  {
    "subject": "significantly lowered interrupt latency",
    "predicate": "is compared to",
    "object": "standard RISC-V"
  },
  {
    "subject": "increased size of the ID stage",
    "predicate": "does not impact",
    "object": "the critical path of the base core design"
  },
  {
    "subject": "TIME-CRITICAL SYSTEMS",
    "predicate": "SHIFT DESIGN PRIORITIES FROM",
    "object": "AREA EFFICIENCY"
  },
  {
    "subject": "TIME-CRITICAL SYSTEMS",
    "predicate": "SHIFT DESIGN PRIORITIES TO",
    "object": "SAFETY, SECURITY, AND RELIABILITY"
  },
  {
    "subject": "this section",
    "predicate": "describes",
    "object": "the leading solutions to optimize handling asynchronous events in state-of-the-art embedded and real-time MCUs"
  },
  {
    "subject": "We",
    "predicate": "differentiate between",
    "object": "existing PLICs and CLICs"
  },
  {
    "subject": "CLICs",
    "predicate": "are introduced in",
    "object": "Section II-C"
  },
  {
    "subject": "We",
    "predicate": "focus on",
    "object": "the latter"
  },
  {
    "subject": "We",
    "predicate": "discuss",
    "object": "solutions across various platforms in industry and academia"
  },
  {
    "subject": "Solutions",
    "predicate": "address",
    "object": "interrupt context save/restore techniques"
  },
  {
    "subject": "Solutions",
    "predicate": "address",
    "object": "context switch techniques"
  },
  {
    "subject": "Solutions",
    "predicate": "address",
    "object": "dedicated strategies to optimize redundant context restore with back-to-back interrupts"
  },
  {
    "subject": "modified version of the return authorized licensed use",
    "predicate": "is limited to",
    "object": "California Polytechnic State University San Luis Obispo"
  },
  {
    "subject": "TABLE III",
    "predicate": "summarizes",
    "object": "THE OVERVIEW"
  },
  {
    "subject": "we",
    "predicate": "assume",
    "object": "the definition presented in Section II-B for the interrupt latency"
  },
  {
    "subject": "we",
    "predicate": "provide",
    "object": "references to different variants adopted by SOTA in Table III"
  },
  {
    "subject": "interrupt handler",
    "predicate": "operates through",
    "object": "a dedicated register bank"
  },
  {
    "subject": "dedicated register bank",
    "predicate": "has",
    "object": "up to eight registers"
  },
  {
    "subject": "eight registers",
    "predicate": "are employed to",
    "object": "minimize context switching"
  },
  {
    "subject": "the core",
    "predicate": "starts fetching",
    "object": "the jump address from the interrupt vector table"
  },
  {
    "subject": "fetching the jump address",
    "predicate": "occurs",
    "object": "simultaneously during context save and embed context restore within the return instruction"
  },
  {
    "subject": "ARM Cortex-M series",
    "predicate": "integrates",
    "object": "Nested Vectored Interrupt Controller (NVIC)"
  },
  {
    "subject": "A state machine 32",
    "predicate": "implements",
    "object": "caller-save register stacking in the background"
  },
  {
    "subject": "HW",
    "predicate": "encodes in",
    "object": "link register a value (EXCRETURN)"
  },
  {
    "subject": "value (EXCRETURN)",
    "predicate": "notifies",
    "object": "core to start unwinding the stack"
  },
  {
    "subject": "core",
    "predicate": "starts",
    "object": "unwinding the stack to return to normal program execution"
  },
  {
    "subject": "Interrupt Control Unit (ICU) 33, 34, 35",
    "predicate": "is part of",
    "object": "Infineon Aurix MCU-class Tricore family"
  },
  {
    "subject": "The context of the calling routine",
    "predicate": "is saved in",
    "object": "memory autonomously"
  },
  {
    "subject": "Restoring the context",
    "predicate": "is embedded in",
    "object": "the RET instruction"
  },
  {
    "subject": "Restoring the context",
    "predicate": "happens in parallel with",
    "object": "the return jump 36"
  },
  {
    "subject": "27",
    "predicate": "are the first to propose",
    "object": "extensions for the RISC-V CLIC"
  },
  {
    "subject": "interrupt handling",
    "predicate": "is enhanced with",
    "object": "automatic stacking in hardware"
  },
  {
    "subject": "automatic stacking in hardware",
    "predicate": "benefits from",
    "object": "the core's Harvard architecture"
  },
  {
    "subject": "automatic stacking in hardware",
    "predicate": "benefits from",
    "object": "simultaneous data and instruction memory access"
  },
  {
    "subject": "Register banking",
    "predicate": "is",
    "object": "a technique adopted by several architectures"
  },
  {
    "subject": "Register banking",
    "predicate": "swaps",
    "object": "a task's context without pushing/popping register values to the stack"
  },
  {
    "subject": "Register banking",
    "predicate": "has",
    "object": "an additional area overhead in the design"
  },
  {
    "subject": "A tasks context switch",
    "predicate": "benefits from",
    "object": "quickly transferring the suspended context to the dedicated register bank"
  },
  {
    "subject": "A tasks context switch",
    "predicate": "benefits from",
    "object": "already restoring the next task to be executed"
  },
  {
    "subject": "HW REGISTER BANKING",
    "predicate": "is in",
    "object": "PLICs (GIC)"
  },
  {
    "subject": "HW REGISTER BANKING",
    "predicate": "is the case of",
    "object": "ARM designs"
  },
  {
    "subject": "A similar approach",
    "predicate": "is implemented in",
    "object": "the Renesas M32C80 series 30"
  },
  {
    "subject": "A dual register bank",
    "predicate": "allows",
    "object": "quickly swapping the context without saving/restoring to/from the stack"
  },
  {
    "subject": "The second register bank",
    "predicate": "is reserved for",
    "object": "high-speed interrupts"
  },
  {
    "subject": "THE AURIX FAMILY",
    "predicate": "implements",
    "object": "an SW managed solution"
  },
  {
    "subject": "the SW managed solution",
    "predicate": "features",
    "object": "a specific organization of the context layout in the system memory"
  },
  {
    "subject": "the specific organization of the context layout",
    "predicate": "is based on",
    "object": "context save area (CSA) chained in a linked list fashion"
  },
  {
    "subject": "A more complex approach",
    "predicate": "is introduced by",
    "object": "Huang et al."
  },
  {
    "subject": "28",
    "predicate": "adopts",
    "object": "a valid-based mechanism in HW to block context switch on selected registers"
  },
  {
    "subject": "valid-based mechanism in HW",
    "predicate": "blocks",
    "object": "context switch on selected registers"
  },
  {
    "subject": "28",
    "predicate": "reduces",
    "object": "register movement by almost 50"
  },
  {
    "subject": "THIS FEATURE",
    "predicate": "is combined with",
    "object": "SEMI-SHADOWING"
  },
  {
    "subject": "SEMI-SHADOWING",
    "predicate": "is similar to",
    "object": "REGISTER BANKING"
  },
  {
    "subject": "SEMI-SHADOWING",
    "predicate": "uses",
    "object": "the top (FLIP) and bottom (FLOP) halves of the RF as RF copies"
  },
  {
    "subject": "the latter approach",
    "predicate": "is similar to",
    "object": "leveraging RISC-V's RV32E base instruction set by re-using the lower 16 architectural registers of the RF"
  },
  {
    "subject": "THE EVALUATION IN 28",
    "predicate": "lacks",
    "object": "HW IMPLEMENTATION"
  },
  {
    "subject": "THE EVALUATION IN 28",
    "predicate": "lacks",
    "object": "AREA OVERHEAD ASSESSMENT"
  },
  {
    "subject": "THE EVALUATION IN 28",
    "predicate": "reduces",
    "object": "CONTEXT SWITCHING OVERHEAD BY 24"
  },
  {
    "subject": "CONTEXT SWITCHING OVERHEAD",
    "predicate": "is reduced by",
    "object": "24"
  },
  {
    "subject": "THE EVALUATION IN 28",
    "predicate": "reduces CON- TEXT SWITCHING OVERHEAD BY 24",
    "object": "on THE DSPSTONE BENCHMARK"
  },
  {
    "subject": "THESE APPROACHES",
    "predicate": "trade-off",
    "object": "HW- and SW-induced latencies when handling asynchronous events"
  },
  {
    "subject": "HSE",
    "predicate": "is",
    "object": "a hardware scheduling engine"
  },
  {
    "subject": "HSE",
    "predicate": "directly attaches",
    "object": "interrupts to running tasks"
  },
  {
    "subject": "HSE",
    "predicate": "does not need",
    "object": "a specialized interrupt controller"
  },
  {
    "subject": "this approach",
    "predicate": "allows",
    "object": "lowering interrupt latency and task context switches dramatically"
  },
  {
    "subject": "this approach",
    "predicate": "lacks",
    "object": "flexibility"
  },
  {
    "subject": "its area overhead",
    "predicate": "grows",
    "object": "for a high number of tasks"
  },
  {
    "subject": "this approach",
    "predicate": "requires",
    "object": "replicating hardware resources per task"
  },
  {
    "subject": "fast context switching",
    "predicate": "is often required in",
    "object": "architectures such as superscalar central processing units (CPUs)"
  },
  {
    "subject": "fast context switching",
    "predicate": "is often required to hide latency in",
    "object": "graphic processing units (GPUs)"
  },
  {
    "subject": "Such works",
    "predicate": "highlight",
    "object": "the difference in memory footprint between architectures (MB size RFs) and low-end embedded microcontrollers targeted in this work"
  },
  {
    "subject": "Such works",
    "predicate": "typically adopt",
    "object": "RF caching rather than register shadowing or banking"
  },
  {
    "subject": "RF caching",
    "predicate": "is adopted for",
    "object": "performance reasons"
  },
  {
    "subject": "Performance reasons",
    "predicate": "include",
    "object": "lower access latency to the RF"
  },
  {
    "subject": "Performance reasons",
    "predicate": "include",
    "object": "higher thread-level parallelism (TLP)"
  },
  {
    "subject": "such techniques",
    "predicate": "may deteriorate",
    "object": "the system's predictability"
  },
  {
    "subject": "such techniques",
    "predicate": "are not considered",
    "object": ""
  },
  {
    "subject": "RISC-V",
    "predicate": "adds",
    "object": "the XNXTI CSR with SW-managed interrupt service loops as part of the CLIC specifications"
  },
  {
    "subject": "RISC-V",
    "predicate": "finds",
    "object": "early commercial examples with 31"
  },
  {
    "subject": "RISC-V AIA WITHOUT APLIC",
    "predicate": "has a similar approach to",
    "object": "MNXTI"
  },
  {
    "subject": "RISC-V AIA WITHOUT APLIC",
    "predicate": "has a similar approach to",
    "object": "MNXTI with the XTOPI CSR"
  },
  {
    "subject": "XTOPI CSR",
    "predicate": "reports",
    "object": "the highest-priority, pending, and enabled interrupt for a specific privilege mode"
  },
  {
    "subject": "XTOPI CSR",
    "predicate": "allows",
    "object": "both late arrival and redundant context restore mechanisms"
  },
  {
    "subject": "THIS WORK",
    "predicate": "proposes",
    "object": "a combination of the background-saving with a register banking approach"
  },
  {
    "subject": "We",
    "predicate": "improve",
    "object": "task context switch times in FreeRTOS to 104 clock cycles using FastIRQ"
  },
  {
    "subject": "FastIRQ",
    "predicate": "is",
    "object": "20 times faster than an SW-only approach"
  },
  {
    "subject": "the authors",
    "predicate": "consider for future work",
    "object": "analyzing FastIRQs impact on timing channels"
  },
  {
    "subject": "the authors",
    "predicate": "consider for future work",
    "object": "analyzing FastIRQs integration with different RISC-V extensions"
  },
  {
    "subject": "C. ROCHANGE, S. UHRIG, AND P. SAINRAT",
    "predicate": "are authors of",
    "object": "TIME-PREDICTABLE ARCHITECTURES (FOCUS COMPUTER ENGINEERING SERIES)"
  },
  {
    "subject": "WILEY",
    "predicate": "published",
    "object": "in HOBOKEN, NJ, USA in 2014"
  },
  {
    "subject": "L. M. PINHO ET AL.",
    "predicate": "author of",
    "object": "HIGH-PERFORMANCE AND TIME-PREDICTABLE EMBEDDED COMPUTING"
  },
  {
    "subject": "HIGH-PERFORMANCE AND TIME-PREDICTABLE EMBEDDED COMPUTING",
    "predicate": "available at",
    "object": "HTTP:EU.WILEY.COMWILEYCDA WILEYTITLEPRODUCTCD-1848215932.HTML"
  },
  {
    "subject": "RIVER",
    "predicate": "published in",
    "object": "WHARTON, TX, USA"
  },
  {
    "subject": "RIVER",
    "predicate": "published in year",
    "object": "2018"
  },
  {
    "subject": "3 F. Reghenzani, G. Massari, and W. Fornaciari",
    "predicate": "authored",
    "object": "The Real-Time Linux Kernel: A Survey on PreemptRT, ACM Comput."
  },
  {
    "subject": "4 M. LIU, D. LIU, Y. WANG, M. WANG, AND Z. SHAO",
    "predicate": "authored",
    "object": "ON IMPROVING REAL-TIME INTERRUPT LATENCIES OF HYBRID OPERATING SYSTEMS WITH TWO-LEVEL HARDWARE INTERRUPTS"
  },
  {
    "subject": "ON IMPROVING REAL-TIME INTERRUPT LATENCIES OF HYBRID OPERATING SYSTEMS WITH TWO-LEVEL HARDWARE INTERRUPTS",
    "predicate": "published in",
    "object": "IEEE TRANS."
  },
  {
    "subject": "5 P. Mantegazza, E. L. Dozio, and S. Papacharalambous",
    "predicate": "authored",
    "object": "RTAI: Real Time Application Interface"
  },
  {
    "subject": "RTAI: Real Time Application Interface",
    "predicate": "published in",
    "object": "Linux J."
  },
  {
    "subject": "J. Valvano",
    "predicate": "authored",
    "object": "Introduction to Embedded Systems"
  },
  {
    "subject": "Introduction to Embedded Systems",
    "predicate": "is available at",
    "object": "http://web.engr.oregonstate.edu/traylor/ece473 PDFs/minimize_interrupt_response_time.pdf"
  },
  {
    "subject": "CREATESPACE",
    "predicate": "location",
    "object": "SCOTTS VALLEY, CA, USA"
  },
  {
    "subject": "CREATESPACE",
    "predicate": "date",
    "object": "AUG. 2016"
  },
  {
    "subject": "9 Y. HUANG, L. SHI, J. LI, Q. LI, AND C. J. XUE",
    "predicate": "authored",
    "object": "WCET-AWARE RE-SCHEDULING REGISTER ALLOCATION FOR REAL-TIME EMBEDDED SYSTEMS WITH CLUSTERED VLIW ARCHITECTURE"
  },
  {
    "subject": "WCET-AWARE RE-SCHEDULING REGISTER ALLOCATION FOR REAL-TIME EMBEDDED SYSTEMS WITH CLUSTERED VLIW ARCHITECTURE",
    "predicate": "published in",
    "object": "IEEE TRANS."
  },
  {
    "subject": "X. Zhou and P. Petrov",
    "predicate": "authored",
    "object": "Rapid and low-cost context-switch through embedded processor customization for real-time and control applications"
  },
  {
    "subject": "Rapid and low-cost context-switch through embedded processor customization for real-time and control applications",
    "predicate": "published in",
    "object": "Proc."
  },
  {
    "subject": "ASSOCIATION FOR COMPUTING MACHINERY",
    "predicate": "location",
    "object": "NEW YORK, NY, USA"
  },
  {
    "subject": "ASSOCIATION FOR COMPUTING MACHINERY",
    "predicate": "publication year",
    "object": "2006"
  },
  {
    "subject": "ASSOCIATION FOR COMPUTING MACHINERY",
    "predicate": "page",
    "object": "352"
  },
  {
    "subject": "ASSOCIATION FOR COMPUTING MACHINERY",
    "predicate": "DOI",
    "object": "10.11451146909.1147001"
  },
  {
    "subject": "I. Behnke, L. Pirl, L. Thamsen, R. Danicki, A. Polze, and O. Kao",
    "predicate": "authored",
    "object": "Interrupting Real-Time IoT Tasks: How Bad Can It Be to Connect Your Critical Embedded System to the Internet?"
  },
  {
    "subject": "K. Asanovic and D. A. Patterson",
    "predicate": "wrote",
    "object": "Instruction Sets Should Be Free: The Case for RISC-V"
  },
  {
    "subject": "THE RISC-V INSTRUCTION SET MANUAL VOLUME II: PRIVILEGED ARCHITECTURE VERSION 1.9",
    "predicate": "authors",
    "object": "A. WATERMAN, Y. LEE, R. AVIZIENIS, D. A. PATTERSON, AND K. ASANOVIC"
  },
  {
    "subject": "THE RISC-V INSTRUCTION SET MANUAL VOLUME II: PRIVILEGED ARCHITECTURE VERSION 1.9",
    "predicate": "available at",
    "object": "HTTP://WWW2.EECS.BERKELEY.EDU/PUB/STECHRPTS/2014/EECS-2014-146.HTML"
  },
  {
    "subject": "THE RISC-V INSTRUCTION SET MANUAL VOLUME II: PRIVILEGED ARCHITECTURE VERSION 1.9",
    "predicate": "department",
    "object": "EECS, Berkeley"
  },
  {
    "subject": "EECS",
    "predicate": "is part of",
    "object": "UNIV."
  },
  {
    "subject": "California",
    "predicate": "contains",
    "object": "Berkeley"
  },
  {
    "subject": "Berkeley",
    "predicate": "is located in",
    "object": "California"
  },
  {
    "subject": "Berkeley",
    "predicate": "is located in",
    "object": "CA"
  },
  {
    "subject": "CA",
    "predicate": "is located in",
    "object": "USA"
  },
  {
    "subject": "Berkeley",
    "predicate": "is associated with",
    "object": "Tech"
  },
  {
    "subject": "RISC-V Fast Interrupt Blob",
    "predicate": "is available at",
    "object": "https://github.com/riscv/riscv-fast-interrupt/blob/master/clic"
  },
  {
    "subject": "ADOC 16 M. GAUTSCHI ET AL.",
    "predicate": "wrote",
    "object": "NEAR-THRESHOLD RISC-V CORE WITH DSP EXTENSIONS FOR SCALABLE IOT ENDPOINT DEVICES"
  },
  {
    "subject": "NEAR-THRESHOLD RISC-V CORE WITH DSP EXTENSIONS FOR SCALABLE IOT ENDPOINT DEVICES",
    "predicate": "published in",
    "object": "IEEE TRANS."
  },
  {
    "subject": "OPENHW GROUP",
    "predicate": "has",
    "object": "CV32E40P USER MANUAL"
  },
  {
    "subject": "OPENHW GROUP",
    "predicate": "is",
    "object": "an organization"
  },
  {
    "subject": "CV32E40P",
    "predicate": "is available at",
    "object": "HTTPS"
  },
  {
    "subject": "39 NUCLEI SYSTEM TECHNOLOGY CO. LTD.",
    "predicate": "has unit",
    "object": "ECLIC UNIT"
  },
  {
    "subject": "ECLIC UNIT",
    "predicate": "is introduced in",
    "object": "39 NUCLEI SYSTEM TECHNOLOGY CO. LTD."
  },
  {
    "subject": "NUCLEI",
    "predicate": "ISA",
    "object": "SPEC"
  },
  {
    "subject": "A. Ottaviano et al.",
    "predicate": "authored",
    "object": "ControlPULP: a RISC-V on-chip parallel power controller for many-core HPC processors with FPGA-based hardware-in-the-loop power and thermal emulation"
  },
  {
    "subject": "ControlPULP",
    "predicate": "is",
    "object": "a RISC-V on-chip parallel power controller"
  },
  {
    "subject": "ControlPULP",
    "predicate": "used for",
    "object": "many-core HPC processors"
  },
  {
    "subject": "ControlPULP",
    "predicate": "features",
    "object": "FPGA-based hardware-in-the-loop power and thermal emulation"
  },
  {
    "subject": "Document",
    "predicate": "available at",
    "object": "https://doc.nucleisys.com/nucleispecisaintroduction.html"
  },
  {
    "subject": "PARALLEL PROGRAM.",
    "predicate": "published in",
    "object": "FEB. 2024"
  },
  {
    "subject": "PARALLEL PROGRAM.",
    "predicate": "has DOI",
    "object": "10.1007S10766-024-00761-4"
  },
  {
    "subject": "FREERTOS",
    "predicate": "is",
    "object": "real-time operating system for microcontrollers"
  },
  {
    "subject": "REAL TIME ENGINEERS LTD.",
    "predicate": "is",
    "object": "ONLINE"
  },
  {
    "subject": "21 C.-M. Lin",
    "predicate": "authored",
    "object": "Nested Interrupt Analysis of Low Cost and High Performance Embedded Systems Using GSPN Framework"
  },
  {
    "subject": "Nested Interrupt Analysis of Low Cost and High Performance Embedded Systems Using GSPN Framework",
    "predicate": "published in",
    "object": "IEICE Trans."
  },
  {
    "subject": "Text",
    "predicate": "available at",
    "object": "https://www.freertos.org/index.html"
  },
  {
    "subject": "RISCV-PLIC-1.0.0.PDF",
    "predicate": "is available at",
    "object": "https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic-1.0.0.pdf"
  },
  {
    "subject": "J. Yiu",
    "predicate": "author of",
    "object": "The Definitive Guide to ARM Cortex-M3 Cortex-M4 Processors, 3rd ed."
  },
  {
    "subject": "NEWNES",
    "predicate": "published",
    "object": "in BOSTON, MA, USA in 2013"
  },
  {
    "subject": "HTTPS:DEVELOPER.ARM.COMDOCUMENTATION1001660001",
    "predicate": "is available",
    "object": "25 J. YIU"
  },
  {
    "subject": "ARM Cortex-M processors",
    "predicate": "have",
    "object": "interrupt latency"
  },
  {
    "subject": "V. G. Gaitan, N. C. Gaitan, and I. Ungurean",
    "predicate": "authored",
    "object": "CPU architecture based on a hardware scheduler and independent pipeline registers"
  },
  {
    "subject": "CPU architecture based on a hardware scheduler and independent pipeline registers",
    "predicate": "published in",
    "object": "IEEE Transactions"
  },
  {
    "subject": "Beginner guide on interrupt latency and interrupt latency of the ARM Cortex-M processors",
    "predicate": "available at",
    "object": "https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/beginner-guide-on-interrupt-latency-and-interrupt-latency-of-the-arm-cortex-m-processors?pifragment=227142"
  },
  {
    "subject": "LI and J. K. LEE",
    "predicate": "support",
    "object": "paged register files for improving context switching on embedded processors"
  },
  {
    "subject": "30",
    "predicate": "is",
    "object": "RENESAS"
  },
  {
    "subject": "HARDWARE MANUAL",
    "predicate": "is for",
    "object": "RENESAS MCU M16C"
  },
  {
    "subject": "HARDWARE MANUAL",
    "predicate": "is available at",
    "object": "https://www.renesas.com/us/en/document/mahm32c87-group-m32c87-m32c87a-m32c87b-hardware-manual"
  },
  {
    "subject": "SIFIVE INC.",
    "predicate": "published",
    "object": "HARDWARE MANUAL"
  },
  {
    "subject": "SIFIVE INC.",
    "predicate": "published year",
    "object": "2021"
  },
  {
    "subject": "CORECOMPLEXMANUAL21G1.PDF",
    "predicate": "is available at",
    "object": "HTTPS:SIFIVE.CDN.PRISMIC.IOSIFIVE7C22C2EC-8AF4-4B6C-A5FE-9327D91E7808E21CORECOMPLEXMANUAL21G1.PDF"
  },
  {
    "subject": "STMICROELECTRONICS",
    "predicate": "is mentioned in",
    "object": "the text"
  },
  {
    "subject": "STM32L5-SYSTEM-NESTEDVECTOREDINTERRUPTCONTROLNVIC.PDF",
    "predicate": "is available at",
    "object": "https://www.st.com/content/ccc/resource/training/technical/product_training/group/16135d207346f4e83/STM32L5-SYSTEM-NESTEDVECTOREDINTERRUPTCONTROLNVIC.files/STM32L5-SYSTEM-NESTEDVECTOREDINTERRUPTCONTROLNVIC.pdf"
  },
  {
    "subject": "INFINEON TECHNOLOGIES AG",
    "predicate": "is mentioned in",
    "object": "STM32L5-SYSTEM-NESTEDVECTOREDINTERRUPTCONTROLNVIC.PDF"
  },
  {
    "subject": "FAST POWERTRAIN MICROCONTROLLER",
    "predicate": "is",
    "object": "a microcontroller"
  },
  {
    "subject": "Document",
    "predicate": "is available at",
    "object": "https://old.hotchips.org/wp-content/uploads/hcarchives/hc16/3tue6hc16sess7pres1bw.pdf"
  },
  {
    "subject": "Document",
    "predicate": "is related to",
    "object": "Infineon Technologies AG"
  },
  {
    "subject": "FILE",
    "predicate": "is available at",
    "object": "https://hitex.co.uk/fileadmin/uk-files/downloads/shieldbuddytc27xdumv2.2.pdf"
  },
  {
    "subject": "INFINEON TECHNOLOGIES AG",
    "predicate": "is associated with",
    "object": "the file"
  },
  {
    "subject": "TC27X D-STEP",
    "predicate": "is a",
    "object": "32-bit single-chip microcontroller"
  },
  {
    "subject": "TRICORE V1.6",
    "predicate": "is",
    "object": "CORE ARCHITECTURE"
  },
  {
    "subject": "HTTPS:WWW.INFINEON.COMDGDLTC16 ARCHITECTUREVOL1.PDF?FILEIDDB3A3043372D5CC801373B0F374D5D67",
    "predicate": "is available at",
    "object": "INFINEON TECHNOLOGIES AG"
  },
  {
    "subject": "TASK CONTEXT SWITCHING RTOS",
    "predicate": "is patented by",
    "object": "U.S. PATENT 7 434 222 B2"
  },
  {
    "subject": "U.S. PATENT 7 434 222 B2",
    "predicate": "was issued in",
    "object": "OCT. 2008"
  },
  {
    "subject": "H. ZENG AND K. GHOSE",
    "predicate": "authored",
    "object": "REGISTER FILE CACHING FOR ENERGY EFFICIENCY"
  },
  {
    "subject": "REGISTER FILE CACHING FOR ENERGY EFFICIENCY",
    "predicate": "published in",
    "object": "ISLPED PROC."
  },
  {
    "subject": "Date",
    "predicate": "is",
    "object": "6, JUNE 2024"
  },
  {
    "subject": "38 M. SADROSADATI ET AL.",
    "predicate": "authored",
    "object": "HIGHLY CONCURRENT LATENCY-TOLERANT REGISTER FILES FOR GPUS"
  },
  {
    "subject": "HIGHLY CONCURRENT LATENCY-TOLERANT REGISTER FILES FOR GPUS",
    "predicate": "published in",
    "object": "ACM TRANS."
  },
  {
    "subject": "Robert Balas",
    "predicate": "received",
    "object": "the B.Sc."
  },
  {
    "subject": "Degrees",
    "predicate": "are from",
    "object": "ETH Zurich, Zurich, Switzerland"
  },
  {
    "subject": "Degrees",
    "predicate": "were obtained in",
    "object": "2015 and 2017, respectively"
  },
  {
    "subject": "Degree",
    "predicate": "is at",
    "object": "the Digital Circuits and Systems Group of Prof. Benini"
  },
  {
    "subject": "Digital Circuits and Systems Group",
    "predicate": "is part of",
    "object": "ETH Zurich"
  },
  {
    "subject": "ETH Zurich",
    "predicate": "is located in",
    "object": "Zurich, Switzerland"
  },
  {
    "subject": "His research interests",
    "predicate": "include",
    "object": "real-time computing"
  },
  {
    "subject": "His research interests",
    "predicate": "include",
    "object": "compilers"
  },
  {
    "subject": "His research interests",
    "predicate": "include",
    "object": "operating systems"
  },
  {
    "subject": "His research interests",
    "predicate": "include",
    "object": "power management of HPC processors"
  },
  {
    "subject": "His research interests",
    "predicate": "include",
    "object": "energy-efficient processor architecture"
  },
  {
    "subject": "Alessandro Ottaviano",
    "predicate": "received",
    "object": "the B.Sc."
  },
  {
    "subject": "LUCA BENINI",
    "predicate": "received",
    "object": "the Ph.D."
  },
  {
    "subject": "Degree",
    "predicate": "is in",
    "object": "Physical Engineering"
  },
  {
    "subject": "Degree",
    "predicate": "is from",
    "object": "Politecnico di Turino, Turin, Italy"
  },
  {
    "subject": "Degree",
    "predicate": "was obtained in",
    "object": "2018"
  },
  {
    "subject": "Degree",
    "predicate": "is in",
    "object": "Electrical Engineering"
  },
  {
    "subject": "Degree",
    "predicate": "was obtained from",
    "object": "Politecnico di Turino"
  },
  {
    "subject": "Degree",
    "predicate": "was obtained from",
    "object": "Grenoble INP-PHELMA, Grenoble, France"
  },
  {
    "subject": "Degree",
    "predicate": "was obtained from",
    "object": "EPFL Lausanne, Lausanne, Switzerland"
  },
  {
    "subject": "Degree",
    "predicate": "was obtained in",
    "object": "2020"
  },
  {
    "subject": "Degree",
    "predicate": "field",
    "object": "Electrical Engineering"
  },
  {
    "subject": "Degree",
    "predicate": "awarded by",
    "object": "Stanford University"
  },
  {
    "subject": "Degree",
    "predicate": "location",
    "object": "Stanford, CA, USA"
  },
  {
    "subject": "Degree",
    "predicate": "year",
    "object": "1997"
  },
  {
    "subject": "Dr. Benini",
    "predicate": "is a fellow of",
    "object": "the ACM"
  },
  {
    "subject": "Dr. Benini",
    "predicate": "is a member of",
    "object": "the Academia Europaea"
  }
]