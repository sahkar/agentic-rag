{
  "58": [
    "1032 IEEE TRANSACTIONS ON VERY LARGE SCALE INTEGRATION (VLSI) SYSTEMS, VOL.",
    "1034 IEEE TRANSACTIONS ON VERY LARGE SCALE INTEGRATION (VLSI) SYSTEMS, VOL.",
    "1036 IEEE TRANSACTIONS ON VERY LARGE SCALE INTEGRATION (VLSI) SYSTEMS, VOL.",
    "1038 IEEE TRANSACTIONS ON VERY LARGE SCALE INTEGRATION (VLSI) SYSTEMS, VOL.",
    "1040 IEEE TRANSACTIONS ON VERY LARGE SCALE INTEGRATION (VLSI) SYSTEMS, VOL.",
    "1042 IEEE TRANSACTIONS ON VERY LARGE SCALE INTEGRATION (VLSI) SYSTEMS, VOL.",
    "1044 IEEE TRANSACTIONS ON VERY LARGE SCALE INTEGRATION (VLSI) SYSTEMS, VOL."
  ],
  "89": [
    "32, NO.",
    "32, NO.",
    "32, NO.",
    "32, NO.",
    "32, NO.",
    "32, NO.",
    "32, NO."
  ],
  "11": [
    "6, JUNE 2024 CV32RT: Enabling Fast Interrupt and Context Switching for RISC-V Microcontrollers Robert Balas , Graduate Student Member, IEEE, Alessandro Ottaviano , Graduate Student Member, IEEE, and Luca Benini , Fellow, IEEE Abstract Processors using the open RISC-V instruction set architecture (ISA) are finding increasing adoption in the embed- ded world.",
    "In this work, we implement a CLIC for the CV32E40P, an industrially supported open-source 32-bit microcontroller unit (MCU)-class RISC-V core, and enhance it with fastirq: a custom extension that provides interrupt latency as low as six cycles.",
    "To address these open challenges, we propose CV32RT, a 32-bit RISC-V core that extends the interrupt handling capabilities of CV32E40P 16, 17, an industrially supported open-source core, to achieve best-in-class interrupt latency and fast context switching against commercial off-the-shelf (COTS) processor vendors, paving the road for RISC-V archi- tectures in time-critical systems.",
    "1) We replace the CV32E40P interrupt controller with an implementation of the RISC-V CLIC specification, which provides the core with key features such as prioritization by level and priority, selective hardware vectoring (SHV), and non-nested interrupt optimization tail-chaining through the xnxti 15 control and status register (CSR) directly as RISC-V standard extension (see Section III-A).",
    "BACKGROUND We give a brief overview of the full-system platform used to design and implement the proposed interrupt extension in Section II-A, motivate and explain the relevant target metrics in Section II-B3, and describe the current status of interrupt handling in RISC-V in Section II-C. A. RISC-V System Platform We rely on the CV32E40P core 16abbreviated to CV32 in this articlean open-source, industry-grade, 32-bit, in- order, four-stage RISC-V core, as the basis for implementing our extensions.",
    "A. CV32RT Overview We start with the CV32 core as the baseline, whose native CLINT interrupt controller we replace with the CLIC (hereafter, CV32RTCLIC), and then introduce fastirq into the core microarchitecture, the extension proposed in this work (hereafter, CV32RTfastirq).",
    "B. CV32RTCLIC: CLIC Fast Interrupt Controller We implement the CLIC interrupt controller in CV32RTCLIC 15 according to the draft specification which is to be included in the RISC-V Privileged Specification 14.",
    "TABLE II FEATURE COMPARISON OF VARIOUS FLAVORS OF RISC-V CORE- SPECIFIC INTERRUPT CONTROLLERS Our proposed fastirq extension addresses these weak- nesses by extending the CLIC base capabilities with a mechanism to lower interrupt latency while still keeping HW vectored interrupts and allowing the skipping of redundant context restore operations.",
    "CONCLUSION In this work, we present fastirq, a fast interrupt exten- sion for RISC-V embedded systems.",
    "We implement the extension on CV32RT, a 32-bit, in-order, single-issue core designed with the RISC-V CLIC fast interrupt controller.",
    "27 B. Mao, N. Tan, T. Chong, and L. Li, A CLIC extension based fast interrupt system for embedded RISC-V processors, in Proc."
  ],
  "218": [
    "Many embedded use cases have real-time constraints and require flexible, predictable, and fast reactive handling of incoming events."
  ],
  "236": [
    "However, RISC-V processors are still lagging in this area compared to more mature proprietary architectures, such as ARM Cortex-M and TriCore, which have been tuned for years."
  ],
  "409": [
    "The default interrupt controller standardized by RISC- V, the core local interruptor (CLINT), lacks configurability in prioritization and preemption of interrupts."
  ],
  "10": [
    "The RISC-V core local interrupt controller (CLIC) specification addresses this concern by enabling preemptible, low-latency vectored interrupts while also envisioning optional extensions to improve interrupt latency.",
    "For this reason, the RISC-V community has been developing an extension to the Privileged specifications 14 with the proposal of the RISC-V core local interrupt controller (CLIC) 15, currently under ratification by the community, to handle such real-time scenarios.",
    "C. Interrupt Handling in RISC-V 1) CLINT and PLIC: We distinguish between CLICs, local to each hardware thread (HART), and platform level interrupt controllers (PLICs), centralized interrupt controllers capable of managing multiple HARTs.",
    "A. Platform-Level Interrupt Controllers Controllers that belong to this category, such as the RISC-V PLIC and advanced PLIC (APLIC) for wire-based inter- rupt communication and RISC-V incoming message signaled interrupt controller (IMSIC) for message-signaled interrupt communication, are not designed to distribute time-critical interrupts to the running HARTs.",
    "B. Core-Local Interrupt Controllers CLICs are often specialized in providing fast interrupt-handling capabilities in real-time embedded application domains.",
    "Available: http: www2.eecs.berkeley.eduPubsTechRpts2016EECS-2016-129.html 15 RISC-V SMCLIC Core-Local Interrupt Controller (CLIC) RISC-V Privileged Architecture Extension."
  ],
  "365": [
    "We call CV32RT our enhanced core."
  ],
  "20": [
    "To the best of our knowledge, CV32RT is the first fully open-source RV32 core with competitive interrupt-handling features compared to the Arm Cortex-M series and TriCore.",
    "3) We integrate CV32RT within an open-source system on chip (SoC) 19.2 We evaluate CV32RT interrupt handling capabilities while showing the negligible area overhead introduced by the extension in a modern technology node against its performance benefits (see Section IV).",
    "Then, we show how the various CV32RT versions perform in terms of interrupt latency and context switch times and finally quantify the overhead these additions incur in terms of area and timing."
  ],
  "357": [
    "The proposed extensions are also demonstrated to improve task context switching in real-time operating systems (RTOSs)."
  ],
  "369": [
    "Index Terms Context switching, embedded, interrupt latency, microcontroller unit (MCU), real-time, RISC-V."
  ],
  "319": [
    "INTRODUCTION S EVERAL markets, from automotive to aerospace and robotics, rely on real-time an SW-based solution 1."
  ],
  "214": [
    "For example, the automotive industry employs hundreds of electronic control units (ECUs) for real-time applications, such as electronic engine control, gearbox control, cruise control, anti-lock brake systems, and many other tasks."
  ],
  "254": [
    "General-purpose operating systems (GPOSs) are typi- cally tuned for average throughput rather than real-time Manuscript received 18 August 2023; revised 25 January 2024; accepted 4 March 2024."
  ],
  "291": [
    "Date of publication 21 March 2024; date of current version 23 May 2024."
  ],
  "395": [
    "This work was supported in part by the HORIZON Key Digital Technologies Joint Undertaking (KDT JU) Programme through the TRISTAN project under Grant 101095947."
  ],
  "377": [
    "(Corresponding author: Robert Balas.)"
  ],
  "211": [
    "Robert Balas and Alessandro Ottaviano are with the Integrated Sys- tems Laboratory (IIS), ETH Zrich, 8092 Zrich, Switzerland (e-mail: balasriis.ee.ethz.ch; aottavianoiis.ee.ethz.ch)."
  ],
  "335": [
    "Luca Benini is with the Integrated Systems Laboratory (IIS), ETH Zrich, Zrich, Switzerland, and also with the Department of Electrical, Electronic and Information Engineering (DEI), University of Bologna, 40126 Bologna, Italy (e-mail: lbeniniiis.ee.ethz.ch)."
  ],
  "245": [
    "Color versions of one or more figures in this article are available at https:doi.org10.1109TVLSI.2024.3377130."
  ],
  "355": [
    "Digital Object Identifier 10.1109TVLSI.2024.3377130 requirements imposed by such scenarios."
  ],
  "244": [
    "For example, the development of Linux, a popular open-source GPOS kernel, is focused on average performance, making it less suitable to be used for real-time applications 2."
  ],
  "407": [
    "Albeit extensions and modifications that aim at improving determinism and latencies of critical operations in Linux have been proposed and implemented 2, 3, 4, 5, and they do not guarantee strict bounds on maximum latencies of operations and lack industry-grade maturity to be employed in hard real-time scenarios."
  ],
  "37": [
    "Real-time operating systems (RTOSs) kernels are special- purpose operating systems (OSs) designed to provide real-time guarantees, such as task scheduling according to a given expected completion deadline and deterministic latencies of various operations 6.",
    "A. Stankovic, Scheduling algorithms and operating systems support for real-time systems, Proc."
  ],
  "323": [
    "The RTOS scheduler might add a significant overhead due to the combined effect of both the context switches required to handle the transition from a foreground to a background task and the amount of time elapsed from the source event that causes the preemption and the first instruction of the awakened task (known as interrupt latency 7), thus increasing the worst case execution time (WCET) 2, 8, 9."
  ],
  "42": [
    "The cost of saving and restoring the task state during a context switch is a significant concern as it remains relatively high.",
    "Long context switch times reduce available task utilization and the minimum viable switching granularity."
  ],
  "251": [
    "For instance, the process state that needs to be saved on a context switch includes the program counter, register files (RF)s, status registers, address space mapping, etc."
  ],
  "378": [
    "Therefore, a significant number of memory access operations need to be performed to store the state of the preempted task and restore the state of the new task to be executed 10."
  ],
  "351": [
    "Besides the tasks context switching, a switch into an interrupt context from normal program execution happens each time an asynchronous event is triggered from, e.g., an IO peripheral device."
  ],
  "393": [
    "Behnke et al."
  ],
  "307": [
    "11 provide a meaningful example of the impact on interrupt latency of network loads in time-critical microcontroller units (MCUs), where a high overhead generated by the receiving of packets can be seen in continuous floods as well as short transmission bursts, reaching up to 50 task latenessthe additional time a task takes to finish than its deadline allows, which will start to accumulate over iterations from the critical network loadincrease per packet per second."
  ],
  "49": [
    "Furthermore, HW-induced interrupt latency is only one part of the problem: SW-induced interrupt latency, 1063-8210  2024 IEEE.",
    "Interrupt latency breakdown into SW- and HW-dependent contribu- tions."
  ],
  "336": [
    "Personal use is permitted, but republicationredistribution requires IEEE permission."
  ],
  "76": [
    "See https:www.ieee.orgpublicationsrightsindex.html for more information.",
    "IEEE, vol.",
    "IEEE 39th Int."
  ],
  "12": [
    "Authorized licensed use limited to: California Polytechnic State University San Luis Obispo.",
    "It can route a Authorized licensed use limited to: California Polytechnic State University San Luis Obispo.",
    "The CLIC design proposed in Authorized licensed use limited to: California Polytechnic State University San Luis Obispo.",
    "This can be achieved since we know how the interrupt state gets pushed Authorized licensed use limited to: California Polytechnic State University San Luis Obispo.",
    "Authorized licensed use limited to: California Polytechnic State University San Luis Obispo.",
    "Authorized licensed use limited to: California Polytechnic State University San Luis Obispo.",
    "The latter reduces the execution time of the Authorized licensed use limited to: California Polytechnic State University San Luis Obispo.",
    "Authorized licensed use limited to: California Polytechnic State University San Luis Obispo.",
    "Authorized licensed use limited to: California Polytechnic State University San Luis Obispo."
  ],
  "114": [
    "Downloaded on May 28,2025 at 17:50:39 UTC from IEEE Xplore.",
    "Downloaded on May 28,2025 at 17:50:39 UTC from IEEE Xplore.",
    "Downloaded on May 28,2025 at 17:50:39 UTC from IEEE Xplore.",
    "Downloaded on May 28,2025 at 17:50:39 UTC from IEEE Xplore.",
    "Downloaded on May 28,2025 at 17:50:39 UTC from IEEE Xplore.",
    "Downloaded on May 28,2025 at 17:50:39 UTC from IEEE Xplore.",
    "Downloaded on May 28,2025 at 17:50:39 UTC from IEEE Xplore.",
    "Downloaded on May 28,2025 at 17:50:39 UTC from IEEE Xplore.",
    "Downloaded on May 28,2025 at 17:50:39 UTC from IEEE Xplore.",
    "Downloaded on May 28,2025 at 17:50:39 UTC from IEEE Xplore.",
    "Downloaded on May 28,2025 at 17:50:39 UTC from IEEE Xplore.",
    "Downloaded on May 28,2025 at 17:50:39 UTC from IEEE Xplore.",
    "Downloaded on May 28,2025 at 17:50:39 UTC from IEEE Xplore."
  ],
  "64": [
    "Restrictions apply.",
    "Restrictions apply.",
    "Restrictions apply.",
    "Restrictions apply.",
    "Restrictions apply.",
    "Restrictions apply.",
    "Restrictions apply.",
    "Restrictions apply.",
    "Restrictions apply.",
    "Restrictions apply.",
    "Restrictions apply.",
    "Restrictions apply.",
    "Restrictions apply."
  ],
  "354": [
    "BALAS et al.",
    "BALAS et al.",
    "BALAS et al.",
    "BALAS et al.",
    "BALAS et al.",
    "BALAS et al."
  ],
  "29": [
    ": CV32RT: ENABLING FAST INTERRUPT AND CONTEXT SWITCHING 1033 introduced by the GPOSRTOS scheduler and the user code, primarily impacts the capability of the system to provide timely responses to asynchronous events.",
    ": CV32RT: ENABLING FAST INTERRUPT AND CONTEXT SWITCHING 1035 TABLE I NESTED INTERRUPT PREEMPTION SCHEME ACCORDING TO RISC-V CLIC.",
    "CV32RTfastirq optimizes interrupt latency in the non-nested interrupt case by com- bining bank switching and the nested interrupt case with an automatic context-saving mechanism in the background.",
    "C. CV32RTfastirq: Fast Interrupt Extension 1) Automatic Hardware Context Saving and Bank Switch- ing: A block diagram of CV32RTfastirq is shown in Fig.",
    ": CV32RT: ENABLING FAST INTERRUPT AND CONTEXT SWITCHING 1037 Fig.",
    ": CV32RT: ENABLING FAST INTERRUPT AND CONTEXT SWITCHING 1039 pointer appropriately before triggering an SW interrupt (write to CLICs memory map).",
    ": CV32RT: ENABLING FAST INTERRUPT AND CONTEXT SWITCHING 1041 Fig.",
    ": CV32RT: ENABLING FAST INTERRUPT AND CONTEXT SWITCHING 1043 instruction in machine mode (i.e., emret), which is able to skip redundant context saving and restoring sequences by directly jumping to the next available interrupt handler."
  ],
  "253": [
    "Low interrupt latency and context switch time are crucial metrics for a wide range of platforms ranging from commodity MCU-class embedded systems to more advanced and complex application-class mixed criticality systems (MCSs), where timesafety-critical and non-critical applications coexist on different isolated partitions of the same HW platform 12."
  ],
  "386": [
    "Response and context switch time minimization thus become a challenge to be tackled at the HWSW interface, where SW programming techniques and HW interrupt controller archi- tectures can cooperate to ensure minimal response time 7."
  ],
  "267": [
    "Although commercial vendors and IP providers offer such features as in-house solutions, they are often proprietary and tightly coupled with the vendors instruction set architecture (ISA), target HW family, and associated SW stack."
  ],
  "237": [
    "On the other hand, in the last decade, the ever-growing RISC-V ecosystem 13 has been offering a modular, free, and open- source ISA which is rapidly becoming the de facto lingua franca of computing."
  ],
  "15": [
    "Nevertheless, RISC-V support for fast interrupt and context switch handling is still not mature enough to compete with incumbent proprietary architectures, as it lacks flexible inter- rupt prioritization, preemption mechanisms, and low interrupt latency.",
    "While the modular RISC-V ISA enables developing orthog- onal custom extensions, to the best of the authors knowledge, there are few published works that 1) tackle the problem of minimizing interrupt latency and context switch time from a holistic (HW and SW) viewpoint for RISC-V; 2) try to close the gap with more established proprietary solutions, thereby promoting RISC-V as a valuable candidate for time- and safety-critical application domains such as automotive and aerospace; and 3) provide an open-source solution to be shared with the community.",
    "Interrupt latency of various flavors of RISC-V core-specific inter- rupt controllers for interrupt handlers that support nesting and the calling of C-functions within it (i.e., savingrestoring state following the C-ABI).",
    "With our design, we can achieve interrupt latencies of six clock cycles and efficient back-to-back interrupt handling in 12 cycles which is as low as the fastest available approaches currently implemented in the RISC-V landscape, fully open- source, and competitive against closed-source and proprietary commercial solutions."
  ],
  "379": [
    "In particular, this article makes the following contributions."
  ],
  "321": [
    "We make the implementation avail- able under a permissive open-source license.1 1https:github.compulp-platformclic 2) We design a fast interrupt extension (fastirq) to accelerate both nested (see Section III-A) and non- nested (see Section III-D) interrupt case scenarios."
  ],
  "136": [
    "fastirq reduces interrupt latency by hiding the latency through memory banks and a background-saving mechanism.",
    "Compared to the baseline CLINT and CLIC which both have about 33 cycles interrupt latency, the fastirq extension is able to reduce this down to six cycles."
  ],
  "213": [
    "The same mechanism allows one also to accelerate context switching through HWSW coopera- tion."
  ],
  "249": [
    "Furthermore, we propose early mret (emret), a novel instruction that further optimizes tail-chaining compared to the baseline strategy proposed in the CLIC standard (i.e., xnxti) and its enhancement from 18 (jalxnxti)."
  ],
  "302": [
    "4) Finally, we compare CV32RT with leading COTS sys- tems in both nested and non-nested interrupt scenarios (see Section V)."
  ],
  "339": [
    "We show that the proposed solution pro- motes RISC-V as a competitive candidate for building the next generation of time-critical systems."
  ],
  "297": [
    "II."
  ],
  "264": [
    "This core is embedded in ControlPULP 19, a SoC specialized in running real-time workloads."
  ],
  "310": [
    "The system contains a CV32 manager core, a programmable accelerator subsystem consisting of eight CV32 cores, and a set of standard peripherals such as quad serial peripheral interface (QSPI), inter-integrated circuit (I2C), and universal asyn- chronous receiver-transmitter (UART)."
  ],
  "258": [
    "The manager core is responsible for scheduling tasks, communicating with the peripherals, offloading tasks to the accelerator subsystem, and being responsive to asynchronous external events, e.g., interrupts."
  ],
  "273": [
    "ControlPULP hosts a set of scratchpad memories (SPMs) that guarantee single-cycle access time from the CV32 man- ager core."
  ],
  "252": [
    "This design choice enables deterministic memory access latency for both data load, store, and instruction fetch, bounding the worst case latency when handling unpredictable events."
  ],
  "370": [
    "Applications run on top of FreeRTOS 20, an open-source, priority-based preemptive RTOS, in the manager core from where tasks are scheduled and run."
  ],
  "232": [
    "2https:github.compulp-platformcontrol-pulp Authorized licensed use limited to: California Polytechnic State University San Luis Obispo."
  ],
  "129": [
    "6, JUNE 2024 Fig.",
    "6, JUNE 2024 Fig.",
    "6, JUNE 2024 Fig."
  ],
  "0": [
    "1.",
    "1.",
    "2.",
    "3.",
    "3.",
    "4.",
    "5.",
    "6.",
    "6.",
    "7.",
    "8.",
    "9.",
    "10.",
    "10.",
    "1."
  ],
  "2": [
    "B. Interrupts 1) Level- and Edge-Triggered Interrupts: Interrupt sources can signal interrupts either through a level change of the interrupt line, called a edge-triggered interrupt, or by the logic level itself, a level-triggered interrupt.",
    "2) Nested Interrupts: Following the notation adopted in Section II-B5, the case of nested interrupts entails preemption of a low-level interrupt by a high-level interrupt, as shown in Fig.",
    "(a) Transition between different interrupt levels."
  ],
  "225": [
    "While the latter requires the receiving side of the interrupt to clear the source often through accessing appropriate HW registers, the former is unidirectional notification without confirmation."
  ],
  "28": [
    "This results in faster processing but may lead to dropping interrupt requests accidentally.",
    "This increases the worst case interrupt latency by the time they remain disabled.",
    "This allows execution of the interrupt handler before all interrupt state has been pushed to memory, lowering interrupt latency."
  ],
  "329": [
    "2) Vectored and Direct Interrupts: Interrupts are asyn- chronous events that alter the normal program order execution and require a switch to a different context to handle the event."
  ],
  "14": [
    "A processor supports vectored interrupts when each interrupt traps to a specific interrupt service routine (ISR) according to an interrupt vector table, granting fast interrupt response at the cost of increased code size.",
    "To improve interrupt latencies, interrupt vectoring is sup- ported."
  ],
  "346": [
    "Conversely, non-vectored or direct interrupts trap to a shared ISR."
  ],
  "294": [
    "The latter approach trades code size off for a slower interrupt response since the overhead of resolving the interruption cause and jumping to the correct ISR are handled in explicit instructions while the interrupt table can be made much more compact."
  ],
  "6": [
    "3) Interrupt Latency: Multiple sources determine the inter- rupt latency in a system: the underlying HW, the scheduler or OS, and the application running on top as detailed.",
    "In this article, we focus on minimizing the latency imposed by the HW; thus, whenever we refer to interrupt latency, we mean its HW-contributed part.",
    "The latter consists of restor- ing the interrupt context and the regular interrupt latency."
  ],
  "212": [
    "This breakdown is detailed in Fig."
  ],
  "92": [
    "Interrupt latency is defined as the time it takes from an interrupt edge arriving at the HW, usually the interrupt controller, to the execution of the first instruction of the corresponding interrupt handler routine.",
    "The interrupt latency is measured as the number of cycles it takes for an interrupt to arrive at the interrupt controller input to the first instruction of an interrupt handler that allows the calling of a C-function."
  ],
  "36": [
    "To make a fair comparison between SW-based and more HW-oriented interrupt solutions, we have to delineate what exactly constitutes the first instruction of the interrupt handler.",
    "Each HW configuration has a handwrit- ten optimized interrupt handler that stores all required general-purpose and machine-specific registers for nesting interrupts."
  ],
  "371": [
    "We count as the first instruction the one after all necessary interrupt context has been saved on the stack to be able to call a function."
  ],
  "322": [
    "What exactly entails a function call is dictated by the used application binary interface (ABI) or, more precisely, its calling convention."
  ],
  "5": [
    "Note that when the interrupt handler and interrupt context saving code can be interleaved, some of the context saving code can be removed as it might be redundant.",
    "The active interrupt handlers context must be restored on interrupt return but is immediately saved again due to the next pending interrupt firing.",
    "Restoring the pre-interrupt context is entirely handled in SW for the nested interrupt case."
  ],
  "405": [
    "4) Context Switching Time: The time it takes for a context switch determines the responsiveness of the architecture in swapping from one execution context to another."
  ],
  "277": [
    "The execu- tion context is dependent on the OS being used but usually consists of the state of the architectural registers of the ISA and the chosen ABI."
  ],
  "16": [
    "5) Interrupt Nesting: Preemption refers to an event, such as an interrupt request, temporarily interrupting a current task with the purpose of resuming its execution later.",
    "The simplest case for preemption occurs with non-nested interrupt handlers, where interrupts are globally disabled during the execution of an ISR.",
    "A more complex case for preemption occurs with nested interrupt handlers to handle the case of multiple interrupts at a time.",
    "This situation does not result in preemption, rather causes pending interrupts to be serviced in sequence according to increas- ing priority."
  ],
  "72": [
    "In the case of levelpriority interrupt schemes, this means that: 1) if the levelpriority arbitration is SW-driven, e.g., with priority simplestandard interrupt handlers, the highest priority interrupt identification code is not executed, and 2) if the levelpriority arbitration logic is designed within the interrupt controller, the high- est levelpriority interrupt is pending but disabled, hence not propagated to the core.",
    "With a levelpriority interrupt scheme (either SW or HW driven), this introduces additional masking of incoming interrupts of equal or lower levelpriority than the executing ISR, and sometimes larger than a configurable levelpriority threshold."
  ],
  "31": [
    "This scenario is not ideal for real-time and complex embedded systems, as interrupts are served sequentially.",
    "This is insufficient for the embedded and real-time domain, and attempts to handle a more complex interrupt scheme would require SW emulation, which incurs untenable interrupt latencies."
  ],
  "352": [
    "A high-priority interrupt has to wait for a lower-priority interrupt to finish."
  ],
  "39": [
    "In this scenario, interrupts are globally enabled within the scope of an executing ISR.",
    "Whenever an interrupt handler is entered, global interrupts are disabled."
  ],
  "215": [
    "The ISR need to care designed to ensure the they are reentrant."
  ],
  "333": [
    "The nesting allows higher priority interrupts to preempt a current lower priority ISR executing."
  ],
  "85": [
    "6) Redundant Interrupt Context: Back-to-back interrupts, i.e., interrupts that need to be served sequentially, can happen whenever there are multiple interrupts pending.",
    "The transition from one interrupt to the next one causes a redundant sequence of context restores and context saves.",
    "These redundant context restore sequences negatively impact interrupt latency on higher interrupt loads 21.",
    "D. Interrupt Scenario Analysis 1) Non-Nested Interrupts: As discussed in Section II-B, redundant context restore with non-nested or nested horizontal interrupts can introduce unwanted additional interrupt latency.",
    "(b) Redundant context restore of two non-preemptive interrupts (e.g., two interrupts with same level but different priorities) and tail-chaining to optimize it.",
    "3) Redundant Context Restoring: As described in Section II-B, whenever there are back-to-back interrupts, the interrupt context restore and store sequence between them can be considered redundant.",
    "In this case, the redundant context restoring sequences contains the full interrupt exit code sequence.",
    "3) Optimizations for Non-Nested Interrupt Handling: Redundant context restore with non-nested interrupts is addressed by chaining two back-to-back interrupts and bypass- ing the superfluous restoresave operation."
  ],
  "283": [
    "Section III-D explores the optimizations implemented in this work to address this scenario."
  ],
  "13": [
    "In the RISC-V ecosystem, the privileged specification 14 defines a simple interrupt scheme with a set of timer and inter-processor interrupts.",
    "Compared to standard RISC-V privileged specifications, pending and enabled interrupts are further selectively masked according to a threshold value representing an interrupt level, configured through a CSR.",
    "RISC-V Platform-Level Interrupt Con- troller Specification."
  ],
  "290": [
    "We refer to it as the core local interruptor (CLINT)."
  ],
  "279": [
    "For 32-bit cores, it defines a fixed priority interrupt scheme with 16 predefined or reserved and 16 implementation-defined inter- rupts that can be optionally vectored."
  ],
  "7": [
    "The CLINT itself only supports prioritization of interrupts based on privilege mode.",
    "Due to the inflexible interrupt scheme of the CLINT-mode, much more work needs to be done in managing interrupt mask (SOMEIRQMASK) and other machine state.",
    "Note that in CLINT-mode interrupts with lower priority than the current interrupt running can fire when global interrupts are re-enabled.",
    "For the embedded use cases, the CLINT lacks fine-grained control over interrupt prioritization."
  ],
  "406": [
    "To increase the number of custom interrupts, a PLIC 22 can be attached to the CLINT."
  ],
  "96": [
    "WE ASSUME AN INTERRUPT REQUEST I R Q2 IS BEING SERVICED WHILE ANOTHER REQUEST I R Q1 IS ENABLED AND PENDING.",
    "We consider an active interrupt handler servicing irq2 while irq1 is pending."
  ],
  "23": [
    "PREEMPTION IS REGULATED BY PRIVILEGE MODE (Vertical INTERRUPTS) AND INTERRUPT LEVEL WHEN THE PRIVILEGE MODE IS THE SAME (Horizontal INTER- RUPTS) flexible (at design time) number of interrupts to one or more targets.",
    "Interrupts that are assigned a higher level can pre-empt lower-level interrupts."
  ],
  "320": [
    "A single HART can correspond to multiple targets."
  ],
  "3": [
    "Each interrupt can be assigned a priority, and each target can select a threshold below which interrupts are disabled.",
    "Interrupt selection is driven by the CLIC in HW (see Section III-B), which propagates the highest level, highest priority pending interrupt to the cores interface.",
    "Interrupt priority serves as a tie-breaker for the case of multiple interrupts pending with the same level.",
    "Assuming n interrupt sources, selecting the interrupt with maximum level and priority is implemented with three binary trees.",
    "Enabled interrupts and their level and priority information are then further sent to prioritization logic which uses a binary arbitration tree to select the highest-level interrupt.",
    "Interrupts can be dynamically assigned a priority and a level.",
    "The priorities allow concurrent pending interrupts to be taken in the order preferred by the programmer, while the level information enables pre-emption of same-privilege level interrupts (also called horizontal interrupts)."
  ],
  "404": [
    "This scheme allows interrupts to be divided according to their priorities on the PLIC-level allowing for some flexibility in terms of prioritization, but does not address the flexibility problem on the core local-level."
  ],
  "18": [
    "2) CLIC: The CLIC 15 addresses these limitations by allowing interrupts to be prioritized by so-called levels and priorities.",
    "Analogously, the case where multiple horizontal interrupts have equal levels and priorities results in the CLIC selecting the highest numbered interrupt (identification number id) 15, which is an arbitrary assignment decided at design time."
  ],
  "380": [
    "Interrupts that are enabled, pending, and have a level below the threshold are masked, while others can be propagated."
  ],
  "90": [
    "This feature is useful for, e.g., RTOSs that only want to disable a subset of all interrupts during critical sections.",
    "This can be useful in critical sections where only a subset of interrupts need to be disabled."
  ],
  "301": [
    "Interrupts that do not interfere with the data accessed in such a critical section can still fire."
  ],
  "17": [
    "Consider two interrupts requests irq1 and irq2 with interrupt privilege modes, levels and priorities (priv1, l1, p1) and (priv2, l2, p2), respectively.",
    "In general, irq1 preempts irq2 whenever its level is higher than both the interrupt threshold and irq2s level."
  ],
  "332": [
    "Following the termi- nology introduced in Section II-B and by the CLIC, we will refer to interrupts fired from different privilege modes as ver- tical interrupts and to interrupts fired from the same privilege mode as horizontal interrupts throughout this article."
  ],
  "219": [
    "Table I shows preemption conditions of two nested inter- rupts irq2 and irq1 according to the CLIC specification."
  ],
  "202": [
    "Finally, the CLIC specification addresses the case of redundant context restore (see Section II-B6) by introducing xnxti, a CSR short for Next Interrupt Handler Address and Interrupt-Enable CSRs meant for use with non-vectored interrupts."
  ],
  "374": [
    "Reading from this CSR, while the core is within an active handler, allows to fast-track interrupts that arrive late or to avoid redundant context saverestore by running through pending interrupts back-to-back."
  ],
  "361": [
    "ARCHITECTURE Entering an interrupt context or performing a context switch requires the HW to store enough information to resume operation correctly after returning from the aforementioned context."
  ],
  "255": [
    "This needs to be done as fast as possible."
  ],
  "400": [
    "From a high-level point of view, we can effectively improve interrupt latency and context switch times by: 1) controlling the amount of state that needs to be preserved to enter and leave an interrupt context; 2) increasing the bandwidth and decreasing the latency to memory; 3) relying on latency-hiding techniques that defer the effec- tive saving of the state to a later point in time."
  ],
  "285": [
    "In the following, we detail the architectural features and HWSW codesign of CV32RT (see Sections III-AIII-C), and then describe how the proposed architecture tackles typical case scenarios (see Section III-D)."
  ],
  "411": [
    "The background-saving mechanism updates the stack pointer and stores the bank-switched contents in memory while the execution of the core proceeds in parallel."
  ],
  "300": [
    "2 provides an overview of the design."
  ],
  "27": [
    "Incoming interrupts are filtered with a Gateway module that decides whether there is a pending and enabled request for each interrupt source i (IRQ i).",
    "For each interrupt source, they track: 1) interrupt level and priority; 2) interrupt id; and 3) pending state from the gateway module.",
    "Interrupts arrive at the gateway, where they are combined with programmable configuration information about each interrupt line consisting of level, priority, enable status, and sensitivity (leveledge)."
  ],
  "184": [
    "The Interrupt Prioritization module traverses the tree from leaves to the root, where the sought-after maximum level and priority interrupt is found."
  ],
  "268": [
    "Each tree has low overhead in terms of area and delay, O(n) and O(log(n)), respectively."
  ],
  "324": [
    "CLIC architecture overview."
  ],
  "350": [
    "The interrupt is then presented to the core with a handshake-based interface."
  ],
  "337": [
    "The additional kill signal is there to allow for a handshake to restart so that a potentially more important interrupt can be presented to the core."
  ],
  "362": [
    "this work can scale up to n  4096 local interrupt sources."
  ],
  "281": [
    "Optionally, additional pipeline stages can be inserted in the arbitration tree to relax timing."
  ],
  "396": [
    "Finally, our version of the CLIC supports SHV and the xnxti CSR in the core."
  ],
  "47": [
    "Albeit improving the interrupt handling capabilities of CV32 by introducing priority and levels management in HW, critical operations such as interrupt state and context saverestore are not natively covered by the CLIC and need to be handled in SW. CV32fastirq aims at filling this gap.",
    "The CLIC addresses this with the levelpriority scheme and fastirq improves upon that by moving the interrupt state saving logic in HW and adding emret to handle redundant interrupt context sequences."
  ],
  "314": [
    "Conceptually, we can think of fastirq as a wrapper around the cores RF."
  ],
  "338": [
    "We extend the RF by an additional read port for the background-saving mechanism and registers for latching the additional processor state required for proper interrupt nesting."
  ],
  "363": [
    "A new interrupt at the CLIC will first be checked whether the interrupt level exceeds the configured threshold."
  ],
  "373": [
    "If this is the case, it will be dispatched to the cores main state machine while concurrently triggering the saving logic finite state machine (FSM) in the extended RF."
  ],
  "269": [
    "The cores state machine will flush the pipeline and update the program counter according to the vector table entry."
  ],
  "56": [
    "Meanwhile, in the extended RF, the saving logic triggers a bank switch, allowing the interrupt context to have a fresh set of registers while draining the other bank contents through a separate port to the main memory.",
    "On an interrupt, the RF banks are switched."
  ],
  "293": [
    "2) Stack Pointer Handling: During a bank switch, we need to update the stack pointer."
  ],
  "207": [
    "For that, we have a dedicated adder between the two RFs."
  ],
  "38": [
    "The RISC-V embedded and integer ABI dictate that the stack pointer points below the last saved register on the stack.",
    "The stack pointer is adjusted appropriately to maintain ABI invariants."
  ],
  "311": [
    "Furthermore, if we did not adjust the pointer, the program code running in the interrupt handler could clobber the values on the stack."
  ],
  "246": [
    "We could do away with this mechanism for leaf-type interrupts, but this would require a new ABI considering a virtual stack pointer offset when generating code for interrupt handlers, and it would not solve the nested interrupt case."
  ],
  "392": [
    "3) Conflict Handling: There are interactions between the background-saving mechanism and regular loadstore instruc- tions of the core that could potentially result in incorrect execution."
  ],
  "358": [
    "In the case where a load instruction is trying to update an architectural register while the background-saving mechanism is trying to read the same register, no conflict arises because interrupts are injected into the pipeline and only acted upon in the write-back stage of the core."
  ],
  "376": [
    "At this point, updates to the RF are resolved, and then the bank switching operation takes place ensuring correctness of the execution."
  ],
  "40": [
    "While the interrupt handler is already executing, we also need to ensure that loads or stores accessing stack memory regions where the background-saving mechanism is writing to are properly resolved.",
    "If this happens while the background-saving mechanism is still at work, the execution of the handler has to wait."
  ],
  "327": [
    "Otherwise, we could read stale data or write data that is immediately overwritten."
  ],
  "150": [
    "This is handled by informing the load-store unit of the core of the ongoing state being written to memory."
  ],
  "397": [
    "A straightforward solution is to stall the cores pipeline while the background-saving mechanism is at work."
  ],
  "326": [
    "This, though, partially negates the advantage of executing ahead since we likely want to issue a load soon in the interrupt handler."
  ],
  "233": [
    "We address this problem by additionally checking whether the load-store unit tries to access the memory in the range of the stack pointer."
  ],
  "299": [
    "More precisely, on an interrupt the stack pointer is decremented, making space available, while the background-saving mechanism will start storing the interrupt state word by word."
  ],
  "243": [
    "In the load-store unit, the address offset of the last word pushed out by the background-saving mechanism is compared against any incoming load and stores."
  ],
  "188": [
    "Load and stores that try to access data that is not yet pushed to memory cause the cores pipeline to stall."
  ],
  "394": [
    "This mechanism ensures the correctness of loads and stores issued by the core."
  ],
  "401": [
    "4) Co-Operation of Compiler and Hardware: Accessing stack memory locations during the execution of an interrupt handler typically happens in two use cases."
  ],
  "303": [
    "1) A system call handler (issued through the ecall instruction in RISC-V) wants to access user-provided arguments."
  ],
  "410": [
    "Most will be passed through general-purpose registers, but some might be placed on the stack 2) Short interrupt handlers that want to return before the full interrupt state has been saved."
  ],
  "266": [
    "Each of these cases would potentially engage the stalling logic outlined in Section III-C3, causing higher interrupt latencies."
  ],
  "223": [
    "An HW solution to mitigate the stalling issue would be to add forwarding logic that checks in the load-store unit what is being written by the background-saving mechanism and directly forward these values from the store queue instead of going through the memory subsystem outside the core."
  ],
  "383": [
    "Some register values still cannot be forwarded because they might not have reached the load-store unit yet."
  ],
  "313": [
    "Furthermore, the approach increases HW complexity, requiring a dynamic address lookup into a queue-like buffer."
  ],
  "331": [
    "We propose instead an SW-based solution that does not cause any kind of stalling."
  ],
  "381": [
    "The insight is that we do not need to engage the pipeline stalling logic by ordering the loads to access the already stored interrupt state first."
  ],
  "1": [
    "Overview of the fast interrupt architecture.",
    "and potential nesting interrupt handlers, albeit with a larger delay.",
    "We give an analysis of the functional improvements and argue that these allow more flexible and efficient handling of regular and nested interrupts."
  ],
  "226": [
    "The cv32s RF is extended with additional logic for the background-saving mechanism."
  ],
  "125": [
    "Parts of the old memory bank (the interrupt context) are copied to the cores stack location, while execution can go ahead by using the new bank."
  ],
  "334": [
    "In this design, there is a dedicated memory port for the background-saving mechanism, but optionally it can also be shared with the port from the load-store unit."
  ],
  "235": [
    "For example, if we push out the general-purpose registers x1, x2, ."
  ],
  "375": [
    "in that very same order, then we need to ensure that in the interrupt handler, we use the same order to load words back."
  ],
  "325": [
    "Note that this is a performance issue and does not affect correctness."
  ],
  "146": [
    "When writing assembly, the program- mer has to be aware of that to achieve the best pos- sible latency."
  ],
  "105": [
    "In the case that the programmer uses compiler-specific attributes to write his interrupt handlers, such as attribute((interrupt)) in GCC, the compiler needs to be made aware of that fact."
  ],
  "408": [
    "5) Interrupt Handler Routines: In Fig."
  ],
  "44": [
    "4, we give an overview of how nested interrupt handling code works for the basic CLINT-mode, the baseline CLIC, and our fastirq extension.",
    "Routines for saving state for vectored nesting interrupts using (a) CLINT, (b) CLIC, and (c) proposed fastirq extension."
  ],
  "368": [
    "6) Register File Overhead: RISC-V defines RV32E as a variant of RV32I, which only has 16 registers instead of 32."
  ],
  "359": [
    "Reducing the RF size helps lower context switch times but does not affect the interrupt latency since the set of caller-save registers remains the same when using the embedded-application binary interface (EABI)."
  ],
  "372": [
    "Our imple- mentation allows the core to dynamically switch between RV32I and RV32E with fastirq depending on the work- load."
  ],
  "328": [
    "This allows for the reuse of the unused half of the RF."
  ],
  "149": [
    "If the increased pressure on the RF is not acceptable, instead of doubling the RF size for the banking logic, one could just add additional registers for the seven caller-save registers to save area."
  ],
  "306": [
    "With the proposed approach, the interrupt state can be quickly restored by simply switching register banks."
  ],
  "133": [
    "To differentiate between a regular return from an interrupt handler using mret, which assumes the interrupt state has been restored by SW, we add a new instruction emret instead."
  ],
  "175": [
    "This instruction performs the same function as mret in addition to switching register banks."
  ],
  "382": [
    "In the RISC-V ecosystem, this situation can be optimized by directly checking for other interrupts pending on the same level before restoring the executions interrupt context."
  ],
  "289": [
    "The CLIC offers an HW-assisted solution to address such a scenario with the xnxti CSRs (see Section II-C2)."
  ],
  "33": [
    "Nucleis enhanced CLIC (ECLIC) 18 extends xnxti by embedding the jump to the queuing interrupt handler in the xnxti HW (jalxnxti).",
    "Nuclei System Technology ECLIC 39 extends traditional xnxti with a novel CSR for machine privilege mode, jalmnxti 18, already discussed in this work in Section IV."
  ],
  "308": [
    "In our case, this is implemented through the emret instruction."
  ],
  "248": [
    "Besides checking whether a bank switch is appropriate, it also looks at interrupts pending with the same or lower level."
  ],
  "144": [
    "If such an interrupt exists, emret redirects the control flow to the pending interrupts handler."
  ],
  "399": [
    "Some HW refers to this concept of removing redundant context restores as tail-chaining 23."
  ],
  "349": [
    "This situation is visualized in Fig."
  ],
  "50": [
    "5(b).",
    "5(a)."
  ],
  "22": [
    "We address this scenario by minimizing interrupt latency through hiding latency.",
    "Minimizing Interrupt Response Time."
  ],
  "402": [
    "For nesting interrupts, the first instruction will be re-enabling global interrupts."
  ],
  "391": [
    "At this point, a high-level interrupt could preempt the current running interrupt handler."
  ],
  "398": [
    "This combination of latency hiding and background saving allows the core to quickly enter a first-level interrupt handler Authorized licensed use limited to: California Polytechnic State University San Luis Obispo."
  ],
  "160": [
    "This assumes the regular RISC-V embedded ABI."
  ],
  "161": [
    "In order to prevent that, mie has to be manually adjusted such that the corresponding lower-priority interrupts are disabled."
  ],
  "282": [
    "While this return path could also be handled in HW by adding an additional write port to the cores RF, exiting an interrupt handler is less time-critical since we mostly care about how quickly an external event is addressed."
  ],
  "315": [
    "E. Context Switching Acceleration We can divide context switches into OS-specific and HW- specific parts."
  ],
  "229": [
    "The OS part entails all contributions to the context switch time that is specific to the OS itself, such as computing the next task to be scheduled and bookkeeping operations."
  ],
  "185": [
    "The remainder is the HW-dependent saving and restoring of the state belonging to the new context."
  ],
  "195": [
    "The idea is to use the background-saving mechanism to accelerate the state saving and restoring part of context Fig."
  ],
  "67": [
    "switches by interleaving the loading of a new state with the automatic saving HW pushing out the previous register state to memory in the background.",
    "This will engage the HW mechanism to swap the registers and save them in the background while we can already proceed with the rest of the context switch routine."
  ],
  "80": [
    "For that, the initial part of the context switch routine changes.",
    "any impact on context switching."
  ],
  "162": [
    "At the beginning of the routine, we want to save the current running tasks state to memory."
  ],
  "360": [
    "Instead of manually saving the general-purpose registers, we set up the stack Authorized licensed use limited to: California Polytechnic State University San Luis Obispo."
  ],
  "238": [
    "Additional RISC-V extensions that introduce more context switching state run contrary to the goals of fastirq regard- ing latencies."
  ],
  "364": [
    "While there are no technical limitations with respect to adding more state to fastirq, the resulting design would incur a significant increase in area and power."
  ],
  "112": [
    "If a specific extension is still required, a dirty bit to make context lazy switchable could help to keep the fast path competitive."
  ],
  "284": [
    "EVALUATION This section gives a functional and quantitative evaluation of the various flavors of the CV32RT."
  ],
  "276": [
    "Feature Comparison As discussed in Section II, the CLINT is the first stan- dardized RISC-V interrupt controller."
  ],
  "348": [
    "It supports pre-emption based on privilege modes (machine, hypervisor, supervisor, user), but the interrupt lines have a hardwired prioritiza- tion scheme."
  ],
  "240": [
    "The baseline CLIC addresses these weaknesses."
  ],
  "209": [
    "In addition to that, a level threshold register per privilege level (xintthresh) controls the set of allowed horizontal interrupts by limiting it to those whose level exceeds the given value in the register."
  ],
  "46": [
    "Vectoring can be selectively enabled or disabled per interrupt line.",
    "This solution works for both vectored and non-vectored interrupts."
  ],
  "295": [
    "This allows for better control of the vector table size."
  ],
  "312": [
    "The baseline CLIC does not differ from the regular CLINT in terms of storing and restoring the interrupt context which is fully handled in SW."
  ],
  "87": [
    "The optional xnxti extension allows multiple horizon- tal interrupts to be serviced in sequence without redundant context-restoring operations in between.",
    "In addition, the first interrupt has to still pay the full latency cost since xnxti does not touch the interrupt context storing part itself."
  ],
  "203": [
    "Reading the xnxti CSR yields a pointer to the vector table entry for the next pending and qualifying interrupt, if available, which then allows a direct jump there."
  ],
  "155": [
    "This approach loses the latency advantage of HW vectoring by basically running an SW emulation thereof."
  ],
  "187": [
    "The discussed differences are summarized in Table II."
  ],
  "296": [
    "B. Functional Performance 1) Measurement Setup: We take measurements by running RTL simulations of the different versions of CV32RT as part of ControlPULP."
  ],
  "343": [
    "For the memory subsystem, this means we have single cycle (zero wait state) access to static random access memory (SRAM) (see Section II-A)."
  ],
  "330": [
    "The memory bank we are using is not contended by other bus masters which is achieved by placing data and instructions into specific private banks."
  ],
  "224": [
    "On the system level, there are no additional latencies introduced on interrupt lines between interrupt sources and the CLIC."
  ],
  "24": [
    "2) Interrupt Latency: We measure the HW contributed interrupt latency (as described in Section II-B3) of our fastirq extension and compare it to the CV32 and CV32RT variations (standard CLIC, xnxti, jalxnxti).",
    "9 reports the area breakdown comparison of CV32RT with baseline CLIC (including mnxti and jalmnxti CSRs) and fastirq extensions with 256 input interrupts."
  ],
  "138": [
    "This implies that all caller-save registers need to be saved, which is the general case.",
    "Depending on the function and the ABI, this might be fewer than all caller- save registers.",
    "The saved general-purpose registers are all caller-save registers in the respective ABI."
  ],
  "81": [
    "Interrupt handler routines that save the interrupt context in SW can only save the minimum state if the compiler is able to fully inline the handlers function body.",
    "Interrupt handler routines that use SW-based mechanisms to save and restore interrupt state can, if the compiler permits, fully inline the handler code and save some caller-save registers."
  ],
  "189": [
    "To also consider these cases, we measure the interrupt latency in the optimal case, i.e., only one caller-save register needs saving for SW-based interrupt handlers."
  ],
  "121": [
    "Interrupts are injected into the design at the interrupt controller inputs."
  ],
  "278": [
    "We evaluate both the EABI and regular integer ABI of RISC-V."
  ],
  "159": [
    "This allows for directly calling into C-code functions from interrupt handlers."
  ],
  "286": [
    "For our fastirq extension, this amount of state is always saved since the HW does not know a priori which caller-save registers need to be saved."
  ],
  "41": [
    "6, JUNE 2024 TABLE III COMPARISON OF THE MAIN TECHNIQUES FOR OPTIMIZING INTERRUPT CONTEXT AND TASK CONTEXT SAVERESTORE WITH NESTED AND NON-NESTED INTERRUPTS EMPLOYED BY INDUSTRY AND ACADEMIA IN THE EMBEDDED AND REAL-TIME APPLICATION DOMAINS The results are summarized in Fig.",
    "1) Interrupt Context SaveRestore Acceleration: Several designs automatically save and restore the interrupt context directly in HW.",
    "Albeit automatic interrupt context saverestore reduces SW housekeeping overhead before and after handling the interrupt routine, it only partially addresses the acceleration of the complete task context switch.",
    "While the presented solutions are effective in optimizing context, saverestore with HW and SW cooperation, they lack: 1) a cohesive approach to address both interrupt context and task context switch acceleration and 2) none of the existing RISC-V-based approaches can close the gap with well-established industry vendors.",
    "Interrupt context saverestore especially takes advantage of the former by deferring those operations to the HW."
  ],
  "8": [
    "xnxti and jalxnxti perform even worse (requiring 42 and 35 cycles, respectively) since they both insert additional instructions in the code path between the handler and interrupt event.",
    "xnxti and jalxnxti improve upon this situation by checking for pending interrupts and directly jumping to the respective handlers.",
    "While xnxti only returns a pointer to the address of the next handler and thus needs a small code sequence (load, jump, and retry loop), jalxnxti fuses these operations into one instruction resulting in saving nine cycles."
  ],
  "53": [
    "As a comparison, the Arm Cortex- M4 has an interrupt latency of 12 cycles given a single-cycle memory 24.",
    "The Arm Cortex-M4 is able to do the same task in six cycles assuming it has access to single-cycle memory 24."
  ],
  "86": [
    "In Fig.",
    "As shown in Fig."
  ],
  "163": [
    "6, we show the cost in clock cycles of such sequences."
  ],
  "200": [
    "For the baseline CLIC, it takes 68 or 50 cycles when using the integer or embedded ABI, respectively."
  ],
  "126": [
    "Note that this is independent of the ABI since no interrupt state is affected."
  ],
  "356": [
    "The emret mechanism of fastirq works similarly and costs eight clock cycles but is not restricted to non-vectored interrupts."
  ],
  "270": [
    "4) Context Switch Time: In Fig."
  ],
  "173": [
    "7, we show the context switch time in number of clock cycles between two FreeR- TOS dummy tasks when comparing the baseline CV32RT against CV32RTfastirq.",
    "Average context switch time in FreeRTOS for two tasks of various flavors of CV32RT."
  ],
  "263": [
    "All compile time options such as tracing, stack overflow signaling, and the more generic task selection mechanism were turned off to minimize the context switch code."
  ],
  "265": [
    "We left out configurations that do not have Fig."
  ],
  "387": [
    "As a comparison, we mention the generic Cortex-M4 core, assuming it has single-cycle access to memory."
  ],
  "164": [
    "Note that Arm Cortex-M only has 16 core registers."
  ],
  "148": [
    "fastirq allows us to skip ahead the saving of the general-purpose registers by triggering an SW interrupt as part of the save sequence.",
    "The SW interrupt will trigger the fastirq mechanism, which starts saving the general-purpose registers to memory."
  ],
  "340": [
    "By making sure not to use registers that are still being saved by the background-saving mechanism (as described in Section III-C4), we can save up to 31 cycles (19) for a context switch when using the I-extension, and 16 cycles (12) for the E-extension, respectively."
  ],
  "250": [
    "The FreeRTOS website 20 claims context switches as low as 96 cycles for a Cortex-M4 implementation.3 C. Implementation We synthesize CV32RT as part of the ControlPULP plat- form using Synopsys Design Compiler 2022.03, targeting GlobalFoundries 12LP FinFet technology at 500 MHz, TT cor- ner, and 25 C. One gate equivalent (GE) for this technology equals 0.121 m2."
  ],
  "111": [
    "3This can be seen as a lower bound as on some SoCs such as the STM32L476RG we observed higher latencies due to memory access stalls and other implementation choices in the memory subsystem."
  ],
  "309": [
    "The RISC-V E-Extension reduces the available general-purpose registers from 32 to 16, consequently lowering the context switch state that needs to be saved and restored."
  ],
  "68": [
    "RISC-V CLIC area breakdown at varying numbers of interrupt sources.",
    "8 reports the area breakdown of the CLIC implemented in the proposed with different interrupt sources."
  ],
  "230": [
    "Area overhead of CV32RT in the two main configurations."
  ],
  "389": [
    "The overhead of fastirq in CV32RTfastirq core results in a minimal 10 area increase concentrated around the ID stage."
  ],
  "271": [
    "The design has been synthesized in GF12LP technology (500 MHz, TT corner, 25 C, 0.8 V, super low VT standard cells)."
  ],
  "257": [
    "Area breakdown of CV32E40PRT ID stage with the proposed HW extensions."
  ],
  "156": [
    "8, for each scenario, more than half of the resources implement the configuration registers required to control the CLIC, whose size linearly increases with the number of input interrupts."
  ],
  "231": [
    "In particular, each interrupt is associated with one 32-bit register incurring an area overhead of about 176 GE."
  ],
  "220": [
    "The remaining area implements the gateway and binary tree arbitration logic at the core of the CLIC working principle, as discussed in Section III-B, and additional housekeeping control logic that scales linearly with the number of interrupt sources."
  ],
  "247": [
    "8 also shows that the fraction of the design occupied by the arbitration tree is kept constant when increas- ing the number of sources."
  ],
  "345": [
    "While it is apparent that this design incurs a larger area overhead compared to traditional RISC-V CLINT 14, the gain in flexibility enables a broader application scope with time-critical systems."
  ],
  "204": [
    "From Table II, CV32RTfastirq incurs a 10 overall area increase compared to baseline CLIC only."
  ],
  "123": [
    "While other HW blocks of the core remain primarily unaffected, the instruction decode (ID) stage incurs an area overhead of 21 compared to CV32RTCLIC."
  ],
  "198": [
    "The ID stage is the HW block where the addi- tional registers and the automatic stackingunstacking logic are localized."
  ],
  "256": [
    "A breakdown of the ID stage is shown in Fig."
  ],
  "242": [
    "We notice that the additional storage space for automatic context save and restore in HW increases the area of the RF by about 36 in the proposed implementation."
  ],
  "178": [
    "Similarly, the logic for managing the shadow registers accounts for an overhead of 40 on the baseline ID stage controller."
  ],
  "341": [
    "The HW overhead coming from the additional emret instruction dis- cussed in Section IV is negligible."
  ],
  "318": [
    "Nevertheless, the increased size of the ID stage trades off the benefits of: 1) a simplified programming model that moves several SW operations in HW and 2) significantly lowered interrupt latency than standard RISC-V while not impacting the critical path of the base core design."
  ],
  "142": [
    "Finally, time-critical systems shift design priorities from area efficiency to safety, security, and reliability."
  ],
  "366": [
    "V. RELATED WORK In this section, we describe the leading solutions to opti- mize handling asynchronous events in state-of-the-art (SOTA) embedded and real-time MCUs."
  ],
  "9": [
    "We first differentiate between existing PLICs and CLICs as introduced in Section II-C. Then, we focus on the latter and discuss solutions across various platforms in industry and academia, addressing: 1) interrupt context saverestore techniques; 2) context switch techniques; and 3) dedicated strategies to optimize redundant context restore with back-to-back interrupts.",
    "To address redundant context restore with back-to-back interrupts, we propose a modified version of the return Authorized licensed use limited to: California Polytechnic State University San Luis Obispo."
  ],
  "106": [
    "Table III summarizes the overview."
  ],
  "166": [
    "For the interrupt latency, we assume that the definition presented in Section II-B and explicitly provide references to different variants adopted by SOTA when needed in Table III."
  ],
  "109": [
    "Conversely, Arms generic interrupt controller (GIC) redistributes incoming asynchronous events as either non-critical (IRQ) or critical interrupts (fast IRQ, or FIQ)."
  ],
  "134": [
    "6, JUNE 2024 interrupt handler through a dedicated register bank, with up to eight registers employed to minimize context switching."
  ],
  "239": [
    "This allows the core to start fetching the jump address from the interrupt vector table simultaneously during context save and embed context restore within the return instruction."
  ],
  "275": [
    "A reference example in the field is the Arm Cortex-M series integrating the nested vectored inter- rupt controller (NVIC)."
  ],
  "167": [
    "It implements a state machine 32 that performs caller-save register stacking in the background."
  ],
  "287": [
    "Likewise, upon returning from the ISR, the HW encodes in the link register a value (EXCRETURN), which notifies the core to start unwinding the stack to return to normal program execution."
  ],
  "165": [
    "Analogously, in Infineon AURIX MCU- class TriCore familys interrupt control unit (ICU) 33, 34, 35, the context of the calling routine is saved in memory autonomously while restoring the context is embedded in the RET instruction and happens in parallel with the return jump 36."
  ],
  "292": [
    "From academia, Mao et al."
  ],
  "385": [
    "27 are the first to propose extensions for the RISC-V CLIC."
  ],
  "403": [
    "Though implemen- tation details are omitted, the interrupt handling is enhanced with automatic stacking in HW that benefits from the cores Harvard architecture and simultaneous data and instruction memory access."
  ],
  "35": [
    "2) Task Context SaveRestore Acceleration: Register bank- ing is a technique adopted by several architectures to swap a tasks context without pushingpopping register values to the stack at the cost of an additional area overhead in the design.",
    "A tasks context switch benefits from quickly transferring the suspended context to the ded- icated register bank while already restoring the next task to be executed."
  ],
  "181": [
    "As discussed above, in Arm designs, this is the case of HW register banking in PLICs (GIC)."
  ],
  "74": [
    "A similar approach is implemented in the Renesas M32C80 series 30."
  ],
  "177": [
    "A dual register bank allows quickly swapping the context without savingrestoring tofrom the stack, as the second register bank is reserved for high-speed interrupts."
  ],
  "172": [
    "The Aurix family instead implements an SW managed solution, featuring a specific organization of the context layout in the system memory based on context save area (CSA) chained in a linked list fashion 36."
  ],
  "137": [
    "A more complex approach based on the intuition that often the content of some register remains untouched after a context switch is introduced by Huang et al."
  ],
  "317": [
    "28, which adopts a valid-based mechanism in HW to block context switch on selected registers, reducing register movement by almost 50."
  ],
  "221": [
    "This feature is combined with semi-shadowing, similar to register banking but using the top (flip) and bottom (flop) halves of the RF as RF copies."
  ],
  "132": [
    "The latter approach is similar to leveraging RISC-Vs RV32E base instruction set by re-using the lower 16 architectural registers of the RF, as proposed in this work."
  ],
  "305": [
    "The evaluation in 28 lacks HW implementation and area overhead assessment but reduces con- text switching overhead by 24 on the DSPstone benchmark."
  ],
  "119": [
    "These approaches trade-off HW- and SW-induced latencies when handling asynchronous events, as depicted in Fig."
  ],
  "344": [
    "Gaitan et al."
  ],
  "141": [
    "26 propose a full HW solution based on a hard- ware scheduling engine (HSE) that directly attaches interrupts to running tasks without the need for a specialized inter- rupt controller."
  ],
  "196": [
    "While this approach allows lowering interrupt latency and task context switches dramatically, as reported in Table III, it lacks flexibility and its area overhead grows for a high number of tasks, as it requires replicating hardware resources per task."
  ],
  "70": [
    "Despite exceeding the scope of real-time execution, we mention that fast context switching is often required in architectures such as superscalar central processing units (CPUs) or to hide latency in graphic processing units (GPUs) 37, 38."
  ],
  "199": [
    "Besides highlighting the difference in memory footprint between such architectures (MB size RFs) and low-end embedded microcontrollers targeted in this work, such works typically adopt RF caching rather than register shadowing or banking for performance reasons, i.e., lower access latency to the RF and higher thread-level parallelism (TLP), respectively."
  ],
  "140": [
    "In the real-time application scenario of this work, such techniques may deteriorate the systems pre- dictability and thus are not considered."
  ],
  "216": [
    "RISC-V addresses this scenario by adding the xnxti CSR with SW-managed interrupt service loops as part of the CLIC specifications and finds early commercial examples with 31."
  ],
  "205": [
    "Among MSI solutions, RISC-V AIA without APLIC has a similar approach to mnxti with the xtopi CSR that reports the highest- priority, pending, and enabled interrupt for a specific privilege mode, allowing both late arrival and redundant context restore mechanisms."
  ],
  "201": [
    "This work proposes a combination of the background-saving with a register banking approach."
  ],
  "182": [
    "Furthermore, we improve task con- text switch times in FreeRTOS to 104 clock cycles using fastirq, which is 20 faster than an SW-only approach."
  ],
  "158": [
    "Some research directions involving the proposed extension that the authors consider for future work are analyzing fastirqs impact on timing channels or its integration with different RISC-V extensions."
  ],
  "222": [
    "REFERENCES 1 C. Rochange, S. Uhrig, and P. Sainrat, Time-Predictable Archi- tectures (FOCUSComputer Engineering Series)."
  ],
  "122": [
    "Hoboken, NJ, USA: Wiley, 2014."
  ],
  "217": [
    "Available: http:eu.wiley.comWileyCDA WileyTitleproductCd-1848215932.html 2 L. M. Pinho et al., High-Performance and Time-Predictable Embedded Computing."
  ],
  "154": [
    "Wharton, TX, USA: River, 2018."
  ],
  "97": [
    "3 F. Reghenzani, G. Massari, and W. Fornaciari, The real-time Linux kernel: A survey on PREEMPTRT, ACM Comput."
  ],
  "124": [
    "Surv., vol."
  ],
  "88": [
    "52, no."
  ],
  "73": [
    "1, pp.",
    "7, pp.",
    "1, pp.",
    "1, pp.",
    "10, pp.",
    "9, pp.",
    "9, pp.",
    "14, pp."
  ],
  "26": [
    "136, Feb. 2019, doi: 10.11453297714.",
    "16, doi: 10.1109IPCCC50635.2020.9391536.",
    "136, Jan. 2021, doi: 10.11453419973."
  ],
  "367": [
    "4 M. Liu, D. Liu, Y. Wang, M. Wang, and Z. Shao, On improving real-time interrupt latencies of hybrid operating systems with two-level hardware interrupts, IEEE Trans."
  ],
  "115": [
    "Comput., vol."
  ],
  "208": [
    "60, no."
  ],
  "174": [
    "978991, Jul."
  ],
  "384": [
    "2011."
  ],
  "342": [
    "5 P. Mantegazza, E. L. Dozio, and S. Papacharalambous, RTAI: Real time application interface, Linux J., vol."
  ],
  "113": [
    "2000, no.",
    "2000."
  ],
  "131": [
    "72, p. 10, Apr."
  ],
  "388": [
    "6 K. Ramamritham and J."
  ],
  "262": [
    "82, no."
  ],
  "288": [
    "5567, Jan. 1994."
  ],
  "153": [
    "(2005)."
  ],
  "169": [
    "Available: http:web.engr.oregonstate.edutraylorece473 pdfsminimizeinterruptresponsetime.pdf 8 J. Valvano, Introduction to Embedded Systems."
  ],
  "128": [
    "Scotts Valley, CA, USA: CreateSpace, Aug. 2016."
  ],
  "108": [
    "9 Y. Huang, L. Shi, J. Li, Q. Li, and C. J. Xue, WCET-aware re- scheduling register allocation for real-time embedded systems with clustered VLIW architecture, IEEE Trans."
  ],
  "69": [
    "Very Large Scale Integr.",
    "Very Large Scale Integr.",
    "Very Large Scale Integr."
  ],
  "45": [
    "(VLSI) Syst., vol.",
    "(VLSI) Syst., vol.",
    "Syst., vol.",
    "(VLSI) Syst., vol.",
    "Syst., vol."
  ],
  "54": [
    "22, no.",
    "25, no.",
    "23, no."
  ],
  "171": [
    "168180, Jan. 2014."
  ],
  "170": [
    "10 X. Zhou and P. Petrov, Rapid and low-cost context-switch through embedded processor customization for real-time and control applica- tions, in Proc."
  ],
  "110": [
    "43rd Annu."
  ],
  "95": [
    "Conf.",
    "Conf.",
    "Conf.",
    "Conf.",
    "Conf.",
    "Conf."
  ],
  "135": [
    "Design Autom.",
    "Design, Autom.",
    "Design, Autom."
  ],
  "316": [
    "(DAC)."
  ],
  "197": [
    "New York, NY, USA: Association for Computing Machinery, 2006, p. 352, doi: 10.11451146909.1147001."
  ],
  "179": [
    "11 I. Behnke, L. Pirl, L. Thamsen, R. Danicki, A. Polze, and O. Kao, Interrupting real-time IoT tasks: How bad can it be to connect your critical embedded system to the Internet?"
  ],
  "98": [
    "in Proc."
  ],
  "60": [
    "Commun."
  ],
  "84": [
    "(IPCCC), Nov. 2020, pp."
  ],
  "100": [
    "12 F. Rehm et al., The road towards predictable automotive high Performance platforms, in Proc."
  ],
  "25": [
    "Test Eur.",
    "Test Eur."
  ],
  "298": [
    "(DATE), Feb. 2021, pp.",
    "(DATE), Feb. 2021, pp."
  ],
  "118": [
    "19151924."
  ],
  "21": [
    "13 K. Asanovic and D. A. Patterson, Instruction sets should be free: The case for RISC-V, Dept.",
    "Available: http:www2.eecs.berkeley.eduPubsTechRpts2014EECS- 2014-146.html 14 A. Waterman, Y. Lee, R. Avizienis, D. A. Patterson, and K. Asanovic, The RISC-V instruction set manual volume II: Privileged architec- ture version 1.9, Dept."
  ],
  "180": [
    "EECS, Univ.",
    "EECS, Univ."
  ],
  "34": [
    "California, Berkeley, CA, USA, Tech.",
    "California, Berkeley, CA, USA, Tech."
  ],
  "176": [
    "Rep. UCBEECS-2014-146, Aug. 2014.",
    "Rep. UCBEECS-2016-129, Jul."
  ],
  "191": [
    "2016."
  ],
  "57": [
    "Accessed: Jul.",
    "Accessed: Jun."
  ],
  "120": [
    "18, 2023.",
    "2, 2023.",
    "(2023).",
    "(2023).",
    "(2023)."
  ],
  "234": [
    "Available: https:github.comriscvriscv-fast-interruptblobmasterclic."
  ],
  "145": [
    "adoc 16 M. Gautschi et al., Near-threshold RISC-V core with DSP extensions for scalable IoT endpoint devices, IEEE Trans."
  ],
  "66": [
    "27002713, Oct. 2017."
  ],
  "99": [
    "17 D. Schiavone."
  ],
  "304": [
    "OpenHW Group CV32E40P User Manual."
  ],
  "103": [
    "OpenHW Group."
  ],
  "210": [
    "Available: https:cv32e40p."
  ],
  "4": [
    "readthedocs.ioenlatest 18 Nuclei System Technology.",
    "39 Nuclei System Technology Co. Ltd. ECLIC Unit Introduction."
  ],
  "78": [
    "(2021).",
    "(2020).",
    "(2020)."
  ],
  "101": [
    "Nuclei ISA Spec."
  ],
  "183": [
    "Available: https:doc.nucleisys.comnucleispecisaintroduction.html 19 A. Ottaviano et al., ControlPULP: A RISC-V on-chip parallel power controller for many-core HPC processors with FPGA-based hardware- in-the-loop power and thermal emulation, Int."
  ],
  "390": [
    "Parallel Program., Feb. 2024, doi: 10.1007s10766-024-00761-4."
  ],
  "55": [
    "20 R. Barry."
  ],
  "77": [
    "FreeRTOS: Real-Time Operating System for Microcontrollers."
  ],
  "91": [
    "Real Time Engineers Ltd. Online."
  ],
  "261": [
    "Available: https:www.freertos.orgindex.html 21 C.-M. Lin, Nested interrupt analysis of low cost and high performance embedded systems using GSPN framework, IEICE Trans."
  ],
  "168": [
    "25092519, 2010."
  ],
  "127": [
    "22 RISC-V Internationa."
  ],
  "259": [
    "Available: https:github.comriscvriscv- plic-specblobmasterriscv-plic-1.0.0.pdf 23 J. Yiu, The Definitive Guide to ARM Cortex-M3 Cortex-M4 Processors, 3rd ed."
  ],
  "353": [
    "Boston, MA, USA: Newnes, 2013."
  ],
  "62": [
    "24 ARM."
  ],
  "206": [
    "Cortex-M4 Tech."
  ],
  "107": [
    "Reference Manual."
  ],
  "147": [
    "Available: https:developer.arm.comdocumentation1001660001 25 J. Yiu."
  ],
  "75": [
    "(2012).",
    "(2014).",
    "(2012)."
  ],
  "43": [
    "A Beginners Guide Interrupt LatencyInterrupt Latency Arm Cortex-M Processors.",
    "Available: https:community.arm.comarm-community-blogsbarchitectures-and -processors-blogpostsbeginner-guide-on-interrupt-latency-and- interrupt-latency-of-the-arm-cortex-m-processors?pifragment-227142 26 V. G. Gaitan, N. C. Gaitan, and I. Ungurean, CPU architecture based on a hardware scheduler and independent pipeline registers, IEEE Trans."
  ],
  "190": [
    "16611674, Sep. 2015."
  ],
  "280": [
    "6th Int."
  ],
  "347": [
    "Circuits Microsystems (ICICM), Oct. 2021, pp."
  ],
  "65": [
    "109113."
  ],
  "79": [
    "28 C.-W. Huang, K.-Y."
  ],
  "143": [
    "Hsieh, J.-J."
  ],
  "61": [
    "Li, and J. K. Lee, Support of paged register files for improving context switching on embedded processors, in Proc."
  ],
  "104": [
    "Eng., 2009, pp."
  ],
  "194": [
    "352357."
  ],
  "93": [
    "29 R. Balas and L. Benini, RISC-V for real-time MCUsSoftware opti- mization and microarchitectural gap analysis, in Proc."
  ],
  "192": [
    "874877."
  ],
  "51": [
    "30 Renesas."
  ],
  "186": [
    "Hardware ManualRENESAS MCU M16C."
  ],
  "48": [
    "Available: https:www.renesas.comusendocumentmahm32c87- group-m32c87-m32c87a-m32c87b-hardware-manual 31 SiFive Inc. (2021)."
  ],
  "260": [
    "SiFive E21 Core Complex Manual."
  ],
  "139": [
    "Available: https:sifive.cdn.prismic.iosifive7c22c2ec-8af4-4b6c-a5fe- 9327d91e7808e21corecomplexmanual21G1.pdf 32 STMicroelectronics."
  ],
  "52": [
    "Available: https:www.st.comcontentcccresourcetrainingtechnicalproducttrain inggroup16135d207346f4e83STM32L5-System-NestedVectore dInterruptControlNVICfilesSTM32L5-System-NestedVectored InterruptControlNVIC.pdfjcrcontenttranslationsen.STM32L5- System-NestedVectoredInterruptControlNVIC.pdf 33 Infineon Technologies AG."
  ],
  "102": [
    "A Fast Powertrain Microcontroller."
  ],
  "19": [
    "Available: https:old.hotchips.orgwp-contentuploads hcarchiveshc163Tue6HC16Sess7Pres1bw.pdf 34 Infineon Technologies AG.",
    "Available: https:hitex.co.ukfileadminuk- filesdownloadsShieldBuddytc27xDumv2.2.pdf 35 Infineon Technologies AG."
  ],
  "241": [
    "TC27x D-Step, 32-Bit Single-Chip Microcontroller."
  ],
  "117": [
    "TriCore V1.6, Core Archi- tecture."
  ],
  "227": [
    "Available: https:www.infineon.comdgdltc16 architecturevol1.pdf?fileIddb3a3043372d5cc801373b0f374d5d67 36 Infineon Technologies AG, Task context switching RTOS, U.S. Patent 7 434 222 B2, Oct. 2008."
  ],
  "32": [
    "6, JUNE 2024 37 H. Zeng and K. Ghose, Register file caching for energy efficiency, in ISLPED Proc."
  ],
  "151": [
    "Low Power Electron."
  ],
  "63": [
    "Design, Oct. 2006, pp."
  ],
  "152": [
    "244249."
  ],
  "30": [
    "38 M. Sadrosadati et al., Highly concurrent latency-tolerant register files for GPUs, ACM Trans."
  ],
  "82": [
    "37, nos."
  ],
  "83": [
    "Accessed: Aug. 4, 2023."
  ],
  "272": [
    "Available: https:doc.nucleisys.comnuclei specisaeclic.html Robert Balas (Graduate Student Member, IEEE) received the B.Sc."
  ],
  "59": [
    "degrees in electrical engineering and information technology from ETH Zrich, Zrich, Switzerland, in 2015 and 2017, respectively, where he is currently working toward the Ph.D. degree at the Digital Circuits and Systems Group of Prof. Benini.",
    "He is currently working toward the Ph.D. degree at the Digital Circuits and Systems Group of Prof. Benini, ETH Zrich, Zrich, Switzerland.",
    "He currently holds the Chair of the Digital Circuits and Systems Group, ETH Zrich (ETHZ), Zrich, Switzerland, and is also a Full Professor at the Universit di Bologna, Bologna, Italy."
  ],
  "116": [
    "His research interests include real-time computing, compilers, and operating systems.",
    "His research interests include real-time computing, power management of HPC processors, and energy-efficient processor archi- tecture."
  ],
  "193": [
    "Alessandro Ottaviano (Graduate Student Member, IEEE) received the B.Sc."
  ],
  "71": [
    "degree in physical engi- neering from the Politecnico di Turino, Turin, Italy, in 2018, and the joint M.Sc."
  ],
  "130": [
    "degree in electrical engineering from the Politecnico di Turino, Grenoble INP-Phelma, Grenoble, France, and EPFL Lausanne, Lausanne, Switzerland, in 2020."
  ],
  "157": [
    "Luca Benini (Fellow, IEEE) received the Ph.D. degree in electrical engineering from Stanford Uni- versity, Stanford, CA, USA, in 1997."
  ],
  "94": [
    "Dr. Benini is a fellow of the ACM and a member of the Academia Europaea."
  ],
  "274": [
    "He was a recipient of the 2023 IEEE CS E.J."
  ],
  "228": [
    "McCluskey Award."
  ]
}