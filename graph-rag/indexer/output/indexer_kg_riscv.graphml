<?xml version='1.0' encoding='utf-8'?>
<graphml xmlns="http://graphml.graphdrawing.org/xmlns" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://graphml.graphdrawing.org/xmlns http://graphml.graphdrawing.org/xmlns/1.0/graphml.xsd"><key id="d0" for="edge" attr.name="relationship" attr.type="string"/>
<graph edgedefault="directed"><node id="Processors"/>
<node id="the open RISC-V instruction set architecture (ISA)"/>
<node id="Processors using the open RISC-V instruction set architecture (ISA)"/>
<node id="increasing adoption in the embedded world"/>
<node id="Robert Balas"/>
<node id="graduate student member, IEEE"/>
<node id="Alessandro Ottaviano"/>
<node id="Luca Benini"/>
<node id="fellow, IEEE"/>
<node id="We"/>
<node id="a CLIC for the CV32E40P"/>
<node id="CV32E40P"/>
<node id="an industrially supported open-source 32-bit microcontroller unit (MCU)-class RISC-V core"/>
<node id="CV32E40P with FastIRQ"/>
<node id="FastIRQ"/>
<node id="a custom extension"/>
<node id="interrupt latency as low as six cycles"/>
<node id="CV32RT"/>
<node id="a 32-bit RISC-V core"/>
<node id="the interrupt handling capabilities of CV32E40P"/>
<node id="an industrially supported open-source core"/>
<node id="best-in-class interrupt latency"/>
<node id="fast context switching"/>
<node id="commercial off-the-shelf (COTS) processor vendors"/>
<node id="RISC-V architectures in time-critical systems"/>
<node id="the CV32E40P interrupt controller with an implementation of the RISC-V CLIC specification"/>
<node id="The RISC-V CLIC specification"/>
<node id="the core with key features"/>
<node id="Key features"/>
<node id="prioritization by level and priority"/>
<node id="selective hardware vectoring (SHV)"/>
<node id="non-nested interrupt optimization tail-chaining through the XNXTI 15 control and status register (CSR)"/>
<node id="XNXTI 15 control and status register (CSR)"/>
<node id="directly a RISC-V standard extension"/>
<node id="a brief overview of the full-system platform used to design and implement the proposed interrupt extension in Section II-A"/>
<node id="the relevant target metrics in Section II-B3"/>
<node id="the current status of interrupt handling in RISC-V in Section II-C"/>
<node id="RISC-V system platform"/>
<node id="the CV32E40P core"/>
<node id="CV32E40P core"/>
<node id="CV32"/>
<node id="an open-source, industry-grade, 32-bit, in-order, four-stage RISC-V core"/>
<node id="the basis for implementing our extensions"/>
<node id="CV32 core"/>
<node id="the baseline"/>
<node id="native CLINT interrupt controller"/>
<node id="CLIC"/>
<node id="CV32RTCLIC"/>
<node id="FASTIRQ"/>
<node id="core microarchitecture"/>
<node id="this work"/>
<node id="CV32RTFASTIRQ"/>
<node id="CLIC interrupt controller"/>
<node id="draft specification"/>
<node id="RISC-V privileged specification"/>
<node id="Our proposed FastIRQ extension"/>
<node id="weaknesses of various flavors of RISC-V core-specific interrupt controllers"/>
<node id="the CLIC base capabilities"/>
<node id="a mechanism to lower interrupt latency"/>
<node id="HW vectored interrupts"/>
<node id="skipping of redundant context restore operations"/>
<node id="FASTIRQ, a fast interrupt extension for RISC-V embedded systems"/>
<node id="the extension"/>
<node id="a 32-bit, in-order, single-issue core"/>
<node id="the RISC-V CLIC fast interrupt controller"/>
<node id="27 B. MAO, N. TAN, T. CHONG, AND L. LI"/>
<node id="A CLIC EXTENSION BASED FAST INTERRUPT SYSTEM FOR EMBEDDED RISC-V PROCESSORS"/>
<node id="PROC."/>
<node id="Many embedded use cases"/>
<node id="real-time constraints"/>
<node id="flexible, predictable, and fast reactive handling of incoming events"/>
<node id="RISC-V processors"/>
<node id="this area"/>
<node id="more mature proprietary architectures"/>
<node id="ARM Cortex-M and TriCore"/>
<node id="tuned for years"/>
<node id="THE DEFAULT INTERRUPT CONTROLLER"/>
<node id="RISC-V"/>
<node id="THE CORE LOCAL INTERRUPTOR (CLINT)"/>
<node id="configurability in prioritization and preemption of interrupts"/>
<node id="The RISC-V community"/>
<node id="an extension to the privileged specifications 14"/>
<node id="The extension to the privileged specifications 14"/>
<node id="the RISC-V Core Local Interrupt Controller (CLIC) 15"/>
<node id="The RISC-V Core Local Interrupt Controller (CLIC) 15"/>
<node id="currently under ratification by the community"/>
<node id="real-time scenarios"/>
<node id="CLICS"/>
<node id="local to each hardware thread (HART)"/>
<node id="PLICS"/>
<node id="platform level interrupt controllers"/>
<node id="centralized interrupt controllers"/>
<node id="managing multiple HARTs"/>
<node id="Platform-level interrupt controllers"/>
<node id="RISC-V PLIC"/>
<node id="Advanced PLIC (APLIC)"/>
<node id="RISC-V Incoming Message Signaled Interrupt Controller (IMSIC)"/>
<node id="RISC-V PLIC and Advanced PLIC (APLIC)"/>
<node id="wire-based interrupt communication"/>
<node id="message-signaled interrupt communication"/>
<node id="distribute time-critical interrupts to the running harts"/>
<node id="B. CORE-LOCAL INTERRUPT CONTROLLERS (CLICS)"/>
<node id="providing fast interrupt-handling capabilities in real-time embedded application domains"/>
<node id="WE"/>
<node id="CV32RT OUR ENHANCED CORE"/>
<node id="the first fully open-source RV32 core with competitive interrupt-handling features compared to the ARM Cortex-M series and TriCore"/>
<node id="CV32RT within an open-source system on chip (SoC)"/>
<node id="CV32RT interrupt handling capabilities"/>
<node id="The extension"/>
<node id="negligible area overhead in a modern technology node"/>
<node id="performance benefits"/>
<node id="various CV32RT versions"/>
<node id="interrupt latency and context switch times"/>
<node id="these additions"/>
<node id="overhead in terms of area and timing"/>
<node id="THE PROPOSED EXTENSIONS"/>
<node id="TASK CONTEXT SWITCHING IN REAL-TIME OPERATING SYSTEMS (RTOSS)"/>
<node id="INDEX TERMS"/>
<node id="CONTEXT SWITCHING"/>
<node id="EMBEDDED"/>
<node id="INTERRUPT LATENCY"/>
<node id="MICROCONTROLLER UNIT (MCU)"/>
<node id="REAL-TIME"/>
<node id="Several markets"/>
<node id="real-time AN SW-based solution"/>
<node id="The automotive industry"/>
<node id="hundreds of electronic control units (ECUs)"/>
<node id="Electronic control units (ECUs)"/>
<node id="real-time applications"/>
<node id="Real-time applications"/>
<node id="electronic engine control"/>
<node id="gearbox control"/>
<node id="cruise control"/>
<node id="anti-lock brake systems"/>
<node id="many other tasks"/>
<node id="General-purpose operating systems (GPOSS)"/>
<node id="average throughput"/>
<node id="DATE OF PUBLICATION"/>
<node id="21 MARCH 2024"/>
<node id="DATE OF CURRENT VERSION"/>
<node id="23 MAY 2024"/>
<node id="THIS WORK"/>
<node id="THE HORIZON KEY DIGITAL TECHNOLOGIES JOINT UNDERTAKING (KDT JU) PROGRAMME"/>
<node id="THE TRISTAN PROJECT"/>
<node id="101095947"/>
<node id="Integrated Systems Laboratory (IIS), ETH Zurich, 8092 Zurich, Switzerland"/>
<node id="balas@iis.ee.ethz.ch"/>
<node id="aottaviano@iis.ee.ethz.ch"/>
<node id="the Integrated Systems Laboratory (IIS), ETH Zurich, Zurich, Switzerland"/>
<node id="the Department of Electrical, Electronic and Information Engineering (DEI), University of Bologna, 40126 Bologna, Italy"/>
<node id="color versions of one or more figures in this article"/>
<node id="https://doi.org/10.1109/TVLSI.2024.3377130"/>
<node id="DIGITAL OBJECT IDENTIFIER"/>
<node id="10.1109TVLSI.2024.3377130"/>
<node id="The development of Linux"/>
<node id="average performance"/>
<node id="Linux"/>
<node id="a popular open-source GPOS kernel"/>
<node id="Extensions and modifications"/>
<node id="improving determinism and latencies of critical operations in Linux"/>
<node id="proposed and implemented"/>
<node id="strict bounds on maximum latencies of operations"/>
<node id="industry-grade maturity to be employed in hard real-time scenarios"/>
<node id="REAL-TIME OPERATING SYSTEMS (RTOSS) KERNELS"/>
<node id="special-purpose operating systems (OSS)"/>
<node id="real-time guarantees"/>
<node id="task scheduling according to a given expected completion deadline"/>
<node id="deterministic latencies of various operations"/>
<node id="A. STANKOVIC"/>
<node id="SCHEDULING ALGORITHMS AND OPERATING SYSTEMS SUPPORT FOR REAL-TIME SYSTEMS"/>
<node id="The RTOS scheduler"/>
<node id="a significant overhead"/>
<node id="The significant overhead"/>
<node id="the combined effect of both the context switches required to handle the transition from a foreground to a background task and the amount of time elapsed from the source event that causes the preemption and the first instruction of the awakened task"/>
<node id="The amount of time elapsed from the source event that causes the preemption and the first instruction of the awakened task"/>
<node id="interrupt latency"/>
<node id="the worst case execution time (WCET)"/>
<node id="The cost of saving and restoring the task state during a context switch"/>
<node id="a significant concern"/>
<node id="relatively high"/>
<node id="LONG CONTEXT SWITCH TIMES"/>
<node id="AVAILABLE TASK UTILIZATION"/>
<node id="THE MINIMUM VIABLE SWITCHING GRANULARITY"/>
<node id="process state"/>
<node id="context switch"/>
<node id="program counter"/>
<node id="register files (RFs)"/>
<node id="status registers"/>
<node id="address space mapping"/>
<node id="A significant number of memory access operations"/>
<node id="to store the state of the preempted task"/>
<node id="to restore the state of the new task to be executed"/>
<node id="a switch into an interrupt context from normal program execution"/>
<node id="an asynchronous event is triggered from an IO peripheral device"/>
<node id="high overhead generated by the receiving of packets"/>
<node id="continuous floods"/>
<node id="short transmission bursts"/>
<node id="50 task lateness"/>
<node id="task lateness"/>
<node id="the additional time a task takes to finish than its deadline allows"/>
<node id="iterations from the critical network load increase per packet per second"/>
<node id="HW-induced interrupt latency"/>
<node id="only one part of the problem"/>
<node id="SW-induced interrupt latency"/>
<node id="part of the problem"/>
<node id="SW-dependent contributions"/>
<node id="HW-dependent contributions"/>
<node id="Personal use"/>
<node id="permitted"/>
<node id="Republication redistribution"/>
<node id="IEEE permission"/>
<node id="AUTHORIZED LICENSED USE"/>
<node id="CALIFORNIA POLYTECHNIC STATE UNIVERSITY SAN LUIS OBISPO"/>
<node id="THE CLIC DESIGN"/>
<node id="interrupt state"/>
<node id="this"/>
<node id="The latter"/>
<node id="the execution time of the authorized licensed use limited to California Polytechnic State University San Luis Obispo"/>
<node id="document"/>
<node id="May 28, 2025 at 17:50:39 UTC"/>
<node id="IEEE Xplore"/>
<node id="fast interrupt and context switching"/>
<node id="the GPOSRTOS scheduler and the user code"/>
<node id="the capability of the system to provide timely responses to asynchronous events"/>
<node id="Table I"/>
<node id="nested interrupt preemption scheme according to RISC-V CLIC"/>
<node id="interrupt latency in the non-nested interrupt case"/>
<node id="interrupt latency in the nested interrupt case"/>
<node id="bank switching and the nested interrupt case with an automatic context-saving mechanism in the background"/>
<node id="FAST INTERRUPT EXTENSION"/>
<node id="automatic hardware context saving and bank switching"/>
<node id="block diagram"/>
<node id="pointer"/>
<node id="appropriately before triggering an SW interrupt"/>
<node id="SW interrupt"/>
<node id="write to CLICS memory map"/>
<node id="fast interrupt and context switching 1043 instruction in machine mode (i.e., EMRET)"/>
<node id="EMRET"/>
<node id="skip redundant context saving and restoring sequences"/>
<node id="directly jumping to the next available interrupt handler"/>
<node id="Low interrupt latency and context switch time"/>
<node id="crucial metrics"/>
<node id="Crucial metrics"/>
<node id="a wide range of platforms"/>
<node id="Platforms"/>
<node id="commodity MCU-class embedded systems to more advanced and complex application-class mixed criticality systems (MCSS)"/>
<node id="Timesafety-critical and non-critical applications"/>
<node id="different isolated partitions of the same HW platform"/>
<node id="response and context switch time minimization"/>
<node id="a challenge to be tackled at the HWSW interface"/>
<node id="SW programming techniques and HW interrupt controller architectures"/>
<node id="to ensure minimal response time"/>
<node id="commercial vendors and IP providers"/>
<node id="such features as in-house solutions"/>
<node id="often proprietary"/>
<node id="tightly coupled with the vendors instruction set architecture (ISA), target HW family, and associated SW stack"/>
<node id="RISC-V ecosystem"/>
<node id="a modular, free, and open-source ISA"/>
<node id="the de facto lingua franca of computing"/>
<node id="RISC-V support for fast interrupt and context switch handling"/>
<node id="incumbent proprietary architectures"/>
<node id="flexible interrupt prioritization"/>
<node id="preemption mechanisms"/>
<node id="low interrupt latency"/>
<node id="interrupt handlers"/>
<node id="nesting"/>
<node id="calling of C-functions within it"/>
<node id="calling of C-functions within interrupt handlers"/>
<node id="saving and restoring state following the C-ABI"/>
<node id="various flavors of RISC-V core-specific interrupt controllers"/>
<node id="our design"/>
<node id="interrupt latencies of six clock cycles"/>
<node id="efficient back-to-back interrupt handling in 12 cycles"/>
<node id="interrupt latencies of six clock cycles and efficient back-to-back interrupt handling in 12 cycles"/>
<node id="the fastest available approaches currently implemented in the RISC-V landscape"/>
<node id="fully open-source"/>
<node id="competitive against closed-source and proprietary commercial solutions"/>
<node id="the implementation under a permissive open-source license"/>
<node id="a fast interrupt extension (FASTIRQ)"/>
<node id="both nested and non-nested interrupt case scenarios"/>
<node id="hiding the latency through memory banks and a background-saving mechanism"/>
<node id="CLINT"/>
<node id="about 33 cycles interrupt latency"/>
<node id="FASTIRQ extension"/>
<node id="six cycles"/>
<node id="THE SAME MECHANISM"/>
<node id="one to accelerate context switching through HWSW cooperation"/>
<node id="Early MRET (EMRET)"/>
<node id="a novel instruction"/>
<node id="tail-chaining"/>
<node id="the baseline strategy proposed in the CLIC standard (i.e., XNXTI)"/>
<node id="its enhancement from 18 (JALXNXTI)"/>
<node id="CV32RT with leading COTS systems in both nested and non-nested interrupt scenarios"/>
<node id="THE PROPOSED SOLUTION"/>
<node id="RISC-V AS A COMPETITIVE CANDIDATE FOR BUILDING THE NEXT GENERATION OF TIME-CRITICAL SYSTEMS"/>
<node id="THIS CORE"/>
<node id="CONTROLPULP 19"/>
<node id="a SoC specialized in running real-time workloads"/>
<node id="The manager core"/>
<node id="scheduling tasks"/>
<node id="communicating with the peripherals"/>
<node id="offloading tasks to the accelerator subsystem"/>
<node id="being responsive to asynchronous external events"/>
<node id="asynchronous external events"/>
<node id="interrupts"/>
<node id="CONTROLPULP"/>
<node id="a set of scratchpad memories (SPMs)"/>
<node id="scratchpad memories (SPMs)"/>
<node id="single-cycle access time from the CV32 manager core"/>
<node id="this design choice"/>
<node id="deterministic memory access latency for both data load, store, and instruction fetch"/>
<node id="the worst case latency when handling unpredictable events"/>
<node id="Applications"/>
<node id="FreeRTOS 20"/>
<node id="an open-source, priority-based preemptive RTOS"/>
<node id="the manager core"/>
<node id="Tasks"/>
<node id="interrupt sources"/>
<node id="a level change of the interrupt line"/>
<node id="an edge-triggered interrupt"/>
<node id="the logic level itself"/>
<node id="a level-triggered interrupt"/>
<node id="nested interrupts"/>
<node id="preemption of a low-level interrupt by a high-level interrupt"/>
<node id="Transition"/>
<node id="different interrupt levels"/>
<node id="the latter"/>
<node id="the receiving side of the interrupt to clear the source often through accessing appropriate HW registers"/>
<node id="the former"/>
<node id="unidirectional notification without confirmation"/>
<node id="Interrupts"/>
<node id="asynchronous events"/>
<node id="the normal program order execution"/>
<node id="a switch to a different context to handle the event"/>
<node id="A processor"/>
<node id="vectored interrupts"/>
<node id="Each interrupt"/>
<node id="a specific interrupt service routine (ISR)"/>
<node id="Trapping to a specific ISR"/>
<node id="an interrupt vector table"/>
<node id="Vectored interrupts"/>
<node id="fast interrupt response"/>
<node id="increased code size"/>
<node id="interrupt vectoring"/>
<node id="to improve interrupt latencies"/>
<node id="NON-VECTORED OR DIRECT INTERRUPTS"/>
<node id="a SHARED ISR"/>
<node id="THE LATTER APPROACH"/>
<node id="code size for a slower interrupt response"/>
<node id="the overhead of resolving the interruption cause and jumping to the correct ISR"/>
<node id="explicit instructions"/>
<node id="the interrupt table"/>
<node id="much more compact"/>
<node id="multiple sources"/>
<node id="interrupt latency in a system"/>
<node id="underlying HW"/>
<node id="scheduler or OS"/>
<node id="application running on top"/>
<node id="we"/>
<node id="minimizing the latency imposed by the HW"/>
<node id="its HW-contributed part"/>
<node id="THE LATTER"/>
<node id="restoring the interrupt context and the regular interrupt latency"/>
<node id="Interrupt latency"/>
<node id="the time it takes from an interrupt edge arriving at the HW, usually the interrupt controller, to the execution of the first instruction of the corresponding interrupt handler routine"/>
<node id="the number of cycles it takes for an interrupt to arrive at the interrupt controller input to the first instruction of an interrupt handler that allows the calling of a C-function"/>
<node id="what exactly constitutes the first instruction of the interrupt handler"/>
<node id="each HW configuration"/>
<node id="a handwritten optimized interrupt handler"/>
<node id="handwritten optimized interrupt handler"/>
<node id="all required general-purpose and machine-specific registers for nesting interrupts"/>
<node id="the first instruction"/>
<node id="the one after all necessary interrupt context has been saved on the stack to be able to call a function"/>
<node id="interrupt handler and interrupt context saving code"/>
<node id="true"/>
<node id="some of the context saving code"/>
<node id="redundant"/>
<node id="THE ACTIVE INTERRUPT HANDLERS CONTEXT"/>
<node id="INTERRUPT RETURN"/>
<node id="THE NEXT PENDING INTERRUPT FIRING"/>
<node id="restoring the pre-interrupt context"/>
<node id="SW for the nested interrupt case"/>
<node id="context switching time"/>
<node id="the responsiveness of the architecture in swapping from one execution context to another"/>
<node id="Preemption"/>
<node id="an event such as an interrupt request"/>
<node id="An interrupt request"/>
<node id="a current task"/>
<node id="The purpose of preemption"/>
<node id="resuming its execution later"/>
<node id="The simplest case for preemption"/>
<node id="non-nested interrupt handlers"/>
<node id="the execution of an ISR"/>
<node id="A more complex case for preemption"/>
<node id="nested interrupt handlers"/>
<node id="Nested interrupt handlers"/>
<node id="the case of multiple interrupts at a time"/>
<node id="THIS SITUATION"/>
<node id="PREEMPTION"/>
<node id="PENDING INTERRUPTS TO BE SERVICED IN SEQUENCE ACCORDING TO INCREASING PRIORITY"/>
<node id="LEVELPRIORITY arbitration"/>
<node id="SW-driven"/>
<node id="SW-driven LEVELPRIORITY arbitration"/>
<node id="priority simplestandard interrupt handlers"/>
<node id="LEVELPRIORITY arbitration logic"/>
<node id="interrupt controller"/>
<node id="highest LEVELPRIORITY interrupt"/>
<node id="pending but disabled"/>
<node id="core"/>
<node id="A levelpriority interrupt scheme"/>
<node id="additional masking of incoming interrupts of equal or lower levelpriority than the executing ISR"/>
<node id="additional masking of incoming interrupts sometimes larger than a configurable levelpriority threshold"/>
<node id="either software or hardware driven"/>
<node id="this scenario"/>
<node id="real-time and complex embedded systems"/>
<node id="sequentially"/>
<node id="A HIGH-PRIORITY INTERRUPT"/>
<node id="A LOWER-PRIORITY INTERRUPT TO FINISH"/>
<node id="globally within the scope of an executing ISR"/>
<node id="interrupt handler"/>
<node id="global interrupts are disabled"/>
<node id="ISR"/>
<node id="carefully designed"/>
<node id="they are reentrant"/>
<node id="THE NESTING"/>
<node id="higher priority interrupts to preempt a current lower priority ISR executing"/>
<node id="Back-to-back interrupts"/>
<node id="interrupts that need to be served sequentially"/>
<node id="whenever there are multiple interrupts pending"/>
<node id="The transition from one interrupt to the next one"/>
<node id="a redundant sequence of context restores and context saves"/>
<node id="Redundant context restore sequences"/>
<node id="interrupt latency on higher interrupt loads"/>
<node id="Redundant context restore with non-nested or nested horizontal interrupts"/>
<node id="unwanted additional interrupt latency"/>
<node id="REDUNDANT CONTEXT RESTORE"/>
<node id="TWO NON-PREEMPTIVE INTERRUPTS"/>
<node id="TWO INTERRUPTS WITH SAME LEVEL BUT DIFFERENT PRIORITIES"/>
<node id="TAIL-CHAINING"/>
<node id="OPTIMIZE IT"/>
<node id="interrupt context restore and store sequence between back-to-back interrupts"/>
<node id="REDUNDANT CONTEXT RESTORING SEQUENCES"/>
<node id="FULL INTERRUPT EXIT CODE SEQUENCE"/>
<node id="Redundant context restore with non-nested interrupts"/>
<node id="chaining two back-to-back interrupts and bypassing the superfluous restore-save operation"/>
<node id="SECTION III-D"/>
<node id="the optimizations implemented in this work to address this scenario"/>
<node id="The privileged specification 14"/>
<node id="a simple interrupt scheme with a set of timer and inter-processor interrupts"/>
<node id="The simple interrupt scheme"/>
<node id="the RISC-V ecosystem"/>
<node id="pending and enabled interrupts"/>
<node id="according to a threshold value representing an interrupt level"/>
<node id="threshold value representing an interrupt level"/>
<node id="a CSR"/>
<node id="32-bit cores"/>
<node id="a fixed priority interrupt scheme"/>
<node id="fixed priority interrupt scheme"/>
<node id="16 predefined or reserved interrupts"/>
<node id="16 implementation-defined interrupts"/>
<node id="16 predefined or reserved interrupts and 16 implementation-defined interrupts"/>
<node id="optionally vectored"/>
<node id="THE CLINT ITSELF"/>
<node id="prioritization of interrupts based on privilege mode"/>
<node id="CLINT-MODE"/>
<node id="inflexible interrupt scheme"/>
<node id="inflexible interrupt scheme of the CLINT-MODE"/>
<node id="much more work to be done in managing interrupt mask (SOMEIRQMASK) and other machine state"/>
<node id="interrupts with lower priority than the current interrupt running"/>
<node id="in CLINT-mode when global interrupts are re-enabled"/>
<node id="the Clint"/>
<node id="fine-grained control over interrupt prioritization"/>
<node id="PLIC 22"/>
<node id="the CLINT"/>
<node id="the number of custom interrupts"/>
<node id="an active interrupt handler"/>
<node id="IRQ2"/>
<node id="IRQ1"/>
<node id="pending"/>
<node id="interrupts that are assigned a higher level"/>
<node id="lower-level interrupts"/>
<node id="A single hart"/>
<node id="multiple targets"/>
<node id="each interrupt"/>
<node id="a priority"/>
<node id="each target"/>
<node id="a threshold"/>
<node id="below the threshold"/>
<node id="INTERRUPT SELECTION"/>
<node id="the CLIC in HW"/>
<node id="the highest level, highest priority pending interrupt to the cores interface"/>
<node id="Interrupt priority"/>
<node id="a tie-breaker for the case of multiple interrupts pending with the same level"/>
<node id="enabled interrupts and their level and priority information"/>
<node id="prioritization logic"/>
<node id="a binary arbitration tree"/>
<node id="the highest-level interrupt"/>
<node id="a level"/>
<node id="The priorities"/>
<node id="concurrent pending interrupts to be taken in the order preferred by the programmer"/>
<node id="The level information"/>
<node id="pre-emption of same-privilege level interrupts"/>
<node id="same-privilege level interrupts"/>
<node id="horizontal interrupts"/>
<node id="THIS SCHEME"/>
<node id="interrupts to be divided according to their priorities on the PLIC-level"/>
<node id="some flexibility in terms of prioritization"/>
<node id="the flexibility problem on the core local-level"/>
<node id="CLIC 15"/>
<node id="these limitations"/>
<node id="interrupts to be prioritized by so-called levels and priorities"/>
<node id="multiple horizontal interrupts"/>
<node id="equal levels and priorities"/>
<node id="the CLIC"/>
<node id="the highest numbered interrupt (identification number ID 15)"/>
<node id="an arbitrary assignment decided at design time"/>
<node id="this feature"/>
<node id="RTOSs that only want to disable a subset of all interrupts during critical sections"/>
<node id="interrupts that do not interfere with the data accessed in such a critical section"/>
<node id="still fire"/>
<node id="its level is higher than both the interrupt threshold and IRQ2's level"/>
<node id="interrupts fired from different privilege modes"/>
<node id="vertical interrupts"/>
<node id="interrupts fired from the same privilege mode"/>
<node id="TABLE I"/>
<node id="preemption conditions of two nested interrupts IRQ2 and IRQ1 according to the CLIC specification"/>
<node id="THE CLIC SPECIFICATION"/>
<node id="the case of redundant context restore (see Section II-B6)"/>
<node id="XNXTI"/>
<node id="a CSR short for next interrupt handler address"/>
<node id="XNXTI and interrupt-enable CSRs"/>
<node id="non-vectored interrupts"/>
<node id="READING FROM THIS CSR"/>
<node id="to fast-track interrupts that arrive late"/>
<node id="to avoid redundant context save-restore by running through pending interrupts back-to-back"/>
<node id="the core"/>
<node id="an active handler"/>
<node id="architecture entering an interrupt context or performing a context switch"/>
<node id="the HW to store enough information to resume operation correctly after returning from the aforementioned context"/>
<node id="Improving interrupt latency and context switch times"/>
<node id="controlling the amount of state that needs to be preserved to enter and leave an interrupt context"/>
<node id="increasing the bandwidth and decreasing the latency to memory"/>
<node id="relying on latency-hiding techniques that defer the effective saving of the state to a later point in time"/>
<node id="architectural features and HWSW codesign"/>
<node id="proposed architecture"/>
<node id="typical case scenarios"/>
<node id="THE BACKGROUND-SAVING MECHANISM"/>
<node id="THE STACK POINTER"/>
<node id="THE BANK-SWITCHED CONTENTS IN MEMORY"/>
<node id="THE EXECUTION OF THE CORE"/>
<node id="IN PARALLEL"/>
<node id="2"/>
<node id="an overview of the design"/>
<node id="the gateway"/>
<node id="programmable configuration information"/>
<node id="each interrupt line"/>
<node id="level, priority, enable status, and sensitivity (leveledge)"/>
<node id="THE INTERRUPT PRIORITIZATION MODULE"/>
<node id="THE TREE FROM LEAVES TO THE ROOT"/>
<node id="THE SOUGHT-AFTER MAXIMUM LEVEL AND PRIORITY INTERRUPT"/>
<node id="AT THE ROOT"/>
<node id="each tree"/>
<node id="low overhead in terms of area and delay"/>
<node id="overhead in terms of area"/>
<node id="O(N)"/>
<node id="overhead in terms of delay"/>
<node id="O(LOG(N))"/>
<node id="THE INTERRUPT"/>
<node id="THE CORE"/>
<node id="A HANDSHAKE-BASED INTERFACE"/>
<node id="The additional kill signal"/>
<node id="a handshake to restart"/>
<node id="A handshake"/>
<node id="a potentially more important interrupt to be presented to the core"/>
<node id="N 4096 LOCAL INTERRUPT SOURCES"/>
<node id="additional pipeline stages"/>
<node id="in the arbitration tree"/>
<node id="relax timing"/>
<node id="OUR VERSION OF THE CLIC"/>
<node id="SHV"/>
<node id="THE XNXTI CSR IN THE CORE"/>
<node id="interrupt handling capabilities"/>
<node id="interrupt handling capabilities of CV32"/>
<node id="introducing priority and levels management in HW"/>
<node id="critical operations such as interrupt state and context save/restore"/>
<node id="SW"/>
<node id="CV32FASTIRQ"/>
<node id="filling this gap"/>
<node id="THE CLIC"/>
<node id="this with the LEVELPRIORITY scheme"/>
<node id="that"/>
<node id="moving the interrupt state saving logic in HW"/>
<node id="adding EMRET to handle redundant interrupt context sequences"/>
<node id="a wrapper around the cores RF"/>
<node id="the RF by an additional read port for the background-saving mechanism"/>
<node id="registers for latching the additional processor state required for proper interrupt nesting"/>
<node id="A new interrupt at the CLIC"/>
<node id="whether the interrupt level exceeds the configured threshold"/>
<node id="THE CORES STATE MACHINE"/>
<node id="the pipeline"/>
<node id="the program counter"/>
<node id="the vector table entry"/>
<node id="the saving logic"/>
<node id="a bank switch"/>
<node id="the bank switch"/>
<node id="the interrupt context to have a fresh set of registers"/>
<node id="the other bank contents"/>
<node id="a separate port to the main memory"/>
<node id="RF BANKS"/>
<node id="on an interrupt"/>
<node id="the stack pointer during a bank switch"/>
<node id="a dedicated adder between the two RFs"/>
<node id="THE RISC-V EMBEDDED AND INTEGER ABI"/>
<node id="THE STACK POINTER POINTS BELOW THE LAST SAVED REGISTER ON THE STACK"/>
<node id="APPROPRIATELY TO MAINTAIN ABI INVARIANTS"/>
<node id="the program code running in the interrupt handler"/>
<node id="the values on the stack"/>
<node id="this mechanism for leaf-type interrupts"/>
<node id="Doing away with this mechanism for leaf-type interrupts"/>
<node id="a new ABI considering a virtual stack pointer offset when generating code for interrupt handlers"/>
<node id="the nested interrupt case"/>
<node id="interactions"/>
<node id="background-saving mechanism and regular loadstore instructions of the core"/>
<node id="incorrect execution"/>
<node id="A load instruction"/>
<node id="an architectural register"/>
<node id="The background-saving mechanism"/>
<node id="the same register"/>
<node id="No conflict"/>
<node id="when a load instruction is trying to update an architectural register while the background-saving mechanism is trying to read the same register"/>
<node id="the write-back stage of the core"/>
<node id="updates to the RF"/>
<node id="at this point"/>
<node id="the bank switching operation"/>
<node id="after updates to the RF are resolved"/>
<node id="correctness of the execution"/>
<node id="loads or stores accessing stack memory regions where the background-saving mechanism is writing to"/>
<node id="properly resolved"/>
<node id="execution of the handler"/>
<node id="if this happens while the background-saving mechanism is still at work"/>
<node id="stale data"/>
<node id="data that is immediately overwritten"/>
<node id="the load-store unit of the core"/>
<node id="the ongoing state being written to memory"/>
<node id="A straightforward solution"/>
<node id="stall the cores pipeline while the background-saving mechanism is at work"/>
<node id="A LOAD SOON IN THE INTERRUPT HANDLER"/>
<node id="the load-store unit"/>
<node id="the memory in the range of the stack pointer"/>
<node id="the stack pointer"/>
<node id="decrementing the stack pointer"/>
<node id="space available"/>
<node id="the background-saving mechanism"/>
<node id="the interrupt state word by word"/>
<node id="the address offset of the last word pushed out by the background-saving mechanism"/>
<node id="any incoming load and stores"/>
<node id="LOAD AND STORES THAT TRY TO ACCESS DATA THAT IS NOT YET PUSHED TO MEMORY"/>
<node id="THE CORES PIPELINE TO STALL"/>
<node id="THIS MECHANISM"/>
<node id="THE CORRECTNESS OF LOADS AND STORES ISSUED BY THE CORE"/>
<node id="Accessing stack memory locations during the execution of an interrupt handler"/>
<node id="two use cases"/>
<node id="A SYSTEM CALL HANDLER"/>
<node id="the ECALL instruction in RISC-V"/>
<node id="user-provided arguments"/>
<node id="most"/>
<node id="general-purpose registers"/>
<node id="some"/>
<node id="the stack"/>
<node id="short interrupt handlers"/>
<node id="the full interrupt state has been saved"/>
<node id="each of these cases"/>
<node id="the stalling logic outlined in Section III-C3"/>
<node id="engaging the stalling logic outlined in Section III-C3"/>
<node id="higher interrupt latencies"/>
<node id="a hardware solution"/>
<node id="forwarding logic"/>
<node id="what is being written by the background-saving mechanism"/>
<node id="these values from the store queue"/>
<node id="these values"/>
<node id="the store queue"/>
<node id="the memory subsystem outside the core"/>
<node id="some register values"/>
<node id="because they might not have reached the load-store unit yet"/>
<node id="THE APPROACH"/>
<node id="HW COMPLEXITY"/>
<node id="A DYNAMIC ADDRESS LOOKUP INTO A QUEUE-LIKE BUFFER"/>
<node id="an SW-based solution that does not cause any kind of stalling"/>
<node id="the pipeline stalling logic by ordering the loads to access the already stored interrupt state first"/>
<node id="an analysis of the functional improvements"/>
<node id="THE CV32S RF"/>
<node id="additional logic for the background-saving mechanism"/>
<node id="parts of the old memory bank (the interrupt context)"/>
<node id="the cores stack location"/>
<node id="execution"/>
<node id="the new bank"/>
<node id="this design"/>
<node id="a dedicated memory port for the background-saving mechanism"/>
<node id="the dedicated memory port"/>
<node id="the port from the load-store unit"/>
<node id="the general-purpose registers X1, X2"/>
<node id="in the interrupt handler, we use the same order to load words back"/>
<node id="the programmer"/>
<node id="that to achieve the best possible latency"/>
<node id="programmer"/>
<node id="compiler-specific attributes to write his interrupt handlers"/>
<node id="compiler-specific attributes"/>
<node id="attribute((interrupt)) in GCC"/>
<node id="compiler"/>
<node id="the fact that programmer uses compiler-specific attributes to write his interrupt handlers"/>
<node id="how nested interrupt handling code works for the basic CLINT-mode, the baseline CLIC, and our FastIRQ extension"/>
<node id="ROUTINES"/>
<node id="SAVING STATE FOR VECTORED NESTING INTERRUPTS"/>
<node id="PROPOSED FASTIRQ EXTENSION"/>
<node id="reducing the RF size"/>
<node id="lower context switch times"/>
<node id="the interrupt latency"/>
<node id="the set of caller-save registers"/>
<node id="the same when using the embedded-application binary interface (EABI)"/>
<node id="OUR IMPLEMENTATION"/>
<node id="the core to dynamically switch between RV32I and RV32E with FastIRQ depending on the workload"/>
<node id="one"/>
<node id="additional registers for the seven caller-save registers to save area"/>
<node id="doubling the RF size for the banking logic"/>
<node id="adding additional registers for the seven caller-save registers to save area"/>
<node id="increased pressure on the RF"/>
<node id="not acceptable"/>
<node id="the interrupt state"/>
<node id="simply switching register banks"/>
<node id="to differentiate between a regular return from an interrupt handler using MRET"/>
<node id="THIS INSTRUCTION"/>
<node id="the same function as MRET"/>
<node id="switching register banks"/>
<node id="this situation"/>
<node id="directly checking for other interrupts pending on the same level before restoring the executions interrupt context"/>
<node id="an HW-assisted solution to address such a scenario with the XNXTI CSRS"/>
<node id="NUCLEIS ENHANCED CLIC (ECLIC) 18"/>
<node id="the jump to the queuing interrupt handler in the XNXTI HW (JALXNXTI)"/>
<node id="NUCLEI SYSTEM TECHNOLOGY ECLIC 39"/>
<node id="traditional XNXTI"/>
<node id="a novel CSR for machine privilege mode, JALMNXTI 18"/>
<node id="JALMNXTI 18"/>
<node id="this work in Section IV"/>
<node id="some HW"/>
<node id="this concept of removing redundant context restores as tail-chaining"/>
<node id="latency"/>
<node id="re-enabling global interrupts"/>
<node id="A high-level interrupt"/>
<node id="the current running interrupt handler"/>
<node id="MIE"/>
<node id="to prevent that corresponding lower-priority interrupts are disabled"/>
<node id="this return path"/>
<node id="HW by adding an additional write port to the cores RF"/>
<node id="exiting an interrupt handler"/>
<node id="less time-critical"/>
<node id="how quickly an external event is addressed"/>
<node id="context switches"/>
<node id="OS-specific and HW-specific parts"/>
<node id="The OS part"/>
<node id="all contributions to the context switch time that is specific to the OS itself"/>
<node id="computing the next task to be scheduled"/>
<node id="bookkeeping operations"/>
<node id="THE REMAINDER"/>
<node id="THE HW-DEPENDENT SAVING AND RESTORING OF THE STATE BELONGING TO THE NEW CONTEXT"/>
<node id="THE IDEA"/>
<node id="THE STATE SAVING AND RESTORING PART OF CONTEXT FIG"/>
<node id="HW"/>
<node id="the previous register state to memory in the background"/>
<node id="HW mechanism"/>
<node id="swap the registers"/>
<node id="the registers in the background"/>
<node id="the rest of the context switch routine"/>
<node id="the initial part of the context switch routine"/>
<node id="for that"/>
<node id="the current running tasks state to memory"/>
<node id="Additional RISC-V extensions"/>
<node id="more context switching state"/>
<node id="More context switching state"/>
<node id="contrary to the goals of FastIRQ regarding latencies"/>
<node id="adding more state to FastIRQ"/>
<node id="technical limitations"/>
<node id="the resulting design"/>
<node id="a significant increase in area and power"/>
<node id="a dirty bit"/>
<node id="the fast path competitive"/>
<node id="THIS SECTION"/>
<node id="A FUNCTIONAL AND QUANTITATIVE EVALUATION OF THE VARIOUS FLAVORS OF THE CV32RT"/>
<node id="the first standardized RISC-V interrupt controller"/>
<node id="The interrupt lines"/>
<node id="a hardwired prioritization scheme"/>
<node id="THE BASELINE CLIC"/>
<node id="THESE WEAKNESSES"/>
<node id="A level threshold register per privilege level (XINTTHRESH)"/>
<node id="the set of allowed horizontal interrupts"/>
<node id="the set of allowed horizontal interrupts to those whose level exceeds the given value in the register"/>
<node id="VECTORING"/>
<node id="selectively enabled or disabled per interrupt line"/>
<node id="THIS SOLUTION"/>
<node id="VECTORED INTERRUPTS"/>
<node id="NON-VECTORED INTERRUPTS"/>
<node id="THE OPTIONAL XNXTI EXTENSION"/>
<node id="multiple horizontal interrupts to be serviced in sequence without redundant context-restoring operations in between"/>
<node id="the first interrupt"/>
<node id="the full latency cost"/>
<node id="the interrupt context storing part itself"/>
<node id="READING THE XNXTI CSR"/>
<node id="a pointer to the vector table entry for the next pending and qualifying interrupt"/>
<node id="a direct jump there"/>
<node id="THIS APPROACH"/>
<node id="THE LATENCY ADVANTAGE OF HW VECTORING"/>
<node id="AN SW EMULATION THEREOF"/>
<node id="RTL simulations of the different versions of CV32RT as part of CONTROLPULP"/>
<node id="memory subsystem"/>
<node id="single cycle (zero wait state) access to static random access memory (SRAM)"/>
<node id="The memory bank we are using"/>
<node id="other bus masters"/>
<node id="interrupt lines"/>
<node id="no additional latencies introduced between interrupt sources and the CLIC"/>
<node id="the HW contributed interrupt latency of our FastIRQ extension"/>
<node id="the HW contributed interrupt latency"/>
<node id="Section II-B3"/>
<node id="the HW contributed interrupt latency of our FastIRQ extension to the CV32 and CV32RT variations"/>
<node id="CV32 and CV32RT variations"/>
<node id="Standard CLIC, XNXTI, JALXNXTI"/>
<node id="all caller-save registers"/>
<node id="saved"/>
<node id="Interrupt handler routines that save the interrupt context in SW"/>
<node id="the minimum state if the compiler is able to fully inline the handlers function body"/>
<node id="interrupt handler routines that use sw-based mechanisms to save and restore interrupt state"/>
<node id="the handler code"/>
<node id="some caller-save registers"/>
<node id="the compiler"/>
<node id="fully inlining the handler code and saving some caller-save registers"/>
<node id="the interrupt latency in the optimal case"/>
<node id="only one caller-save register"/>
<node id="SW-based interrupt handlers"/>
<node id="INTERRUPTS"/>
<node id="the design at the interrupt controller inputs"/>
<node id="the EABI of RISC-V"/>
<node id="the regular integer ABI of RISC-V"/>
<node id="FOR OUR FASTIRQ EXTENSION"/>
<node id="is always saved"/>
<node id="the HW"/>
<node id="which caller-save registers need to be saved"/>
<node id="TABLE III"/>
<node id="the main techniques for optimizing interrupt context and task context save/restore with nested and non-nested interrupts employed by industry and academia in the embedded and real-time application domains"/>
<node id="the results"/>
<node id="FIG."/>
<node id="several designs"/>
<node id="the interrupt context directly in HW"/>
<node id="AUTOMATIC INTERRUPT CONTEXT SAVERESTORE"/>
<node id="SW HOUSEKEEPING OVERHEAD BEFORE AND AFTER HANDLING THE INTERRUPT ROUTINE"/>
<node id="THE ACCELERATION OF THE COMPLETE TASK CONTEXT SWITCH"/>
<node id="The presented solutions"/>
<node id="optimizing context, save/restore with HW and SW cooperation"/>
<node id="a cohesive approach to address both interrupt context and task context switch acceleration"/>
<node id="existing RISC-V-based approaches that can close the gap with well-established industry vendors"/>
<node id="INTERRUPT CONTEXT SAVERESTORE"/>
<node id="XNXTI and JALXNXTI"/>
<node id="even worse"/>
<node id="42 cycles"/>
<node id="JALXNXTI"/>
<node id="35 cycles"/>
<node id="additional instructions in the code path between the handler and interrupt event"/>
<node id="XNXTI AND JALXNXTI"/>
<node id="pending interrupts"/>
<node id="the respective handlers"/>
<node id="a pointer to the address of the next handler"/>
<node id="a small code sequence (load, jump, and retry loop)"/>
<node id="these operations into one instruction"/>
<node id="fusing these operations into one instruction"/>
<node id="saving nine cycles"/>
<node id="ARM Cortex-M4"/>
<node id="an interrupt latency of 12 cycles given a single-cycle memory"/>
<node id="the same task in six cycles"/>
<node id="it has access to single-cycle memory 24"/>
<node id="the cost in clock cycles of such sequences"/>
<node id="the baseline CLIC"/>
<node id="68 cycles when using the integer ABI"/>
<node id="50 cycles when using the embedded ABI"/>
<node id="THE EMRET MECHANISM OF FASTIRQ"/>
<node id="similarly"/>
<node id="eight clock cycles"/>
<node id="context switch time"/>
<node id="number of clock cycles between two FreeRTOS dummy tasks"/>
<node id="baseline CV32RT and CV32RTFASTIRQ"/>
<node id="Average context switch time"/>
<node id="FreeRTOS for two tasks of various flavors of CV32RT"/>
<node id="all compile time options such as tracing, stack overflow signaling, and the more generic task selection mechanism"/>
<node id="to minimize the context switch code"/>
<node id="configurations that do not have Fig"/>
<node id="generic Cortex-M4 core"/>
<node id="single-cycle access to memory"/>
<node id="ARM Cortex-M"/>
<node id="16 core registers"/>
<node id="us to skip ahead the saving of the general-purpose registers"/>
<node id="an SW interrupt as part of the save sequence"/>
<node id="THE SW INTERRUPT"/>
<node id="THE FASTIRQ MECHANISM"/>
<node id="SAVING THE GENERAL-PURPOSE REGISTERS TO MEMORY"/>
<node id="using the I-extension"/>
<node id="31 cycles (19) for a context switch"/>
<node id="using the E-extension"/>
<node id="16 cycles (12) for a context switch"/>
<node id="not using registers that are still being saved by the background-saving mechanism"/>
<node id="saving cycles for a context switch"/>
<node id="THE FREERTOS WEBSITE 20"/>
<node id="context switches as low as 96 cycles for a Cortex-M4 implementation"/>
<node id="CV32RT as part of the ControlPULP platform"/>
<node id="SYNOPSYS DESIGN COMPILER 2022.03"/>
<node id="synthesizing CV32RT"/>
<node id="GlobalFoundries 12LP FinFET technology"/>
<node id="500 MHz, TT corner, and 25 C"/>
<node id="One gate equivalent (GE) for this technology"/>
<node id="0.121 m2"/>
<node id="STM32L476RG"/>
<node id="higher latencies due to memory access stalls and other implementation choices in the memory subsystem"/>
<node id="RISC-V E-extension"/>
<node id="the available general-purpose registers from 32 to 16"/>
<node id="Reducing the available general-purpose registers from 32 to 16"/>
<node id="the context switch state that needs to be saved and restored"/>
<node id="REPORTS"/>
<node id="the CLIC implemented in the proposed with different interrupt sources"/>
<node id="AREA OVERHEAD"/>
<node id="two main configurations"/>
<node id="FASTIRQ overhead in CV32RTFASTIRQ core"/>
<node id="a minimal 10 area increase"/>
<node id="area increase"/>
<node id="the ID stage"/>
<node id="THE DESIGN"/>
<node id="GF12LP TECHNOLOGY"/>
<node id="500 MHZ"/>
<node id="TT CORNER"/>
<node id="25 C"/>
<node id="0.8 V"/>
<node id="SUPER LOW VT STANDARD CELLS"/>
<node id="more than half of the resources"/>
<node id="the configuration registers required to control the CLIC"/>
<node id="the size"/>
<node id="the number of input interrupts"/>
<node id="one 32-bit register"/>
<node id="an area overhead of about 176 GE"/>
<node id="The remaining area"/>
<node id="the gateway and binary tree arbitration logic at the core of the CLIC working principle"/>
<node id="additional housekeeping control logic that scales linearly with the number of interrupt sources"/>
<node id="the fraction of the design occupied by the arbitration tree"/>
<node id="when increasing the number of sources"/>
<node id="a larger area overhead compared to traditional RISC-V CLINT 14"/>
<node id="the gain in flexibility"/>
<node id="a broader application scope with time-critical systems"/>
<node id="a 10 overall area increase compared to baseline CLIC only"/>
<node id="INSTRUCTION DECODE (ID) STAGE"/>
<node id="an area overhead of 21 compared to CV32RTCLIC"/>
<node id="OTHER HW BLOCKS OF THE CORE"/>
<node id="primarily unaffected"/>
<node id="ID stage"/>
<node id="the HW block where the additional registers and the automatic stacking/unstacking logic are localized"/>
<node id="A breakdown"/>
<node id="FIG"/>
<node id="additional storage space for automatic context save and restore in HW"/>
<node id="the area of the RF by about 36 in the proposed implementation"/>
<node id="the logic for managing the shadow registers"/>
<node id="an overhead of 40 on the baseline ID stage controller"/>
<node id="HW overhead coming from the additional EMRET instruction"/>
<node id="negligible"/>
<node id="increased size of the ID stage"/>
<node id="the benefits of a simplified programming model that moves several SW operations in HW"/>
<node id="the benefits of significantly lowered interrupt latency than standard RISC-V"/>
<node id="significantly lowered interrupt latency"/>
<node id="standard RISC-V"/>
<node id="the critical path of the base core design"/>
<node id="TIME-CRITICAL SYSTEMS"/>
<node id="AREA EFFICIENCY"/>
<node id="SAFETY, SECURITY, AND RELIABILITY"/>
<node id="this section"/>
<node id="the leading solutions to optimize handling asynchronous events in state-of-the-art embedded and real-time MCUs"/>
<node id="existing PLICs and CLICs"/>
<node id="CLICs"/>
<node id="Section II-C"/>
<node id="solutions across various platforms in industry and academia"/>
<node id="Solutions"/>
<node id="interrupt context save/restore techniques"/>
<node id="context switch techniques"/>
<node id="dedicated strategies to optimize redundant context restore with back-to-back interrupts"/>
<node id="modified version of the return authorized licensed use"/>
<node id="California Polytechnic State University San Luis Obispo"/>
<node id="THE OVERVIEW"/>
<node id="the definition presented in Section II-B for the interrupt latency"/>
<node id="references to different variants adopted by SOTA in Table III"/>
<node id="a dedicated register bank"/>
<node id="dedicated register bank"/>
<node id="up to eight registers"/>
<node id="eight registers"/>
<node id="minimize context switching"/>
<node id="the jump address from the interrupt vector table"/>
<node id="fetching the jump address"/>
<node id="simultaneously during context save and embed context restore within the return instruction"/>
<node id="ARM Cortex-M series"/>
<node id="Nested Vectored Interrupt Controller (NVIC)"/>
<node id="A state machine 32"/>
<node id="caller-save register stacking in the background"/>
<node id="link register a value (EXCRETURN)"/>
<node id="value (EXCRETURN)"/>
<node id="core to start unwinding the stack"/>
<node id="unwinding the stack to return to normal program execution"/>
<node id="Interrupt Control Unit (ICU) 33, 34, 35"/>
<node id="Infineon Aurix MCU-class Tricore family"/>
<node id="The context of the calling routine"/>
<node id="memory autonomously"/>
<node id="Restoring the context"/>
<node id="the RET instruction"/>
<node id="the return jump 36"/>
<node id="27"/>
<node id="extensions for the RISC-V CLIC"/>
<node id="interrupt handling"/>
<node id="automatic stacking in hardware"/>
<node id="the core's Harvard architecture"/>
<node id="simultaneous data and instruction memory access"/>
<node id="Register banking"/>
<node id="a technique adopted by several architectures"/>
<node id="a task's context without pushing/popping register values to the stack"/>
<node id="an additional area overhead in the design"/>
<node id="A tasks context switch"/>
<node id="quickly transferring the suspended context to the dedicated register bank"/>
<node id="already restoring the next task to be executed"/>
<node id="HW REGISTER BANKING"/>
<node id="PLICs (GIC)"/>
<node id="ARM designs"/>
<node id="A similar approach"/>
<node id="the Renesas M32C80 series 30"/>
<node id="A dual register bank"/>
<node id="quickly swapping the context without saving/restoring to/from the stack"/>
<node id="The second register bank"/>
<node id="high-speed interrupts"/>
<node id="THE AURIX FAMILY"/>
<node id="an SW managed solution"/>
<node id="the SW managed solution"/>
<node id="a specific organization of the context layout in the system memory"/>
<node id="the specific organization of the context layout"/>
<node id="context save area (CSA) chained in a linked list fashion"/>
<node id="A more complex approach"/>
<node id="Huang et al."/>
<node id="28"/>
<node id="a valid-based mechanism in HW to block context switch on selected registers"/>
<node id="valid-based mechanism in HW"/>
<node id="context switch on selected registers"/>
<node id="register movement by almost 50"/>
<node id="THIS FEATURE"/>
<node id="SEMI-SHADOWING"/>
<node id="REGISTER BANKING"/>
<node id="the top (FLIP) and bottom (FLOP) halves of the RF as RF copies"/>
<node id="the latter approach"/>
<node id="leveraging RISC-V's RV32E base instruction set by re-using the lower 16 architectural registers of the RF"/>
<node id="THE EVALUATION IN 28"/>
<node id="HW IMPLEMENTATION"/>
<node id="AREA OVERHEAD ASSESSMENT"/>
<node id="CONTEXT SWITCHING OVERHEAD BY 24"/>
<node id="CONTEXT SWITCHING OVERHEAD"/>
<node id="24"/>
<node id="on THE DSPSTONE BENCHMARK"/>
<node id="THESE APPROACHES"/>
<node id="HW- and SW-induced latencies when handling asynchronous events"/>
<node id="HSE"/>
<node id="a hardware scheduling engine"/>
<node id="interrupts to running tasks"/>
<node id="a specialized interrupt controller"/>
<node id="this approach"/>
<node id="lowering interrupt latency and task context switches dramatically"/>
<node id="flexibility"/>
<node id="its area overhead"/>
<node id="for a high number of tasks"/>
<node id="replicating hardware resources per task"/>
<node id="architectures such as superscalar central processing units (CPUs)"/>
<node id="graphic processing units (GPUs)"/>
<node id="Such works"/>
<node id="the difference in memory footprint between architectures (MB size RFs) and low-end embedded microcontrollers targeted in this work"/>
<node id="RF caching rather than register shadowing or banking"/>
<node id="RF caching"/>
<node id="performance reasons"/>
<node id="Performance reasons"/>
<node id="lower access latency to the RF"/>
<node id="higher thread-level parallelism (TLP)"/>
<node id="such techniques"/>
<node id="the system's predictability"/>
<node id="the XNXTI CSR with SW-managed interrupt service loops as part of the CLIC specifications"/>
<node id="early commercial examples with 31"/>
<node id="RISC-V AIA WITHOUT APLIC"/>
<node id="MNXTI"/>
<node id="MNXTI with the XTOPI CSR"/>
<node id="XTOPI CSR"/>
<node id="the highest-priority, pending, and enabled interrupt for a specific privilege mode"/>
<node id="both late arrival and redundant context restore mechanisms"/>
<node id="a combination of the background-saving with a register banking approach"/>
<node id="task context switch times in FreeRTOS to 104 clock cycles using FastIRQ"/>
<node id="20 times faster than an SW-only approach"/>
<node id="the authors"/>
<node id="analyzing FastIRQs impact on timing channels"/>
<node id="analyzing FastIRQs integration with different RISC-V extensions"/>
<node id="C. ROCHANGE, S. UHRIG, AND P. SAINRAT"/>
<node id="TIME-PREDICTABLE ARCHITECTURES (FOCUS COMPUTER ENGINEERING SERIES)"/>
<node id="WILEY"/>
<node id="in HOBOKEN, NJ, USA in 2014"/>
<node id="L. M. PINHO ET AL."/>
<node id="HIGH-PERFORMANCE AND TIME-PREDICTABLE EMBEDDED COMPUTING"/>
<node id="HTTP:EU.WILEY.COMWILEYCDA WILEYTITLEPRODUCTCD-1848215932.HTML"/>
<node id="RIVER"/>
<node id="WHARTON, TX, USA"/>
<node id="2018"/>
<node id="3 F. Reghenzani, G. Massari, and W. Fornaciari"/>
<node id="The Real-Time Linux Kernel: A Survey on PreemptRT, ACM Comput."/>
<node id="4 M. LIU, D. LIU, Y. WANG, M. WANG, AND Z. SHAO"/>
<node id="ON IMPROVING REAL-TIME INTERRUPT LATENCIES OF HYBRID OPERATING SYSTEMS WITH TWO-LEVEL HARDWARE INTERRUPTS"/>
<node id="IEEE TRANS."/>
<node id="5 P. Mantegazza, E. L. Dozio, and S. Papacharalambous"/>
<node id="RTAI: Real Time Application Interface"/>
<node id="Linux J."/>
<node id="J. Valvano"/>
<node id="Introduction to Embedded Systems"/>
<node id="http://web.engr.oregonstate.edu/traylor/ece473 PDFs/minimize_interrupt_response_time.pdf"/>
<node id="CREATESPACE"/>
<node id="SCOTTS VALLEY, CA, USA"/>
<node id="AUG. 2016"/>
<node id="9 Y. HUANG, L. SHI, J. LI, Q. LI, AND C. J. XUE"/>
<node id="WCET-AWARE RE-SCHEDULING REGISTER ALLOCATION FOR REAL-TIME EMBEDDED SYSTEMS WITH CLUSTERED VLIW ARCHITECTURE"/>
<node id="X. Zhou and P. Petrov"/>
<node id="Rapid and low-cost context-switch through embedded processor customization for real-time and control applications"/>
<node id="Proc."/>
<node id="ASSOCIATION FOR COMPUTING MACHINERY"/>
<node id="NEW YORK, NY, USA"/>
<node id="2006"/>
<node id="352"/>
<node id="10.11451146909.1147001"/>
<node id="I. Behnke, L. Pirl, L. Thamsen, R. Danicki, A. Polze, and O. Kao"/>
<node id="Interrupting Real-Time IoT Tasks: How Bad Can It Be to Connect Your Critical Embedded System to the Internet?"/>
<node id="K. Asanovic and D. A. Patterson"/>
<node id="Instruction Sets Should Be Free: The Case for RISC-V"/>
<node id="THE RISC-V INSTRUCTION SET MANUAL VOLUME II: PRIVILEGED ARCHITECTURE VERSION 1.9"/>
<node id="A. WATERMAN, Y. LEE, R. AVIZIENIS, D. A. PATTERSON, AND K. ASANOVIC"/>
<node id="HTTP://WWW2.EECS.BERKELEY.EDU/PUB/STECHRPTS/2014/EECS-2014-146.HTML"/>
<node id="EECS, Berkeley"/>
<node id="EECS"/>
<node id="UNIV."/>
<node id="California"/>
<node id="Berkeley"/>
<node id="CA"/>
<node id="USA"/>
<node id="Tech"/>
<node id="RISC-V Fast Interrupt Blob"/>
<node id="https://github.com/riscv/riscv-fast-interrupt/blob/master/clic"/>
<node id="ADOC 16 M. GAUTSCHI ET AL."/>
<node id="NEAR-THRESHOLD RISC-V CORE WITH DSP EXTENSIONS FOR SCALABLE IOT ENDPOINT DEVICES"/>
<node id="OPENHW GROUP"/>
<node id="CV32E40P USER MANUAL"/>
<node id="an organization"/>
<node id="HTTPS"/>
<node id="39 NUCLEI SYSTEM TECHNOLOGY CO. LTD."/>
<node id="ECLIC UNIT"/>
<node id="NUCLEI"/>
<node id="SPEC"/>
<node id="A. Ottaviano et al."/>
<node id="ControlPULP: a RISC-V on-chip parallel power controller for many-core HPC processors with FPGA-based hardware-in-the-loop power and thermal emulation"/>
<node id="ControlPULP"/>
<node id="a RISC-V on-chip parallel power controller"/>
<node id="many-core HPC processors"/>
<node id="FPGA-based hardware-in-the-loop power and thermal emulation"/>
<node id="Document"/>
<node id="https://doc.nucleisys.com/nucleispecisaintroduction.html"/>
<node id="PARALLEL PROGRAM."/>
<node id="FEB. 2024"/>
<node id="10.1007S10766-024-00761-4"/>
<node id="FREERTOS"/>
<node id="real-time operating system for microcontrollers"/>
<node id="REAL TIME ENGINEERS LTD."/>
<node id="ONLINE"/>
<node id="21 C.-M. Lin"/>
<node id="Nested Interrupt Analysis of Low Cost and High Performance Embedded Systems Using GSPN Framework"/>
<node id="IEICE Trans."/>
<node id="Text"/>
<node id="https://www.freertos.org/index.html"/>
<node id="RISCV-PLIC-1.0.0.PDF"/>
<node id="https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic-1.0.0.pdf"/>
<node id="J. Yiu"/>
<node id="The Definitive Guide to ARM Cortex-M3 Cortex-M4 Processors, 3rd ed."/>
<node id="NEWNES"/>
<node id="in BOSTON, MA, USA in 2013"/>
<node id="HTTPS:DEVELOPER.ARM.COMDOCUMENTATION1001660001"/>
<node id="25 J. YIU"/>
<node id="ARM Cortex-M processors"/>
<node id="V. G. Gaitan, N. C. Gaitan, and I. Ungurean"/>
<node id="CPU architecture based on a hardware scheduler and independent pipeline registers"/>
<node id="IEEE Transactions"/>
<node id="Beginner guide on interrupt latency and interrupt latency of the ARM Cortex-M processors"/>
<node id="https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/beginner-guide-on-interrupt-latency-and-interrupt-latency-of-the-arm-cortex-m-processors?pifragment=227142"/>
<node id="LI and J. K. LEE"/>
<node id="paged register files for improving context switching on embedded processors"/>
<node id="30"/>
<node id="RENESAS"/>
<node id="HARDWARE MANUAL"/>
<node id="RENESAS MCU M16C"/>
<node id="https://www.renesas.com/us/en/document/mahm32c87-group-m32c87-m32c87a-m32c87b-hardware-manual"/>
<node id="SIFIVE INC."/>
<node id="2021"/>
<node id="CORECOMPLEXMANUAL21G1.PDF"/>
<node id="HTTPS:SIFIVE.CDN.PRISMIC.IOSIFIVE7C22C2EC-8AF4-4B6C-A5FE-9327D91E7808E21CORECOMPLEXMANUAL21G1.PDF"/>
<node id="STMICROELECTRONICS"/>
<node id="the text"/>
<node id="STM32L5-SYSTEM-NESTEDVECTOREDINTERRUPTCONTROLNVIC.PDF"/>
<node id="https://www.st.com/content/ccc/resource/training/technical/product_training/group/16135d207346f4e83/STM32L5-SYSTEM-NESTEDVECTOREDINTERRUPTCONTROLNVIC.files/STM32L5-SYSTEM-NESTEDVECTOREDINTERRUPTCONTROLNVIC.pdf"/>
<node id="INFINEON TECHNOLOGIES AG"/>
<node id="FAST POWERTRAIN MICROCONTROLLER"/>
<node id="a microcontroller"/>
<node id="https://old.hotchips.org/wp-content/uploads/hcarchives/hc16/3tue6hc16sess7pres1bw.pdf"/>
<node id="Infineon Technologies AG"/>
<node id="FILE"/>
<node id="https://hitex.co.uk/fileadmin/uk-files/downloads/shieldbuddytc27xdumv2.2.pdf"/>
<node id="the file"/>
<node id="TC27X D-STEP"/>
<node id="32-bit single-chip microcontroller"/>
<node id="TRICORE V1.6"/>
<node id="CORE ARCHITECTURE"/>
<node id="HTTPS:WWW.INFINEON.COMDGDLTC16 ARCHITECTUREVOL1.PDF?FILEIDDB3A3043372D5CC801373B0F374D5D67"/>
<node id="TASK CONTEXT SWITCHING RTOS"/>
<node id="U.S. PATENT 7 434 222 B2"/>
<node id="OCT. 2008"/>
<node id="H. ZENG AND K. GHOSE"/>
<node id="REGISTER FILE CACHING FOR ENERGY EFFICIENCY"/>
<node id="ISLPED PROC."/>
<node id="Date"/>
<node id="6, JUNE 2024"/>
<node id="38 M. SADROSADATI ET AL."/>
<node id="HIGHLY CONCURRENT LATENCY-TOLERANT REGISTER FILES FOR GPUS"/>
<node id="ACM TRANS."/>
<node id="the B.Sc."/>
<node id="Degrees"/>
<node id="ETH Zurich, Zurich, Switzerland"/>
<node id="2015 and 2017, respectively"/>
<node id="Degree"/>
<node id="the Digital Circuits and Systems Group of Prof. Benini"/>
<node id="Digital Circuits and Systems Group"/>
<node id="ETH Zurich"/>
<node id="Zurich, Switzerland"/>
<node id="His research interests"/>
<node id="real-time computing"/>
<node id="compilers"/>
<node id="operating systems"/>
<node id="power management of HPC processors"/>
<node id="energy-efficient processor architecture"/>
<node id="LUCA BENINI"/>
<node id="the Ph.D."/>
<node id="Physical Engineering"/>
<node id="Politecnico di Turino, Turin, Italy"/>
<node id="Electrical Engineering"/>
<node id="Politecnico di Turino"/>
<node id="Grenoble INP-PHELMA, Grenoble, France"/>
<node id="EPFL Lausanne, Lausanne, Switzerland"/>
<node id="2020"/>
<node id="Stanford University"/>
<node id="Stanford, CA, USA"/>
<node id="1997"/>
<node id="Dr. Benini"/>
<node id="the ACM"/>
<node id="the Academia Europaea"/>
<edge source="Processors" target="the open RISC-V instruction set architecture (ISA)">
  <data key="d0">use</data>
</edge>
<edge source="Processors using the open RISC-V instruction set architecture (ISA)" target="increasing adoption in the embedded world">
  <data key="d0">are finding</data>
</edge>
<edge source="Robert Balas" target="graduate student member, IEEE">
  <data key="d0">is</data>
</edge>
<edge source="Robert Balas" target="Integrated Systems Laboratory (IIS), ETH Zurich, 8092 Zurich, Switzerland">
  <data key="d0">is with</data>
</edge>
<edge source="Robert Balas" target="balas@iis.ee.ethz.ch">
  <data key="d0">email</data>
</edge>
<edge source="Robert Balas" target="the B.Sc.">
  <data key="d0">received</data>
</edge>
<edge source="Alessandro Ottaviano" target="graduate student member, IEEE">
  <data key="d0">is</data>
</edge>
<edge source="Alessandro Ottaviano" target="Integrated Systems Laboratory (IIS), ETH Zurich, 8092 Zurich, Switzerland">
  <data key="d0">is with</data>
</edge>
<edge source="Alessandro Ottaviano" target="aottaviano@iis.ee.ethz.ch">
  <data key="d0">email</data>
</edge>
<edge source="Alessandro Ottaviano" target="the B.Sc.">
  <data key="d0">received</data>
</edge>
<edge source="Luca Benini" target="fellow, IEEE">
  <data key="d0">is</data>
</edge>
<edge source="Luca Benini" target="the Integrated Systems Laboratory (IIS), ETH Zurich, Zurich, Switzerland">
  <data key="d0">is with</data>
</edge>
<edge source="Luca Benini" target="the Department of Electrical, Electronic and Information Engineering (DEI), University of Bologna, 40126 Bologna, Italy">
  <data key="d0">is with</data>
</edge>
<edge source="We" target="a CLIC for the CV32E40P">
  <data key="d0">implement</data>
</edge>
<edge source="We" target="CV32E40P with FastIRQ">
  <data key="d0">enhance</data>
</edge>
<edge source="We" target="the CV32E40P interrupt controller with an implementation of the RISC-V CLIC specification">
  <data key="d0">replace</data>
</edge>
<edge source="We" target="a brief overview of the full-system platform used to design and implement the proposed interrupt extension in Section II-A">
  <data key="d0">give</data>
</edge>
<edge source="We" target="the relevant target metrics in Section II-B3">
  <data key="d0">motivate and explain</data>
</edge>
<edge source="We" target="the current status of interrupt handling in RISC-V in Section II-C">
  <data key="d0">describe</data>
</edge>
<edge source="We" target="FASTIRQ, a fast interrupt extension for RISC-V embedded systems">
  <data key="d0">present</data>
</edge>
<edge source="We" target="CV32RT within an open-source system on chip (SoC)">
  <data key="d0">integrate</data>
</edge>
<edge source="We" target="CV32RT interrupt handling capabilities">
  <data key="d0">evaluate</data>
</edge>
<edge source="We" target="the implementation under a permissive open-source license">
  <data key="d0">make available</data>
</edge>
<edge source="We" target="a fast interrupt extension (FASTIRQ)">
  <data key="d0">design</data>
</edge>
<edge source="We" target="Early MRET (EMRET)">
  <data key="d0">propose</data>
</edge>
<edge source="We" target="CV32RT with leading COTS systems in both nested and non-nested interrupt scenarios">
  <data key="d0">compare</data>
</edge>
<edge source="We" target="interrupt latency and context switch times">
  <data key="d0">can improve</data>
</edge>
<edge source="We" target="the RF by an additional read port for the background-saving mechanism">
  <data key="d0">extend</data>
</edge>
<edge source="We" target="registers for latching the additional processor state required for proper interrupt nesting">
  <data key="d0">extend</data>
</edge>
<edge source="We" target="this mechanism for leaf-type interrupts">
  <data key="d0">could do away with</data>
</edge>
<edge source="We" target="an SW-based solution that does not cause any kind of stalling">
  <data key="d0">propose</data>
</edge>
<edge source="We" target="this scenario">
  <data key="d0">address</data>
</edge>
<edge source="We" target="interrupt latency">
  <data key="d0">minimize</data>
</edge>
<edge source="We" target="latency">
  <data key="d0">hide</data>
</edge>
<edge source="We" target="the EABI of RISC-V">
  <data key="d0">evaluate</data>
</edge>
<edge source="We" target="the regular integer ABI of RISC-V">
  <data key="d0">evaluate</data>
</edge>
<edge source="We" target="configurations that do not have Fig">
  <data key="d0">left out</data>
</edge>
<edge source="We" target="CV32RT as part of the ControlPULP platform">
  <data key="d0">synthesize</data>
</edge>
<edge source="We" target="existing PLICs and CLICs">
  <data key="d0">differentiate between</data>
</edge>
<edge source="We" target="the latter">
  <data key="d0">focus on</data>
</edge>
<edge source="We" target="solutions across various platforms in industry and academia">
  <data key="d0">discuss</data>
</edge>
<edge source="We" target="task context switch times in FreeRTOS to 104 clock cycles using FastIRQ">
  <data key="d0">improve</data>
</edge>
<edge source="CV32E40P" target="an industrially supported open-source 32-bit microcontroller unit (MCU)-class RISC-V core">
  <data key="d0">is</data>
</edge>
<edge source="CV32E40P" target="an industrially supported open-source core">
  <data key="d0">is</data>
</edge>
<edge source="CV32E40P" target="HTTPS">
  <data key="d0">is available at</data>
</edge>
<edge source="FastIRQ" target="a custom extension">
  <data key="d0">is</data>
</edge>
<edge source="FastIRQ" target="interrupt latency as low as six cycles">
  <data key="d0">provides</data>
</edge>
<edge source="FastIRQ" target="20 times faster than an SW-only approach">
  <data key="d0">is</data>
</edge>
<edge source="CV32RT" target="a 32-bit RISC-V core">
  <data key="d0">is</data>
</edge>
<edge source="CV32RT" target="the interrupt handling capabilities of CV32E40P">
  <data key="d0">extends</data>
</edge>
<edge source="CV32RT" target="best-in-class interrupt latency">
  <data key="d0">achieves</data>
</edge>
<edge source="CV32RT" target="fast context switching">
  <data key="d0">achieves</data>
</edge>
<edge source="CV32RT" target="commercial off-the-shelf (COTS) processor vendors">
  <data key="d0">competes against</data>
</edge>
<edge source="CV32RT" target="RISC-V architectures in time-critical systems">
  <data key="d0">paves the road for</data>
</edge>
<edge source="CV32RT" target="a 32-bit, in-order, single-issue core">
  <data key="d0">is</data>
</edge>
<edge source="CV32RT" target="the RISC-V CLIC fast interrupt controller">
  <data key="d0">is designed with</data>
</edge>
<edge source="CV32RT" target="the first fully open-source RV32 core with competitive interrupt-handling features compared to the ARM Cortex-M series and TriCore">
  <data key="d0">is</data>
</edge>
<edge source="CV32RT" target="fast interrupt and context switching">
  <data key="d0">enables</data>
</edge>
<edge source="CV32RT" target="fast interrupt and context switching 1043 instruction in machine mode (i.e., EMRET)">
  <data key="d0">enables</data>
</edge>
<edge source="CV32RT" target="architectural features and HWSW codesign">
  <data key="d0">has</data>
</edge>
<edge source="CV32RT" target="two main configurations">
  <data key="d0">has</data>
</edge>
<edge source="fast context switching" target="architectures such as superscalar central processing units (CPUs)">
  <data key="d0">is often required in</data>
</edge>
<edge source="fast context switching" target="graphic processing units (GPUs)">
  <data key="d0">is often required to hide latency in</data>
</edge>
<edge source="The RISC-V CLIC specification" target="the core with key features">
  <data key="d0">provides</data>
</edge>
<edge source="Key features" target="prioritization by level and priority">
  <data key="d0">include</data>
</edge>
<edge source="Key features" target="selective hardware vectoring (SHV)">
  <data key="d0">include</data>
</edge>
<edge source="Key features" target="non-nested interrupt optimization tail-chaining through the XNXTI 15 control and status register (CSR)">
  <data key="d0">include</data>
</edge>
<edge source="XNXTI 15 control and status register (CSR)" target="directly a RISC-V standard extension">
  <data key="d0">is</data>
</edge>
<edge source="RISC-V system platform" target="the CV32E40P core">
  <data key="d0">relies on</data>
</edge>
<edge source="CV32E40P core" target="CV32">
  <data key="d0">is abbreviated to</data>
</edge>
<edge source="CV32E40P core" target="an open-source, industry-grade, 32-bit, in-order, four-stage RISC-V core">
  <data key="d0">is</data>
</edge>
<edge source="CV32E40P core" target="the basis for implementing our extensions">
  <data key="d0">is used as</data>
</edge>
<edge source="CV32" target="interrupt handling capabilities">
  <data key="d0">has</data>
</edge>
<edge source="CV32 core" target="the baseline">
  <data key="d0">is</data>
</edge>
<edge source="native CLINT interrupt controller" target="CLIC">
  <data key="d0">is replaced with</data>
</edge>
<edge source="CLIC" target="CV32RTCLIC">
  <data key="d0">is referred to as</data>
</edge>
<edge source="CLIC" target="about 33 cycles interrupt latency">
  <data key="d0">have</data>
</edge>
<edge source="CV32RTCLIC" target="CLIC interrupt controller">
  <data key="d0">implements</data>
</edge>
<edge source="FASTIRQ" target="core microarchitecture">
  <data key="d0">is introduced into</data>
</edge>
<edge source="FASTIRQ" target="this work">
  <data key="d0">is the extension proposed in</data>
</edge>
<edge source="FASTIRQ" target="CV32RTFASTIRQ">
  <data key="d0">is referred to as</data>
</edge>
<edge source="FASTIRQ" target="both nested and non-nested interrupt case scenarios">
  <data key="d0">accelerates</data>
</edge>
<edge source="FASTIRQ" target="interrupt latency">
  <data key="d0">reduces</data>
</edge>
<edge source="FASTIRQ" target="hiding the latency through memory banks and a background-saving mechanism">
  <data key="d0">reduces interrupt latency by</data>
</edge>
<edge source="FASTIRQ" target="that">
  <data key="d0">improves upon</data>
</edge>
<edge source="FASTIRQ" target="moving the interrupt state saving logic in HW">
  <data key="d0">improves upon that by</data>
</edge>
<edge source="FASTIRQ" target="adding EMRET to handle redundant interrupt context sequences">
  <data key="d0">improves upon that by</data>
</edge>
<edge source="FASTIRQ" target="a wrapper around the cores RF">
  <data key="d0">is</data>
</edge>
<edge source="FASTIRQ" target="us to skip ahead the saving of the general-purpose registers">
  <data key="d0">allows</data>
</edge>
<edge source="FASTIRQ" target="an SW interrupt as part of the save sequence">
  <data key="d0">triggers</data>
</edge>
<edge source="CV32RTFASTIRQ" target="interrupt latency in the non-nested interrupt case">
  <data key="d0">optimizes</data>
</edge>
<edge source="CV32RTFASTIRQ" target="interrupt latency in the nested interrupt case">
  <data key="d0">optimizes</data>
</edge>
<edge source="CV32RTFASTIRQ" target="bank switching and the nested interrupt case with an automatic context-saving mechanism in the background">
  <data key="d0">combines</data>
</edge>
<edge source="CV32RTFASTIRQ" target="FAST INTERRUPT EXTENSION">
  <data key="d0">is</data>
</edge>
<edge source="CV32RTFASTIRQ" target="automatic hardware context saving and bank switching">
  <data key="d0">has</data>
</edge>
<edge source="CV32RTFASTIRQ" target="a 10 overall area increase compared to baseline CLIC only">
  <data key="d0">incurs</data>
</edge>
<edge source="CLIC interrupt controller" target="CV32RTCLIC">
  <data key="d0">is implemented in</data>
</edge>
<edge source="CLIC interrupt controller" target="draft specification">
  <data key="d0">is according to</data>
</edge>
<edge source="draft specification" target="RISC-V privileged specification">
  <data key="d0">is to be included in</data>
</edge>
<edge source="Our proposed FastIRQ extension" target="weaknesses of various flavors of RISC-V core-specific interrupt controllers">
  <data key="d0">addresses</data>
</edge>
<edge source="Our proposed FastIRQ extension" target="the CLIC base capabilities">
  <data key="d0">extends</data>
</edge>
<edge source="Our proposed FastIRQ extension" target="a mechanism to lower interrupt latency">
  <data key="d0">provides</data>
</edge>
<edge source="Our proposed FastIRQ extension" target="HW vectored interrupts">
  <data key="d0">keeps</data>
</edge>
<edge source="Our proposed FastIRQ extension" target="skipping of redundant context restore operations">
  <data key="d0">allows</data>
</edge>
<edge source="the extension" target="CV32RT">
  <data key="d0">is implemented on</data>
</edge>
<edge source="27 B. MAO, N. TAN, T. CHONG, AND L. LI" target="A CLIC EXTENSION BASED FAST INTERRUPT SYSTEM FOR EMBEDDED RISC-V PROCESSORS">
  <data key="d0">authored</data>
</edge>
<edge source="A CLIC EXTENSION BASED FAST INTERRUPT SYSTEM FOR EMBEDDED RISC-V PROCESSORS" target="PROC.">
  <data key="d0">published in</data>
</edge>
<edge source="Many embedded use cases" target="real-time constraints">
  <data key="d0">have</data>
</edge>
<edge source="Many embedded use cases" target="flexible, predictable, and fast reactive handling of incoming events">
  <data key="d0">require</data>
</edge>
<edge source="RISC-V processors" target="this area">
  <data key="d0">are lagging in</data>
</edge>
<edge source="RISC-V processors" target="more mature proprietary architectures">
  <data key="d0">are lagging compared to</data>
</edge>
<edge source="more mature proprietary architectures" target="ARM Cortex-M and TriCore">
  <data key="d0">include</data>
</edge>
<edge source="ARM Cortex-M and TriCore" target="tuned for years">
  <data key="d0">have been</data>
</edge>
<edge source="THE DEFAULT INTERRUPT CONTROLLER" target="RISC-V">
  <data key="d0">is standardized by</data>
</edge>
<edge source="THE DEFAULT INTERRUPT CONTROLLER" target="THE CORE LOCAL INTERRUPTOR (CLINT)">
  <data key="d0">is called</data>
</edge>
<edge source="RISC-V" target="the XNXTI CSR with SW-managed interrupt service loops as part of the CLIC specifications">
  <data key="d0">adds</data>
</edge>
<edge source="RISC-V" target="early commercial examples with 31">
  <data key="d0">finds</data>
</edge>
<edge source="THE CORE LOCAL INTERRUPTOR (CLINT)" target="configurability in prioritization and preemption of interrupts">
  <data key="d0">lacks</data>
</edge>
<edge source="The RISC-V community" target="an extension to the privileged specifications 14">
  <data key="d0">has been developing</data>
</edge>
<edge source="The extension to the privileged specifications 14" target="the RISC-V Core Local Interrupt Controller (CLIC) 15">
  <data key="d0">is</data>
</edge>
<edge source="The RISC-V Core Local Interrupt Controller (CLIC) 15" target="currently under ratification by the community">
  <data key="d0">is</data>
</edge>
<edge source="The RISC-V Core Local Interrupt Controller (CLIC) 15" target="real-time scenarios">
  <data key="d0">is developed to handle</data>
</edge>
<edge source="CLICS" target="local to each hardware thread (HART)">
  <data key="d0">are</data>
</edge>
<edge source="PLICS" target="platform level interrupt controllers">
  <data key="d0">are</data>
</edge>
<edge source="PLICS" target="centralized interrupt controllers">
  <data key="d0">are</data>
</edge>
<edge source="PLICS" target="managing multiple HARTs">
  <data key="d0">are capable of</data>
</edge>
<edge source="Platform-level interrupt controllers" target="RISC-V PLIC">
  <data key="d0">include</data>
</edge>
<edge source="Platform-level interrupt controllers" target="Advanced PLIC (APLIC)">
  <data key="d0">include</data>
</edge>
<edge source="Platform-level interrupt controllers" target="RISC-V Incoming Message Signaled Interrupt Controller (IMSIC)">
  <data key="d0">include</data>
</edge>
<edge source="Platform-level interrupt controllers" target="distribute time-critical interrupts to the running harts">
  <data key="d0">are not designed to</data>
</edge>
<edge source="RISC-V Incoming Message Signaled Interrupt Controller (IMSIC)" target="message-signaled interrupt communication">
  <data key="d0">is used for</data>
</edge>
<edge source="RISC-V PLIC and Advanced PLIC (APLIC)" target="wire-based interrupt communication">
  <data key="d0">are used for</data>
</edge>
<edge source="B. CORE-LOCAL INTERRUPT CONTROLLERS (CLICS)" target="providing fast interrupt-handling capabilities in real-time embedded application domains">
  <data key="d0">are specialized in</data>
</edge>
<edge source="WE" target="CV32RT OUR ENHANCED CORE">
  <data key="d0">call</data>
</edge>
<edge source="WE" target="A LOAD SOON IN THE INTERRUPT HANDLER">
  <data key="d0">want to issue</data>
</edge>
<edge source="WE" target="the HW contributed interrupt latency of our FastIRQ extension">
  <data key="d0">measure</data>
</edge>
<edge source="WE" target="the HW contributed interrupt latency of our FastIRQ extension to the CV32 and CV32RT variations">
  <data key="d0">compare</data>
</edge>
<edge source="The extension" target="negligible area overhead in a modern technology node">
  <data key="d0">introduces</data>
</edge>
<edge source="The extension" target="performance benefits">
  <data key="d0">provides</data>
</edge>
<edge source="various CV32RT versions" target="interrupt latency and context switch times">
  <data key="d0">perform in terms of</data>
</edge>
<edge source="these additions" target="overhead in terms of area and timing">
  <data key="d0">incur</data>
</edge>
<edge source="THE PROPOSED EXTENSIONS" target="TASK CONTEXT SWITCHING IN REAL-TIME OPERATING SYSTEMS (RTOSS)">
  <data key="d0">are demonstrated to improve</data>
</edge>
<edge source="INDEX TERMS" target="CONTEXT SWITCHING">
  <data key="d0">include</data>
</edge>
<edge source="INDEX TERMS" target="EMBEDDED">
  <data key="d0">include</data>
</edge>
<edge source="INDEX TERMS" target="INTERRUPT LATENCY">
  <data key="d0">include</data>
</edge>
<edge source="INDEX TERMS" target="MICROCONTROLLER UNIT (MCU)">
  <data key="d0">include</data>
</edge>
<edge source="INDEX TERMS" target="REAL-TIME">
  <data key="d0">include</data>
</edge>
<edge source="INDEX TERMS" target="RISC-V">
  <data key="d0">include</data>
</edge>
<edge source="INTERRUPT LATENCY" target="SW-dependent contributions">
  <data key="d0">is broken down into</data>
</edge>
<edge source="INTERRUPT LATENCY" target="HW-dependent contributions">
  <data key="d0">is broken down into</data>
</edge>
<edge source="Several markets" target="real-time AN SW-based solution">
  <data key="d0">rely on</data>
</edge>
<edge source="The automotive industry" target="hundreds of electronic control units (ECUs)">
  <data key="d0">employs</data>
</edge>
<edge source="Electronic control units (ECUs)" target="real-time applications">
  <data key="d0">are used for</data>
</edge>
<edge source="Real-time applications" target="electronic engine control">
  <data key="d0">include</data>
</edge>
<edge source="Real-time applications" target="gearbox control">
  <data key="d0">include</data>
</edge>
<edge source="Real-time applications" target="cruise control">
  <data key="d0">include</data>
</edge>
<edge source="Real-time applications" target="anti-lock brake systems">
  <data key="d0">include</data>
</edge>
<edge source="Real-time applications" target="many other tasks">
  <data key="d0">include</data>
</edge>
<edge source="General-purpose operating systems (GPOSS)" target="average throughput">
  <data key="d0">are typically tuned for</data>
</edge>
<edge source="DATE OF PUBLICATION" target="21 MARCH 2024">
  <data key="d0">is</data>
</edge>
<edge source="DATE OF CURRENT VERSION" target="23 MAY 2024">
  <data key="d0">is</data>
</edge>
<edge source="THIS WORK" target="THE HORIZON KEY DIGITAL TECHNOLOGIES JOINT UNDERTAKING (KDT JU) PROGRAMME">
  <data key="d0">was supported in part by</data>
</edge>
<edge source="THIS WORK" target="N 4096 LOCAL INTERRUPT SOURCES">
  <data key="d0">can scale up to</data>
</edge>
<edge source="THIS WORK" target="a combination of the background-saving with a register banking approach">
  <data key="d0">proposes</data>
</edge>
<edge source="THE HORIZON KEY DIGITAL TECHNOLOGIES JOINT UNDERTAKING (KDT JU) PROGRAMME" target="THE TRISTAN PROJECT">
  <data key="d0">supported through</data>
</edge>
<edge source="THE TRISTAN PROJECT" target="101095947">
  <data key="d0">was under grant</data>
</edge>
<edge source="color versions of one or more figures in this article" target="https://doi.org/10.1109/TVLSI.2024.3377130">
  <data key="d0">are available at</data>
</edge>
<edge source="DIGITAL OBJECT IDENTIFIER" target="10.1109TVLSI.2024.3377130">
  <data key="d0">is</data>
</edge>
<edge source="The development of Linux" target="average performance">
  <data key="d0">is focused on</data>
</edge>
<edge source="Linux" target="a popular open-source GPOS kernel">
  <data key="d0">is</data>
</edge>
<edge source="Linux" target="real-time applications">
  <data key="d0">is less suitable to be used for</data>
</edge>
<edge source="Extensions and modifications" target="improving determinism and latencies of critical operations in Linux">
  <data key="d0">aim at</data>
</edge>
<edge source="Extensions and modifications" target="proposed and implemented">
  <data key="d0">have been</data>
</edge>
<edge source="Extensions and modifications" target="strict bounds on maximum latencies of operations">
  <data key="d0">do not guarantee</data>
</edge>
<edge source="Extensions and modifications" target="industry-grade maturity to be employed in hard real-time scenarios">
  <data key="d0">lack</data>
</edge>
<edge source="REAL-TIME OPERATING SYSTEMS (RTOSS) KERNELS" target="special-purpose operating systems (OSS)">
  <data key="d0">are</data>
</edge>
<edge source="REAL-TIME OPERATING SYSTEMS (RTOSS) KERNELS" target="real-time guarantees">
  <data key="d0">are designed to provide</data>
</edge>
<edge source="real-time guarantees" target="task scheduling according to a given expected completion deadline">
  <data key="d0">include</data>
</edge>
<edge source="real-time guarantees" target="deterministic latencies of various operations">
  <data key="d0">include</data>
</edge>
<edge source="A. STANKOVIC" target="SCHEDULING ALGORITHMS AND OPERATING SYSTEMS SUPPORT FOR REAL-TIME SYSTEMS">
  <data key="d0">authored</data>
</edge>
<edge source="SCHEDULING ALGORITHMS AND OPERATING SYSTEMS SUPPORT FOR REAL-TIME SYSTEMS" target="PROC.">
  <data key="d0">published in</data>
</edge>
<edge source="The RTOS scheduler" target="a significant overhead">
  <data key="d0">might add</data>
</edge>
<edge source="The significant overhead" target="the combined effect of both the context switches required to handle the transition from a foreground to a background task and the amount of time elapsed from the source event that causes the preemption and the first instruction of the awakened task">
  <data key="d0">is due to</data>
</edge>
<edge source="The significant overhead" target="the worst case execution time (WCET)">
  <data key="d0">thus increases</data>
</edge>
<edge source="The amount of time elapsed from the source event that causes the preemption and the first instruction of the awakened task" target="interrupt latency">
  <data key="d0">is known as</data>
</edge>
<edge source="interrupt latency" target="its HW-contributed part">
  <data key="d0">means</data>
</edge>
<edge source="interrupt latency" target="the number of cycles it takes for an interrupt to arrive at the interrupt controller input to the first instruction of an interrupt handler that allows the calling of a C-function">
  <data key="d0">is measured as</data>
</edge>
<edge source="The cost of saving and restoring the task state during a context switch" target="a significant concern">
  <data key="d0">is</data>
</edge>
<edge source="The cost of saving and restoring the task state during a context switch" target="relatively high">
  <data key="d0">remains</data>
</edge>
<edge source="LONG CONTEXT SWITCH TIMES" target="AVAILABLE TASK UTILIZATION">
  <data key="d0">reduce</data>
</edge>
<edge source="LONG CONTEXT SWITCH TIMES" target="THE MINIMUM VIABLE SWITCHING GRANULARITY">
  <data key="d0">reduce</data>
</edge>
<edge source="process state" target="context switch">
  <data key="d0">needs to be saved on</data>
</edge>
<edge source="process state" target="program counter">
  <data key="d0">includes</data>
</edge>
<edge source="process state" target="register files (RFs)">
  <data key="d0">includes</data>
</edge>
<edge source="process state" target="status registers">
  <data key="d0">includes</data>
</edge>
<edge source="process state" target="address space mapping">
  <data key="d0">includes</data>
</edge>
<edge source="A significant number of memory access operations" target="to store the state of the preempted task">
  <data key="d0">need to be performed</data>
</edge>
<edge source="A significant number of memory access operations" target="to restore the state of the new task to be executed">
  <data key="d0">need to be performed</data>
</edge>
<edge source="a switch into an interrupt context from normal program execution" target="an asynchronous event is triggered from an IO peripheral device">
  <data key="d0">happens each time</data>
</edge>
<edge source="high overhead generated by the receiving of packets" target="continuous floods">
  <data key="d0">can be seen in</data>
</edge>
<edge source="high overhead generated by the receiving of packets" target="short transmission bursts">
  <data key="d0">can be seen in</data>
</edge>
<edge source="high overhead generated by the receiving of packets" target="50 task lateness">
  <data key="d0">reaches up to</data>
</edge>
<edge source="task lateness" target="the additional time a task takes to finish than its deadline allows">
  <data key="d0">is</data>
</edge>
<edge source="task lateness" target="iterations from the critical network load increase per packet per second">
  <data key="d0">will start to accumulate over</data>
</edge>
<edge source="HW-induced interrupt latency" target="only one part of the problem">
  <data key="d0">is</data>
</edge>
<edge source="SW-induced interrupt latency" target="part of the problem">
  <data key="d0">is</data>
</edge>
<edge source="Personal use" target="permitted">
  <data key="d0">is</data>
</edge>
<edge source="Republication redistribution" target="IEEE permission">
  <data key="d0">requires</data>
</edge>
<edge source="AUTHORIZED LICENSED USE" target="CALIFORNIA POLYTECHNIC STATE UNIVERSITY SAN LUIS OBISPO">
  <data key="d0">is limited to</data>
</edge>
<edge source="THE CLIC DESIGN" target="CALIFORNIA POLYTECHNIC STATE UNIVERSITY SAN LUIS OBISPO">
  <data key="d0">proposed in authorized licensed use limited to</data>
</edge>
<edge source="interrupt state" target="this">
  <data key="d0">gets pushed</data>
</edge>
<edge source="The latter" target="the execution time of the authorized licensed use limited to California Polytechnic State University San Luis Obispo">
  <data key="d0">reduces</data>
</edge>
<edge source="document" target="May 28, 2025 at 17:50:39 UTC">
  <data key="d0">was downloaded on</data>
</edge>
<edge source="document" target="IEEE Xplore">
  <data key="d0">was downloaded from</data>
</edge>
<edge source="fast interrupt and context switching" target="the GPOSRTOS scheduler and the user code">
  <data key="d0">is introduced by</data>
</edge>
<edge source="fast interrupt and context switching" target="the capability of the system to provide timely responses to asynchronous events">
  <data key="d0">primarily impacts</data>
</edge>
<edge source="Table I" target="nested interrupt preemption scheme according to RISC-V CLIC">
  <data key="d0">describes</data>
</edge>
<edge source="block diagram" target="CV32RTFASTIRQ">
  <data key="d0">of</data>
</edge>
<edge source="pointer" target="appropriately before triggering an SW interrupt">
  <data key="d0">is set</data>
</edge>
<edge source="SW interrupt" target="write to CLICS memory map">
  <data key="d0">is triggered by</data>
</edge>
<edge source="EMRET" target="skip redundant context saving and restoring sequences">
  <data key="d0">is able to</data>
</edge>
<edge source="EMRET" target="directly jumping to the next available interrupt handler">
  <data key="d0">achieves this by</data>
</edge>
<edge source="EMRET" target="to differentiate between a regular return from an interrupt handler using MRET">
  <data key="d0">is added</data>
</edge>
<edge source="Low interrupt latency and context switch time" target="crucial metrics">
  <data key="d0">are</data>
</edge>
<edge source="Crucial metrics" target="a wide range of platforms">
  <data key="d0">apply to</data>
</edge>
<edge source="Platforms" target="commodity MCU-class embedded systems to more advanced and complex application-class mixed criticality systems (MCSS)">
  <data key="d0">range from</data>
</edge>
<edge source="Timesafety-critical and non-critical applications" target="different isolated partitions of the same HW platform">
  <data key="d0">coexist on</data>
</edge>
<edge source="response and context switch time minimization" target="a challenge to be tackled at the HWSW interface">
  <data key="d0">become</data>
</edge>
<edge source="SW programming techniques and HW interrupt controller architectures" target="to ensure minimal response time">
  <data key="d0">can cooperate</data>
</edge>
<edge source="commercial vendors and IP providers" target="such features as in-house solutions">
  <data key="d0">offer</data>
</edge>
<edge source="such features as in-house solutions" target="often proprietary">
  <data key="d0">are</data>
</edge>
<edge source="such features as in-house solutions" target="tightly coupled with the vendors instruction set architecture (ISA), target HW family, and associated SW stack">
  <data key="d0">are</data>
</edge>
<edge source="RISC-V ecosystem" target="a modular, free, and open-source ISA">
  <data key="d0">has been offering</data>
</edge>
<edge source="RISC-V ecosystem" target="the de facto lingua franca of computing">
  <data key="d0">is becoming</data>
</edge>
<edge source="RISC-V support for fast interrupt and context switch handling" target="incumbent proprietary architectures">
  <data key="d0">is not mature enough to compete with</data>
</edge>
<edge source="RISC-V support for fast interrupt and context switch handling" target="flexible interrupt prioritization">
  <data key="d0">lacks</data>
</edge>
<edge source="RISC-V support for fast interrupt and context switch handling" target="preemption mechanisms">
  <data key="d0">lacks</data>
</edge>
<edge source="RISC-V support for fast interrupt and context switch handling" target="low interrupt latency">
  <data key="d0">lacks</data>
</edge>
<edge source="interrupt handlers" target="nesting">
  <data key="d0">support</data>
</edge>
<edge source="interrupt handlers" target="calling of C-functions within it">
  <data key="d0">support</data>
</edge>
<edge source="calling of C-functions within interrupt handlers" target="saving and restoring state following the C-ABI">
  <data key="d0">involves</data>
</edge>
<edge source="various flavors of RISC-V core-specific interrupt controllers" target="interrupt latency">
  <data key="d0">have</data>
</edge>
<edge source="our design" target="interrupt latencies of six clock cycles">
  <data key="d0">can achieve</data>
</edge>
<edge source="our design" target="efficient back-to-back interrupt handling in 12 cycles">
  <data key="d0">can achieve</data>
</edge>
<edge source="interrupt latencies of six clock cycles and efficient back-to-back interrupt handling in 12 cycles" target="the fastest available approaches currently implemented in the RISC-V landscape">
  <data key="d0">is as low as</data>
</edge>
<edge source="the fastest available approaches currently implemented in the RISC-V landscape" target="fully open-source">
  <data key="d0">are</data>
</edge>
<edge source="the fastest available approaches currently implemented in the RISC-V landscape" target="competitive against closed-source and proprietary commercial solutions">
  <data key="d0">are</data>
</edge>
<edge source="CLINT" target="about 33 cycles interrupt latency">
  <data key="d0">have</data>
</edge>
<edge source="CLINT" target="the first standardized RISC-V interrupt controller">
  <data key="d0">is</data>
</edge>
<edge source="FASTIRQ extension" target="six cycles">
  <data key="d0">is able to reduce interrupt latency to</data>
</edge>
<edge source="THE SAME MECHANISM" target="one to accelerate context switching through HWSW cooperation">
  <data key="d0">allows</data>
</edge>
<edge source="Early MRET (EMRET)" target="a novel instruction">
  <data key="d0">is</data>
</edge>
<edge source="Early MRET (EMRET)" target="tail-chaining">
  <data key="d0">optimizes</data>
</edge>
<edge source="Early MRET (EMRET)" target="the baseline strategy proposed in the CLIC standard (i.e., XNXTI)">
  <data key="d0">optimizes tail-chaining compared to</data>
</edge>
<edge source="Early MRET (EMRET)" target="its enhancement from 18 (JALXNXTI)">
  <data key="d0">optimizes tail-chaining compared to</data>
</edge>
<edge source="THE PROPOSED SOLUTION" target="RISC-V AS A COMPETITIVE CANDIDATE FOR BUILDING THE NEXT GENERATION OF TIME-CRITICAL SYSTEMS">
  <data key="d0">PROMOTES</data>
</edge>
<edge source="THIS CORE" target="CONTROLPULP 19">
  <data key="d0">is embedded in</data>
</edge>
<edge source="CONTROLPULP 19" target="a SoC specialized in running real-time workloads">
  <data key="d0">is</data>
</edge>
<edge source="The manager core" target="scheduling tasks">
  <data key="d0">is responsible for</data>
</edge>
<edge source="The manager core" target="communicating with the peripherals">
  <data key="d0">is responsible for</data>
</edge>
<edge source="The manager core" target="offloading tasks to the accelerator subsystem">
  <data key="d0">is responsible for</data>
</edge>
<edge source="The manager core" target="being responsive to asynchronous external events">
  <data key="d0">is responsible for</data>
</edge>
<edge source="asynchronous external events" target="interrupts">
  <data key="d0">include</data>
</edge>
<edge source="interrupts" target="sequentially">
  <data key="d0">are served</data>
</edge>
<edge source="interrupts" target="globally within the scope of an executing ISR">
  <data key="d0">are enabled</data>
</edge>
<edge source="interrupts" target="below the threshold">
  <data key="d0">are disabled</data>
</edge>
<edge source="interrupts" target="a priority">
  <data key="d0">can be assigned</data>
</edge>
<edge source="interrupts" target="a level">
  <data key="d0">can be assigned</data>
</edge>
<edge source="interrupts" target="the gateway">
  <data key="d0">arrive at</data>
</edge>
<edge source="interrupts" target="programmable configuration information">
  <data key="d0">are combined with</data>
</edge>
<edge source="CONTROLPULP" target="a set of scratchpad memories (SPMs)">
  <data key="d0">hosts</data>
</edge>
<edge source="scratchpad memories (SPMs)" target="single-cycle access time from the CV32 manager core">
  <data key="d0">guarantee</data>
</edge>
<edge source="this design choice" target="deterministic memory access latency for both data load, store, and instruction fetch">
  <data key="d0">enables</data>
</edge>
<edge source="this design choice" target="the worst case latency when handling unpredictable events">
  <data key="d0">bounds</data>
</edge>
<edge source="Applications" target="FreeRTOS 20">
  <data key="d0">run on top of</data>
</edge>
<edge source="FreeRTOS 20" target="an open-source, priority-based preemptive RTOS">
  <data key="d0">is</data>
</edge>
<edge source="FreeRTOS 20" target="the manager core">
  <data key="d0">runs in</data>
</edge>
<edge source="Tasks" target="the manager core">
  <data key="d0">are scheduled and run from</data>
</edge>
<edge source="interrupt sources" target="interrupts">
  <data key="d0">can signal</data>
</edge>
<edge source="interrupt sources" target="a level change of the interrupt line">
  <data key="d0">signal interrupts through</data>
</edge>
<edge source="interrupt sources" target="the logic level itself">
  <data key="d0">signal interrupts through</data>
</edge>
<edge source="a level change of the interrupt line" target="an edge-triggered interrupt">
  <data key="d0">is called</data>
</edge>
<edge source="the logic level itself" target="a level-triggered interrupt">
  <data key="d0">is called</data>
</edge>
<edge source="nested interrupts" target="preemption of a low-level interrupt by a high-level interrupt">
  <data key="d0">entails</data>
</edge>
<edge source="Transition" target="different interrupt levels">
  <data key="d0">is between</data>
</edge>
<edge source="the latter" target="the receiving side of the interrupt to clear the source often through accessing appropriate HW registers">
  <data key="d0">requires</data>
</edge>
<edge source="the former" target="unidirectional notification without confirmation">
  <data key="d0">is</data>
</edge>
<edge source="Interrupts" target="asynchronous events">
  <data key="d0">are</data>
</edge>
<edge source="Interrupts" target="the normal program order execution">
  <data key="d0">alter</data>
</edge>
<edge source="Interrupts" target="a switch to a different context to handle the event">
  <data key="d0">require</data>
</edge>
<edge source="Interrupts" target="the execution of an ISR">
  <data key="d0">are globally disabled during</data>
</edge>
<edge source="Interrupts" target="the pipeline">
  <data key="d0">are injected into</data>
</edge>
<edge source="Interrupts" target="the write-back stage of the core">
  <data key="d0">are only acted upon in</data>
</edge>
<edge source="A processor" target="vectored interrupts">
  <data key="d0">supports</data>
</edge>
<edge source="Each interrupt" target="a specific interrupt service routine (ISR)">
  <data key="d0">traps to</data>
</edge>
<edge source="Trapping to a specific ISR" target="an interrupt vector table">
  <data key="d0">is according to</data>
</edge>
<edge source="Vectored interrupts" target="fast interrupt response">
  <data key="d0">grant</data>
</edge>
<edge source="Vectored interrupts" target="increased code size">
  <data key="d0">have</data>
</edge>
<edge source="interrupt vectoring" target="to improve interrupt latencies">
  <data key="d0">is supported</data>
</edge>
<edge source="NON-VECTORED OR DIRECT INTERRUPTS" target="a SHARED ISR">
  <data key="d0">trap to</data>
</edge>
<edge source="THE LATTER APPROACH" target="code size for a slower interrupt response">
  <data key="d0">trades off</data>
</edge>
<edge source="the overhead of resolving the interruption cause and jumping to the correct ISR" target="explicit instructions">
  <data key="d0">are handled in</data>
</edge>
<edge source="the interrupt table" target="much more compact">
  <data key="d0">can be made</data>
</edge>
<edge source="multiple sources" target="interrupt latency in a system">
  <data key="d0">determine</data>
</edge>
<edge source="underlying HW" target="interrupt latency">
  <data key="d0">is a source of</data>
</edge>
<edge source="scheduler or OS" target="interrupt latency">
  <data key="d0">is a source of</data>
</edge>
<edge source="application running on top" target="interrupt latency">
  <data key="d0">is a source of</data>
</edge>
<edge source="we" target="minimizing the latency imposed by the HW">
  <data key="d0">focus on</data>
</edge>
<edge source="we" target="what exactly constitutes the first instruction of the interrupt handler">
  <data key="d0">have to delineate</data>
</edge>
<edge source="we" target="the stack pointer during a bank switch">
  <data key="d0">need to update</data>
</edge>
<edge source="we" target="a dedicated adder between the two RFs">
  <data key="d0">have</data>
</edge>
<edge source="we" target="stale data">
  <data key="d0">could read</data>
</edge>
<edge source="we" target="data that is immediately overwritten">
  <data key="d0">could write</data>
</edge>
<edge source="we" target="the pipeline stalling logic by ordering the loads to access the already stored interrupt state first">
  <data key="d0">do not need to engage</data>
</edge>
<edge source="we" target="an analysis of the functional improvements">
  <data key="d0">give</data>
</edge>
<edge source="we" target="the general-purpose registers X1, X2">
  <data key="d0">push out</data>
</edge>
<edge source="we" target="in the interrupt handler, we use the same order to load words back">
  <data key="d0">need to ensure</data>
</edge>
<edge source="we" target="how nested interrupt handling code works for the basic CLINT-mode, the baseline CLIC, and our FastIRQ extension">
  <data key="d0">give an overview of</data>
</edge>
<edge source="we" target="how quickly an external event is addressed">
  <data key="d0">mostly care about</data>
</edge>
<edge source="we" target="the rest of the context switch routine">
  <data key="d0">can proceed with</data>
</edge>
<edge source="we" target="the current running tasks state to memory">
  <data key="d0">want to save</data>
</edge>
<edge source="we" target="the stack">
  <data key="d0">set up</data>
</edge>
<edge source="we" target="RTL simulations of the different versions of CV32RT as part of CONTROLPULP">
  <data key="d0">take measurements by running</data>
</edge>
<edge source="we" target="the interrupt latency in the optimal case">
  <data key="d0">measure</data>
</edge>
<edge source="we" target="the cost in clock cycles of such sequences">
  <data key="d0">show</data>
</edge>
<edge source="we" target="the definition presented in Section II-B for the interrupt latency">
  <data key="d0">assume</data>
</edge>
<edge source="we" target="references to different variants adopted by SOTA in Table III">
  <data key="d0">provide</data>
</edge>
<edge source="THE LATTER" target="restoring the interrupt context and the regular interrupt latency">
  <data key="d0">consists of</data>
</edge>
<edge source="Interrupt latency" target="the time it takes from an interrupt edge arriving at the HW, usually the interrupt controller, to the execution of the first instruction of the corresponding interrupt handler routine">
  <data key="d0">is defined as</data>
</edge>
<edge source="each HW configuration" target="a handwritten optimized interrupt handler">
  <data key="d0">has</data>
</edge>
<edge source="handwritten optimized interrupt handler" target="all required general-purpose and machine-specific registers for nesting interrupts">
  <data key="d0">stores</data>
</edge>
<edge source="the first instruction" target="the one after all necessary interrupt context has been saved on the stack to be able to call a function">
  <data key="d0">is</data>
</edge>
<edge source="the first instruction" target="re-enabling global interrupts">
  <data key="d0">will be</data>
</edge>
<edge source="interrupt handler and interrupt context saving code" target="true">
  <data key="d0">can be interleaved</data>
</edge>
<edge source="some of the context saving code" target="true">
  <data key="d0">can be removed</data>
</edge>
<edge source="some of the context saving code" target="redundant">
  <data key="d0">might be</data>
</edge>
<edge source="THE ACTIVE INTERRUPT HANDLERS CONTEXT" target="INTERRUPT RETURN">
  <data key="d0">MUST BE RESTORED ON</data>
</edge>
<edge source="THE ACTIVE INTERRUPT HANDLERS CONTEXT" target="THE NEXT PENDING INTERRUPT FIRING">
  <data key="d0">IS IMMEDIATELY SAVED AGAIN DUE TO</data>
</edge>
<edge source="restoring the pre-interrupt context" target="SW for the nested interrupt case">
  <data key="d0">is handled in</data>
</edge>
<edge source="context switching time" target="the responsiveness of the architecture in swapping from one execution context to another">
  <data key="d0">determines</data>
</edge>
<edge source="Preemption" target="an event such as an interrupt request">
  <data key="d0">refers to</data>
</edge>
<edge source="An interrupt request" target="a current task">
  <data key="d0">temporarily interrupts</data>
</edge>
<edge source="The purpose of preemption" target="resuming its execution later">
  <data key="d0">is</data>
</edge>
<edge source="The simplest case for preemption" target="non-nested interrupt handlers">
  <data key="d0">occurs with</data>
</edge>
<edge source="A more complex case for preemption" target="nested interrupt handlers">
  <data key="d0">occurs with</data>
</edge>
<edge source="Nested interrupt handlers" target="the case of multiple interrupts at a time">
  <data key="d0">handle</data>
</edge>
<edge source="THIS SITUATION" target="PREEMPTION">
  <data key="d0">does not result in</data>
</edge>
<edge source="THIS SITUATION" target="PENDING INTERRUPTS TO BE SERVICED IN SEQUENCE ACCORDING TO INCREASING PRIORITY">
  <data key="d0">causes</data>
</edge>
<edge source="LEVELPRIORITY arbitration" target="SW-driven">
  <data key="d0">is</data>
</edge>
<edge source="SW-driven LEVELPRIORITY arbitration" target="priority simplestandard interrupt handlers">
  <data key="d0">uses</data>
</edge>
<edge source="LEVELPRIORITY arbitration logic" target="interrupt controller">
  <data key="d0">is designed within</data>
</edge>
<edge source="highest LEVELPRIORITY interrupt" target="pending but disabled">
  <data key="d0">is</data>
</edge>
<edge source="highest LEVELPRIORITY interrupt" target="core">
  <data key="d0">is not propagated to</data>
</edge>
<edge source="core" target="unwinding the stack to return to normal program execution">
  <data key="d0">starts</data>
</edge>
<edge source="A levelpriority interrupt scheme" target="additional masking of incoming interrupts of equal or lower levelpriority than the executing ISR">
  <data key="d0">introduces</data>
</edge>
<edge source="A levelpriority interrupt scheme" target="additional masking of incoming interrupts sometimes larger than a configurable levelpriority threshold">
  <data key="d0">introduces</data>
</edge>
<edge source="A levelpriority interrupt scheme" target="either software or hardware driven">
  <data key="d0">can be</data>
</edge>
<edge source="this scenario" target="real-time and complex embedded systems">
  <data key="d0">is not ideal for</data>
</edge>
<edge source="A HIGH-PRIORITY INTERRUPT" target="A LOWER-PRIORITY INTERRUPT TO FINISH">
  <data key="d0">has to wait for</data>
</edge>
<edge source="interrupt handler" target="global interrupts are disabled">
  <data key="d0">is entered</data>
</edge>
<edge source="interrupt handler" target="a dedicated register bank">
  <data key="d0">operates through</data>
</edge>
<edge source="ISR" target="carefully designed">
  <data key="d0">need to be</data>
</edge>
<edge source="ISR" target="they are reentrant">
  <data key="d0">are designed to ensure</data>
</edge>
<edge source="THE NESTING" target="higher priority interrupts to preempt a current lower priority ISR executing">
  <data key="d0">allows</data>
</edge>
<edge source="Back-to-back interrupts" target="interrupts that need to be served sequentially">
  <data key="d0">are</data>
</edge>
<edge source="Back-to-back interrupts" target="whenever there are multiple interrupts pending">
  <data key="d0">can happen</data>
</edge>
<edge source="The transition from one interrupt to the next one" target="a redundant sequence of context restores and context saves">
  <data key="d0">causes</data>
</edge>
<edge source="Redundant context restore sequences" target="interrupt latency on higher interrupt loads">
  <data key="d0">negatively impact</data>
</edge>
<edge source="Redundant context restore with non-nested or nested horizontal interrupts" target="unwanted additional interrupt latency">
  <data key="d0">can introduce</data>
</edge>
<edge source="REDUNDANT CONTEXT RESTORE" target="TWO NON-PREEMPTIVE INTERRUPTS">
  <data key="d0">applies to</data>
</edge>
<edge source="TWO NON-PREEMPTIVE INTERRUPTS" target="TWO INTERRUPTS WITH SAME LEVEL BUT DIFFERENT PRIORITIES">
  <data key="d0">example</data>
</edge>
<edge source="TAIL-CHAINING" target="OPTIMIZE IT">
  <data key="d0">used to</data>
</edge>
<edge source="interrupt context restore and store sequence between back-to-back interrupts" target="redundant">
  <data key="d0">can be considered</data>
</edge>
<edge source="REDUNDANT CONTEXT RESTORING SEQUENCES" target="FULL INTERRUPT EXIT CODE SEQUENCE">
  <data key="d0">contains</data>
</edge>
<edge source="Redundant context restore with non-nested interrupts" target="chaining two back-to-back interrupts and bypassing the superfluous restore-save operation">
  <data key="d0">is addressed by</data>
</edge>
<edge source="SECTION III-D" target="the optimizations implemented in this work to address this scenario">
  <data key="d0">explores</data>
</edge>
<edge source="The privileged specification 14" target="a simple interrupt scheme with a set of timer and inter-processor interrupts">
  <data key="d0">defines</data>
</edge>
<edge source="The simple interrupt scheme" target="the RISC-V ecosystem">
  <data key="d0">is in</data>
</edge>
<edge source="pending and enabled interrupts" target="according to a threshold value representing an interrupt level">
  <data key="d0">are masked</data>
</edge>
<edge source="threshold value representing an interrupt level" target="a CSR">
  <data key="d0">is configured through</data>
</edge>
<edge source="32-bit cores" target="a fixed priority interrupt scheme">
  <data key="d0">define</data>
</edge>
<edge source="fixed priority interrupt scheme" target="16 predefined or reserved interrupts">
  <data key="d0">has</data>
</edge>
<edge source="fixed priority interrupt scheme" target="16 implementation-defined interrupts">
  <data key="d0">has</data>
</edge>
<edge source="16 predefined or reserved interrupts and 16 implementation-defined interrupts" target="optionally vectored">
  <data key="d0">can be</data>
</edge>
<edge source="THE CLINT ITSELF" target="prioritization of interrupts based on privilege mode">
  <data key="d0">supports</data>
</edge>
<edge source="CLINT-MODE" target="inflexible interrupt scheme">
  <data key="d0">has</data>
</edge>
<edge source="inflexible interrupt scheme of the CLINT-MODE" target="much more work to be done in managing interrupt mask (SOMEIRQMASK) and other machine state">
  <data key="d0">causes</data>
</edge>
<edge source="interrupts with lower priority than the current interrupt running" target="in CLINT-mode when global interrupts are re-enabled">
  <data key="d0">can fire</data>
</edge>
<edge source="the Clint" target="fine-grained control over interrupt prioritization">
  <data key="d0">lacks</data>
</edge>
<edge source="PLIC 22" target="the CLINT">
  <data key="d0">can be attached to</data>
</edge>
<edge source="PLIC 22" target="the number of custom interrupts">
  <data key="d0">increases</data>
</edge>
<edge source="an active interrupt handler" target="IRQ2">
  <data key="d0">is servicing</data>
</edge>
<edge source="IRQ1" target="pending">
  <data key="d0">is</data>
</edge>
<edge source="IRQ1" target="IRQ2">
  <data key="d0">preempts</data>
</edge>
<edge source="IRQ1" target="its level is higher than both the interrupt threshold and IRQ2's level">
  <data key="d0">preempts IRQ2 when</data>
</edge>
<edge source="interrupts that are assigned a higher level" target="lower-level interrupts">
  <data key="d0">can pre-empt</data>
</edge>
<edge source="A single hart" target="multiple targets">
  <data key="d0">can correspond to</data>
</edge>
<edge source="each interrupt" target="a priority">
  <data key="d0">can be assigned</data>
</edge>
<edge source="each interrupt" target="one 32-bit register">
  <data key="d0">is associated with</data>
</edge>
<edge source="each target" target="a threshold">
  <data key="d0">can select</data>
</edge>
<edge source="INTERRUPT SELECTION" target="the CLIC in HW">
  <data key="d0">is driven by</data>
</edge>
<edge source="the CLIC in HW" target="the highest level, highest priority pending interrupt to the cores interface">
  <data key="d0">propagates</data>
</edge>
<edge source="Interrupt priority" target="a tie-breaker for the case of multiple interrupts pending with the same level">
  <data key="d0">serves as</data>
</edge>
<edge source="enabled interrupts and their level and priority information" target="prioritization logic">
  <data key="d0">are sent to</data>
</edge>
<edge source="prioritization logic" target="a binary arbitration tree">
  <data key="d0">uses</data>
</edge>
<edge source="a binary arbitration tree" target="the highest-level interrupt">
  <data key="d0">selects</data>
</edge>
<edge source="The priorities" target="concurrent pending interrupts to be taken in the order preferred by the programmer">
  <data key="d0">allow</data>
</edge>
<edge source="The level information" target="pre-emption of same-privilege level interrupts">
  <data key="d0">enables</data>
</edge>
<edge source="same-privilege level interrupts" target="horizontal interrupts">
  <data key="d0">are also called</data>
</edge>
<edge source="THIS SCHEME" target="interrupts to be divided according to their priorities on the PLIC-level">
  <data key="d0">allows</data>
</edge>
<edge source="THIS SCHEME" target="some flexibility in terms of prioritization">
  <data key="d0">allows</data>
</edge>
<edge source="THIS SCHEME" target="the flexibility problem on the core local-level">
  <data key="d0">does not address</data>
</edge>
<edge source="CLIC 15" target="these limitations">
  <data key="d0">addresses</data>
</edge>
<edge source="CLIC 15" target="interrupts to be prioritized by so-called levels and priorities">
  <data key="d0">allows</data>
</edge>
<edge source="multiple horizontal interrupts" target="equal levels and priorities">
  <data key="d0">have</data>
</edge>
<edge source="the CLIC" target="the highest numbered interrupt (identification number ID 15)">
  <data key="d0">selects</data>
</edge>
<edge source="the highest numbered interrupt (identification number ID 15)" target="an arbitrary assignment decided at design time">
  <data key="d0">is</data>
</edge>
<edge source="this feature" target="RTOSs that only want to disable a subset of all interrupts during critical sections">
  <data key="d0">is useful for</data>
</edge>
<edge source="interrupts that do not interfere with the data accessed in such a critical section" target="still fire">
  <data key="d0">can</data>
</edge>
<edge source="interrupts fired from different privilege modes" target="vertical interrupts">
  <data key="d0">are referred to as</data>
</edge>
<edge source="interrupts fired from the same privilege mode" target="horizontal interrupts">
  <data key="d0">are referred to as</data>
</edge>
<edge source="TABLE I" target="preemption conditions of two nested interrupts IRQ2 and IRQ1 according to the CLIC specification">
  <data key="d0">shows</data>
</edge>
<edge source="THE CLIC SPECIFICATION" target="the case of redundant context restore (see Section II-B6)">
  <data key="d0">addresses</data>
</edge>
<edge source="XNXTI" target="a CSR short for next interrupt handler address">
  <data key="d0">is</data>
</edge>
<edge source="XNXTI" target="the interrupt context storing part itself">
  <data key="d0">does not touch</data>
</edge>
<edge source="XNXTI" target="42 cycles">
  <data key="d0">require</data>
</edge>
<edge source="XNXTI" target="a pointer to the address of the next handler">
  <data key="d0">returns</data>
</edge>
<edge source="XNXTI" target="a small code sequence (load, jump, and retry loop)">
  <data key="d0">needs</data>
</edge>
<edge source="XNXTI and interrupt-enable CSRs" target="non-vectored interrupts">
  <data key="d0">are meant for use with</data>
</edge>
<edge source="READING FROM THIS CSR" target="to fast-track interrupts that arrive late">
  <data key="d0">allows</data>
</edge>
<edge source="READING FROM THIS CSR" target="to avoid redundant context save-restore by running through pending interrupts back-to-back">
  <data key="d0">allows</data>
</edge>
<edge source="the core" target="an active handler">
  <data key="d0">is within</data>
</edge>
<edge source="the core" target="the jump address from the interrupt vector table">
  <data key="d0">starts fetching</data>
</edge>
<edge source="architecture entering an interrupt context or performing a context switch" target="the HW to store enough information to resume operation correctly after returning from the aforementioned context">
  <data key="d0">requires</data>
</edge>
<edge source="Improving interrupt latency and context switch times" target="controlling the amount of state that needs to be preserved to enter and leave an interrupt context">
  <data key="d0">can be done by</data>
</edge>
<edge source="Improving interrupt latency and context switch times" target="increasing the bandwidth and decreasing the latency to memory">
  <data key="d0">can be done by</data>
</edge>
<edge source="Improving interrupt latency and context switch times" target="relying on latency-hiding techniques that defer the effective saving of the state to a later point in time">
  <data key="d0">can be done by</data>
</edge>
<edge source="proposed architecture" target="typical case scenarios">
  <data key="d0">tackles</data>
</edge>
<edge source="THE BACKGROUND-SAVING MECHANISM" target="THE STACK POINTER">
  <data key="d0">UPDATES</data>
</edge>
<edge source="THE BACKGROUND-SAVING MECHANISM" target="THE BANK-SWITCHED CONTENTS IN MEMORY">
  <data key="d0">STORES</data>
</edge>
<edge source="THE BACKGROUND-SAVING MECHANISM" target="THE STATE SAVING AND RESTORING PART OF CONTEXT FIG">
  <data key="d0">to accelerate</data>
</edge>
<edge source="THE STACK POINTER" target="APPROPRIATELY TO MAINTAIN ABI INVARIANTS">
  <data key="d0">IS ADJUSTED</data>
</edge>
<edge source="THE EXECUTION OF THE CORE" target="IN PARALLEL">
  <data key="d0">PROCEEDS</data>
</edge>
<edge source="2" target="an overview of the design">
  <data key="d0">provides</data>
</edge>
<edge source="programmable configuration information" target="each interrupt line">
  <data key="d0">is about</data>
</edge>
<edge source="programmable configuration information" target="level, priority, enable status, and sensitivity (leveledge)">
  <data key="d0">consists of</data>
</edge>
<edge source="THE INTERRUPT PRIORITIZATION MODULE" target="THE TREE FROM LEAVES TO THE ROOT">
  <data key="d0">TRAVERSES</data>
</edge>
<edge source="THE SOUGHT-AFTER MAXIMUM LEVEL AND PRIORITY INTERRUPT" target="AT THE ROOT">
  <data key="d0">IS FOUND</data>
</edge>
<edge source="each tree" target="low overhead in terms of area and delay">
  <data key="d0">has</data>
</edge>
<edge source="overhead in terms of area" target="O(N)">
  <data key="d0">is</data>
</edge>
<edge source="overhead in terms of delay" target="O(LOG(N))">
  <data key="d0">is</data>
</edge>
<edge source="THE INTERRUPT" target="THE CORE">
  <data key="d0">is presented to</data>
</edge>
<edge source="THE INTERRUPT" target="A HANDSHAKE-BASED INTERFACE">
  <data key="d0">is presented with</data>
</edge>
<edge source="The additional kill signal" target="a handshake to restart">
  <data key="d0">is there to allow for</data>
</edge>
<edge source="A handshake" target="a potentially more important interrupt to be presented to the core">
  <data key="d0">allows</data>
</edge>
<edge source="additional pipeline stages" target="in the arbitration tree">
  <data key="d0">can be inserted</data>
</edge>
<edge source="additional pipeline stages" target="relax timing">
  <data key="d0">can be inserted to</data>
</edge>
<edge source="OUR VERSION OF THE CLIC" target="SHV">
  <data key="d0">supports</data>
</edge>
<edge source="OUR VERSION OF THE CLIC" target="THE XNXTI CSR IN THE CORE">
  <data key="d0">supports</data>
</edge>
<edge source="interrupt handling capabilities of CV32" target="introducing priority and levels management in HW">
  <data key="d0">are improved by</data>
</edge>
<edge source="critical operations such as interrupt state and context save/restore" target="the CLIC">
  <data key="d0">are not natively covered by</data>
</edge>
<edge source="critical operations such as interrupt state and context save/restore" target="SW">
  <data key="d0">need to be handled in</data>
</edge>
<edge source="CV32FASTIRQ" target="filling this gap">
  <data key="d0">aims at</data>
</edge>
<edge source="THE CLIC" target="this with the LEVELPRIORITY scheme">
  <data key="d0">addresses</data>
</edge>
<edge source="THE CLIC" target="an HW-assisted solution to address such a scenario with the XNXTI CSRS">
  <data key="d0">offers</data>
</edge>
<edge source="A new interrupt at the CLIC" target="whether the interrupt level exceeds the configured threshold">
  <data key="d0">will be checked</data>
</edge>
<edge source="THE CORES STATE MACHINE" target="the pipeline">
  <data key="d0">will flush</data>
</edge>
<edge source="THE CORES STATE MACHINE" target="the program counter">
  <data key="d0">will update</data>
</edge>
<edge source="the program counter" target="the vector table entry">
  <data key="d0">is updated according to</data>
</edge>
<edge source="the saving logic" target="a bank switch">
  <data key="d0">triggers</data>
</edge>
<edge source="the bank switch" target="the interrupt context to have a fresh set of registers">
  <data key="d0">allows</data>
</edge>
<edge source="the other bank contents" target="a separate port to the main memory">
  <data key="d0">are drained through</data>
</edge>
<edge source="RF BANKS" target="on an interrupt">
  <data key="d0">are switched</data>
</edge>
<edge source="THE RISC-V EMBEDDED AND INTEGER ABI" target="THE STACK POINTER POINTS BELOW THE LAST SAVED REGISTER ON THE STACK">
  <data key="d0">dictate</data>
</edge>
<edge source="the program code running in the interrupt handler" target="the values on the stack">
  <data key="d0">could clobber</data>
</edge>
<edge source="Doing away with this mechanism for leaf-type interrupts" target="a new ABI considering a virtual stack pointer offset when generating code for interrupt handlers">
  <data key="d0">would require</data>
</edge>
<edge source="Doing away with this mechanism for leaf-type interrupts" target="the nested interrupt case">
  <data key="d0">would not solve</data>
</edge>
<edge source="interactions" target="background-saving mechanism and regular loadstore instructions of the core">
  <data key="d0">exist between</data>
</edge>
<edge source="interactions" target="incorrect execution">
  <data key="d0">could result in</data>
</edge>
<edge source="A load instruction" target="an architectural register">
  <data key="d0">is trying to update</data>
</edge>
<edge source="The background-saving mechanism" target="the same register">
  <data key="d0">is trying to read</data>
</edge>
<edge source="No conflict" target="when a load instruction is trying to update an architectural register while the background-saving mechanism is trying to read the same register">
  <data key="d0">arises</data>
</edge>
<edge source="updates to the RF" target="at this point">
  <data key="d0">are resolved</data>
</edge>
<edge source="the bank switching operation" target="after updates to the RF are resolved">
  <data key="d0">takes place</data>
</edge>
<edge source="the bank switching operation" target="correctness of the execution">
  <data key="d0">ensures</data>
</edge>
<edge source="loads or stores accessing stack memory regions where the background-saving mechanism is writing to" target="properly resolved">
  <data key="d0">need to be</data>
</edge>
<edge source="execution of the handler" target="if this happens while the background-saving mechanism is still at work">
  <data key="d0">has to wait</data>
</edge>
<edge source="the load-store unit of the core" target="the ongoing state being written to memory">
  <data key="d0">is informed of</data>
</edge>
<edge source="A straightforward solution" target="stall the cores pipeline while the background-saving mechanism is at work">
  <data key="d0">is to</data>
</edge>
<edge source="the load-store unit" target="the memory in the range of the stack pointer">
  <data key="d0">tries to access</data>
</edge>
<edge source="the stack pointer" target="on an interrupt">
  <data key="d0">is decremented</data>
</edge>
<edge source="decrementing the stack pointer" target="space available">
  <data key="d0">makes</data>
</edge>
<edge source="the background-saving mechanism" target="the interrupt state word by word">
  <data key="d0">will start storing</data>
</edge>
<edge source="the address offset of the last word pushed out by the background-saving mechanism" target="any incoming load and stores">
  <data key="d0">is compared against</data>
</edge>
<edge source="LOAD AND STORES THAT TRY TO ACCESS DATA THAT IS NOT YET PUSHED TO MEMORY" target="THE CORES PIPELINE TO STALL">
  <data key="d0">CAUSE</data>
</edge>
<edge source="THIS MECHANISM" target="THE CORRECTNESS OF LOADS AND STORES ISSUED BY THE CORE">
  <data key="d0">ensures</data>
</edge>
<edge source="Accessing stack memory locations during the execution of an interrupt handler" target="two use cases">
  <data key="d0">happens in</data>
</edge>
<edge source="A SYSTEM CALL HANDLER" target="the ECALL instruction in RISC-V">
  <data key="d0">is issued through</data>
</edge>
<edge source="A SYSTEM CALL HANDLER" target="user-provided arguments">
  <data key="d0">wants to access</data>
</edge>
<edge source="most" target="general-purpose registers">
  <data key="d0">will be passed through</data>
</edge>
<edge source="some" target="the stack">
  <data key="d0">might be placed on</data>
</edge>
<edge source="short interrupt handlers" target="the full interrupt state has been saved">
  <data key="d0">want to return before</data>
</edge>
<edge source="each of these cases" target="the stalling logic outlined in Section III-C3">
  <data key="d0">would potentially engage</data>
</edge>
<edge source="engaging the stalling logic outlined in Section III-C3" target="higher interrupt latencies">
  <data key="d0">causes</data>
</edge>
<edge source="a hardware solution" target="forwarding logic">
  <data key="d0">would be to add</data>
</edge>
<edge source="forwarding logic" target="the load-store unit">
  <data key="d0">checks in</data>
</edge>
<edge source="forwarding logic" target="what is being written by the background-saving mechanism">
  <data key="d0">checks</data>
</edge>
<edge source="forwarding logic" target="these values from the store queue">
  <data key="d0">forwards</data>
</edge>
<edge source="these values" target="the store queue">
  <data key="d0">are forwarded from</data>
</edge>
<edge source="these values" target="the memory subsystem outside the core">
  <data key="d0">are forwarded instead of going through</data>
</edge>
<edge source="some register values" target="because they might not have reached the load-store unit yet">
  <data key="d0">cannot be forwarded</data>
</edge>
<edge source="THE APPROACH" target="HW COMPLEXITY">
  <data key="d0">INCREASES</data>
</edge>
<edge source="THE APPROACH" target="A DYNAMIC ADDRESS LOOKUP INTO A QUEUE-LIKE BUFFER">
  <data key="d0">REQUIRES</data>
</edge>
<edge source="THE CV32S RF" target="additional logic for the background-saving mechanism">
  <data key="d0">is extended with</data>
</edge>
<edge source="parts of the old memory bank (the interrupt context)" target="the cores stack location">
  <data key="d0">are copied to</data>
</edge>
<edge source="execution" target="the new bank">
  <data key="d0">can go ahead by using</data>
</edge>
<edge source="this design" target="a dedicated memory port for the background-saving mechanism">
  <data key="d0">has</data>
</edge>
<edge source="this design" target="a larger area overhead compared to traditional RISC-V CLINT 14">
  <data key="d0">incurs</data>
</edge>
<edge source="the dedicated memory port" target="the port from the load-store unit">
  <data key="d0">can be shared with</data>
</edge>
<edge source="the programmer" target="that to achieve the best possible latency">
  <data key="d0">has to be aware of</data>
</edge>
<edge source="programmer" target="compiler-specific attributes to write his interrupt handlers">
  <data key="d0">uses</data>
</edge>
<edge source="compiler-specific attributes" target="attribute((interrupt)) in GCC">
  <data key="d0">include</data>
</edge>
<edge source="compiler" target="the fact that programmer uses compiler-specific attributes to write his interrupt handlers">
  <data key="d0">needs to be made aware of</data>
</edge>
<edge source="ROUTINES" target="SAVING STATE FOR VECTORED NESTING INTERRUPTS">
  <data key="d0">are for</data>
</edge>
<edge source="SAVING STATE FOR VECTORED NESTING INTERRUPTS" target="CLINT">
  <data key="d0">uses</data>
</edge>
<edge source="SAVING STATE FOR VECTORED NESTING INTERRUPTS" target="CLIC">
  <data key="d0">uses</data>
</edge>
<edge source="SAVING STATE FOR VECTORED NESTING INTERRUPTS" target="PROPOSED FASTIRQ EXTENSION">
  <data key="d0">uses</data>
</edge>
<edge source="reducing the RF size" target="lower context switch times">
  <data key="d0">helps</data>
</edge>
<edge source="reducing the RF size" target="the interrupt latency">
  <data key="d0">does not affect</data>
</edge>
<edge source="the set of caller-save registers" target="the same when using the embedded-application binary interface (EABI)">
  <data key="d0">remains</data>
</edge>
<edge source="OUR IMPLEMENTATION" target="the core to dynamically switch between RV32I and RV32E with FastIRQ depending on the workload">
  <data key="d0">allows</data>
</edge>
<edge source="one" target="additional registers for the seven caller-save registers to save area">
  <data key="d0">could add</data>
</edge>
<edge source="doubling the RF size for the banking logic" target="adding additional registers for the seven caller-save registers to save area">
  <data key="d0">is alternative to</data>
</edge>
<edge source="increased pressure on the RF" target="not acceptable">
  <data key="d0">is</data>
</edge>
<edge source="the interrupt state" target="simply switching register banks">
  <data key="d0">can be quickly restored by</data>
</edge>
<edge source="THIS INSTRUCTION" target="the same function as MRET">
  <data key="d0">performs</data>
</edge>
<edge source="THIS INSTRUCTION" target="switching register banks">
  <data key="d0">performs</data>
</edge>
<edge source="this situation" target="directly checking for other interrupts pending on the same level before restoring the executions interrupt context">
  <data key="d0">can be optimized by</data>
</edge>
<edge source="NUCLEIS ENHANCED CLIC (ECLIC) 18" target="XNXTI">
  <data key="d0">extends</data>
</edge>
<edge source="NUCLEIS ENHANCED CLIC (ECLIC) 18" target="the jump to the queuing interrupt handler in the XNXTI HW (JALXNXTI)">
  <data key="d0">embeds</data>
</edge>
<edge source="NUCLEI SYSTEM TECHNOLOGY ECLIC 39" target="traditional XNXTI">
  <data key="d0">extends</data>
</edge>
<edge source="NUCLEI SYSTEM TECHNOLOGY ECLIC 39" target="a novel CSR for machine privilege mode, JALMNXTI 18">
  <data key="d0">extends with</data>
</edge>
<edge source="JALMNXTI 18" target="this work in Section IV">
  <data key="d0">is discussed in</data>
</edge>
<edge source="some HW" target="this concept of removing redundant context restores as tail-chaining">
  <data key="d0">refers to</data>
</edge>
<edge source="A high-level interrupt" target="the current running interrupt handler">
  <data key="d0">could preempt</data>
</edge>
<edge source="MIE" target="to prevent that corresponding lower-priority interrupts are disabled">
  <data key="d0">has to be manually adjusted</data>
</edge>
<edge source="this return path" target="HW by adding an additional write port to the cores RF">
  <data key="d0">could be handled in</data>
</edge>
<edge source="exiting an interrupt handler" target="less time-critical">
  <data key="d0">is</data>
</edge>
<edge source="context switches" target="OS-specific and HW-specific parts">
  <data key="d0">can be divided into</data>
</edge>
<edge source="The OS part" target="all contributions to the context switch time that is specific to the OS itself">
  <data key="d0">entails</data>
</edge>
<edge source="The OS part" target="computing the next task to be scheduled">
  <data key="d0">includes</data>
</edge>
<edge source="The OS part" target="bookkeeping operations">
  <data key="d0">includes</data>
</edge>
<edge source="THE REMAINDER" target="THE HW-DEPENDENT SAVING AND RESTORING OF THE STATE BELONGING TO THE NEW CONTEXT">
  <data key="d0">is</data>
</edge>
<edge source="THE IDEA" target="THE BACKGROUND-SAVING MECHANISM">
  <data key="d0">is to use</data>
</edge>
<edge source="HW" target="the previous register state to memory in the background">
  <data key="d0">pushes out</data>
</edge>
<edge source="HW" target="link register a value (EXCRETURN)">
  <data key="d0">encodes in</data>
</edge>
<edge source="HW mechanism" target="swap the registers">
  <data key="d0">engages to</data>
</edge>
<edge source="HW mechanism" target="the registers in the background">
  <data key="d0">saves</data>
</edge>
<edge source="the initial part of the context switch routine" target="for that">
  <data key="d0">changes</data>
</edge>
<edge source="Additional RISC-V extensions" target="more context switching state">
  <data key="d0">introduce</data>
</edge>
<edge source="More context switching state" target="contrary to the goals of FastIRQ regarding latencies">
  <data key="d0">run</data>
</edge>
<edge source="adding more state to FastIRQ" target="technical limitations">
  <data key="d0">has no</data>
</edge>
<edge source="the resulting design" target="a significant increase in area and power">
  <data key="d0">would incur</data>
</edge>
<edge source="a dirty bit" target="the fast path competitive">
  <data key="d0">could help to keep</data>
</edge>
<edge source="THIS SECTION" target="A FUNCTIONAL AND QUANTITATIVE EVALUATION OF THE VARIOUS FLAVORS OF THE CV32RT">
  <data key="d0">GIVES</data>
</edge>
<edge source="The interrupt lines" target="a hardwired prioritization scheme">
  <data key="d0">have</data>
</edge>
<edge source="THE BASELINE CLIC" target="THESE WEAKNESSES">
  <data key="d0">ADDRESSES</data>
</edge>
<edge source="A level threshold register per privilege level (XINTTHRESH)" target="the set of allowed horizontal interrupts">
  <data key="d0">controls</data>
</edge>
<edge source="A level threshold register per privilege level (XINTTHRESH)" target="the set of allowed horizontal interrupts to those whose level exceeds the given value in the register">
  <data key="d0">limits</data>
</edge>
<edge source="VECTORING" target="selectively enabled or disabled per interrupt line">
  <data key="d0">can be</data>
</edge>
<edge source="THIS SOLUTION" target="VECTORED INTERRUPTS">
  <data key="d0">works for</data>
</edge>
<edge source="THIS SOLUTION" target="NON-VECTORED INTERRUPTS">
  <data key="d0">works for</data>
</edge>
<edge source="THE OPTIONAL XNXTI EXTENSION" target="multiple horizontal interrupts to be serviced in sequence without redundant context-restoring operations in between">
  <data key="d0">allows</data>
</edge>
<edge source="the first interrupt" target="the full latency cost">
  <data key="d0">has to pay</data>
</edge>
<edge source="READING THE XNXTI CSR" target="a pointer to the vector table entry for the next pending and qualifying interrupt">
  <data key="d0">yields</data>
</edge>
<edge source="a pointer to the vector table entry for the next pending and qualifying interrupt" target="a direct jump there">
  <data key="d0">allows</data>
</edge>
<edge source="THIS APPROACH" target="THE LATENCY ADVANTAGE OF HW VECTORING">
  <data key="d0">loses</data>
</edge>
<edge source="THIS APPROACH" target="AN SW EMULATION THEREOF">
  <data key="d0">runs</data>
</edge>
<edge source="memory subsystem" target="single cycle (zero wait state) access to static random access memory (SRAM)">
  <data key="d0">has</data>
</edge>
<edge source="The memory bank we are using" target="other bus masters">
  <data key="d0">is not contended by</data>
</edge>
<edge source="interrupt lines" target="no additional latencies introduced between interrupt sources and the CLIC">
  <data key="d0">have</data>
</edge>
<edge source="the HW contributed interrupt latency" target="Section II-B3">
  <data key="d0">is described in</data>
</edge>
<edge source="CV32 and CV32RT variations" target="Standard CLIC, XNXTI, JALXNXTI">
  <data key="d0">include</data>
</edge>
<edge source="all caller-save registers" target="saved">
  <data key="d0">need to be</data>
</edge>
<edge source="Interrupt handler routines that save the interrupt context in SW" target="the minimum state if the compiler is able to fully inline the handlers function body">
  <data key="d0">can only save</data>
</edge>
<edge source="interrupt handler routines that use sw-based mechanisms to save and restore interrupt state" target="the handler code">
  <data key="d0">can fully inline</data>
</edge>
<edge source="interrupt handler routines that use sw-based mechanisms to save and restore interrupt state" target="some caller-save registers">
  <data key="d0">can save</data>
</edge>
<edge source="the compiler" target="fully inlining the handler code and saving some caller-save registers">
  <data key="d0">permits</data>
</edge>
<edge source="only one caller-save register" target="SW-based interrupt handlers">
  <data key="d0">needs saving for</data>
</edge>
<edge source="INTERRUPTS" target="the design at the interrupt controller inputs">
  <data key="d0">are injected into</data>
</edge>
<edge source="FOR OUR FASTIRQ EXTENSION" target="is always saved">
  <data key="d0">this amount of state</data>
</edge>
<edge source="the HW" target="which caller-save registers need to be saved">
  <data key="d0">does not know a priori</data>
</edge>
<edge source="TABLE III" target="the main techniques for optimizing interrupt context and task context save/restore with nested and non-nested interrupts employed by industry and academia in the embedded and real-time application domains">
  <data key="d0">compares</data>
</edge>
<edge source="TABLE III" target="THE OVERVIEW">
  <data key="d0">summarizes</data>
</edge>
<edge source="the results" target="FIG.">
  <data key="d0">are summarized in</data>
</edge>
<edge source="several designs" target="the interrupt context directly in HW">
  <data key="d0">automatically save and restore</data>
</edge>
<edge source="AUTOMATIC INTERRUPT CONTEXT SAVERESTORE" target="SW HOUSEKEEPING OVERHEAD BEFORE AND AFTER HANDLING THE INTERRUPT ROUTINE">
  <data key="d0">reduces</data>
</edge>
<edge source="AUTOMATIC INTERRUPT CONTEXT SAVERESTORE" target="THE ACCELERATION OF THE COMPLETE TASK CONTEXT SWITCH">
  <data key="d0">only partially addresses</data>
</edge>
<edge source="The presented solutions" target="optimizing context, save/restore with HW and SW cooperation">
  <data key="d0">are effective in</data>
</edge>
<edge source="The presented solutions" target="a cohesive approach to address both interrupt context and task context switch acceleration">
  <data key="d0">lack</data>
</edge>
<edge source="The presented solutions" target="existing RISC-V-based approaches that can close the gap with well-established industry vendors">
  <data key="d0">lack</data>
</edge>
<edge source="INTERRUPT CONTEXT SAVERESTORE" target="the former">
  <data key="d0">takes advantage of</data>
</edge>
<edge source="INTERRUPT CONTEXT SAVERESTORE" target="the HW">
  <data key="d0">defers operations to</data>
</edge>
<edge source="XNXTI and JALXNXTI" target="even worse">
  <data key="d0">perform</data>
</edge>
<edge source="XNXTI and JALXNXTI" target="additional instructions in the code path between the handler and interrupt event">
  <data key="d0">insert</data>
</edge>
<edge source="JALXNXTI" target="35 cycles">
  <data key="d0">require</data>
</edge>
<edge source="JALXNXTI" target="these operations into one instruction">
  <data key="d0">fuses</data>
</edge>
<edge source="XNXTI AND JALXNXTI" target="this situation">
  <data key="d0">improve upon</data>
</edge>
<edge source="XNXTI AND JALXNXTI" target="pending interrupts">
  <data key="d0">check for</data>
</edge>
<edge source="XNXTI AND JALXNXTI" target="the respective handlers">
  <data key="d0">directly jump to</data>
</edge>
<edge source="fusing these operations into one instruction" target="saving nine cycles">
  <data key="d0">results in</data>
</edge>
<edge source="ARM Cortex-M4" target="an interrupt latency of 12 cycles given a single-cycle memory">
  <data key="d0">has</data>
</edge>
<edge source="ARM Cortex-M4" target="the same task in six cycles">
  <data key="d0">is able to do</data>
</edge>
<edge source="ARM Cortex-M4" target="it has access to single-cycle memory 24">
  <data key="d0">assumes</data>
</edge>
<edge source="the baseline CLIC" target="68 cycles when using the integer ABI">
  <data key="d0">takes</data>
</edge>
<edge source="the baseline CLIC" target="50 cycles when using the embedded ABI">
  <data key="d0">takes</data>
</edge>
<edge source="THE EMRET MECHANISM OF FASTIRQ" target="similarly">
  <data key="d0">works</data>
</edge>
<edge source="THE EMRET MECHANISM OF FASTIRQ" target="eight clock cycles">
  <data key="d0">costs</data>
</edge>
<edge source="THE EMRET MECHANISM OF FASTIRQ" target="non-vectored interrupts">
  <data key="d0">is not restricted to</data>
</edge>
<edge source="context switch time" target="number of clock cycles between two FreeRTOS dummy tasks">
  <data key="d0">is shown in</data>
</edge>
<edge source="context switch time" target="baseline CV32RT and CV32RTFASTIRQ">
  <data key="d0">is compared between</data>
</edge>
<edge source="Average context switch time" target="FreeRTOS for two tasks of various flavors of CV32RT">
  <data key="d0">is measured in</data>
</edge>
<edge source="all compile time options such as tracing, stack overflow signaling, and the more generic task selection mechanism" target="to minimize the context switch code">
  <data key="d0">were turned off</data>
</edge>
<edge source="generic Cortex-M4 core" target="single-cycle access to memory">
  <data key="d0">has</data>
</edge>
<edge source="ARM Cortex-M" target="16 core registers">
  <data key="d0">has</data>
</edge>
<edge source="THE SW INTERRUPT" target="THE FASTIRQ MECHANISM">
  <data key="d0">WILL TRIGGER</data>
</edge>
<edge source="THE FASTIRQ MECHANISM" target="SAVING THE GENERAL-PURPOSE REGISTERS TO MEMORY">
  <data key="d0">STARTS</data>
</edge>
<edge source="using the I-extension" target="31 cycles (19) for a context switch">
  <data key="d0">can save up to</data>
</edge>
<edge source="using the E-extension" target="16 cycles (12) for a context switch">
  <data key="d0">can save up to</data>
</edge>
<edge source="not using registers that are still being saved by the background-saving mechanism" target="saving cycles for a context switch">
  <data key="d0">enables</data>
</edge>
<edge source="THE FREERTOS WEBSITE 20" target="context switches as low as 96 cycles for a Cortex-M4 implementation">
  <data key="d0">claims</data>
</edge>
<edge source="SYNOPSYS DESIGN COMPILER 2022.03" target="synthesizing CV32RT">
  <data key="d0">is used for</data>
</edge>
<edge source="SYNOPSYS DESIGN COMPILER 2022.03" target="GlobalFoundries 12LP FinFET technology">
  <data key="d0">targets</data>
</edge>
<edge source="GlobalFoundries 12LP FinFET technology" target="500 MHz, TT corner, and 25 C">
  <data key="d0">operates at</data>
</edge>
<edge source="One gate equivalent (GE) for this technology" target="0.121 m2">
  <data key="d0">equals</data>
</edge>
<edge source="STM32L476RG" target="higher latencies due to memory access stalls and other implementation choices in the memory subsystem">
  <data key="d0">has</data>
</edge>
<edge source="RISC-V E-extension" target="the available general-purpose registers from 32 to 16">
  <data key="d0">reduces</data>
</edge>
<edge source="Reducing the available general-purpose registers from 32 to 16" target="the context switch state that needs to be saved and restored">
  <data key="d0">lowers</data>
</edge>
<edge source="REPORTS" target="the CLIC implemented in the proposed with different interrupt sources">
  <data key="d0">the area breakdown of</data>
</edge>
<edge source="AREA OVERHEAD" target="CV32RT">
  <data key="d0">is related to</data>
</edge>
<edge source="FASTIRQ overhead in CV32RTFASTIRQ core" target="a minimal 10 area increase">
  <data key="d0">results in</data>
</edge>
<edge source="area increase" target="the ID stage">
  <data key="d0">is concentrated around</data>
</edge>
<edge source="THE DESIGN" target="GF12LP TECHNOLOGY">
  <data key="d0">has been synthesized in</data>
</edge>
<edge source="GF12LP TECHNOLOGY" target="500 MHZ">
  <data key="d0">has frequency</data>
</edge>
<edge source="GF12LP TECHNOLOGY" target="TT CORNER">
  <data key="d0">has corner</data>
</edge>
<edge source="GF12LP TECHNOLOGY" target="25 C">
  <data key="d0">has temperature</data>
</edge>
<edge source="GF12LP TECHNOLOGY" target="0.8 V">
  <data key="d0">has voltage</data>
</edge>
<edge source="GF12LP TECHNOLOGY" target="SUPER LOW VT STANDARD CELLS">
  <data key="d0">has cell type</data>
</edge>
<edge source="more than half of the resources" target="the configuration registers required to control the CLIC">
  <data key="d0">implement</data>
</edge>
<edge source="the size" target="the number of input interrupts">
  <data key="d0">linearly increases with</data>
</edge>
<edge source="one 32-bit register" target="an area overhead of about 176 GE">
  <data key="d0">incurs</data>
</edge>
<edge source="The remaining area" target="the gateway and binary tree arbitration logic at the core of the CLIC working principle">
  <data key="d0">implements</data>
</edge>
<edge source="The remaining area" target="additional housekeeping control logic that scales linearly with the number of interrupt sources">
  <data key="d0">implements</data>
</edge>
<edge source="the fraction of the design occupied by the arbitration tree" target="when increasing the number of sources">
  <data key="d0">is kept constant</data>
</edge>
<edge source="the gain in flexibility" target="a broader application scope with time-critical systems">
  <data key="d0">enables</data>
</edge>
<edge source="INSTRUCTION DECODE (ID) STAGE" target="an area overhead of 21 compared to CV32RTCLIC">
  <data key="d0">incurs</data>
</edge>
<edge source="OTHER HW BLOCKS OF THE CORE" target="primarily unaffected">
  <data key="d0">remain</data>
</edge>
<edge source="ID stage" target="the HW block where the additional registers and the automatic stacking/unstacking logic are localized">
  <data key="d0">is</data>
</edge>
<edge source="A breakdown" target="FIG">
  <data key="d0">is shown in</data>
</edge>
<edge source="additional storage space for automatic context save and restore in HW" target="the area of the RF by about 36 in the proposed implementation">
  <data key="d0">increases</data>
</edge>
<edge source="the logic for managing the shadow registers" target="an overhead of 40 on the baseline ID stage controller">
  <data key="d0">accounts for</data>
</edge>
<edge source="HW overhead coming from the additional EMRET instruction" target="negligible">
  <data key="d0">is</data>
</edge>
<edge source="increased size of the ID stage" target="the benefits of a simplified programming model that moves several SW operations in HW">
  <data key="d0">trades off</data>
</edge>
<edge source="increased size of the ID stage" target="the benefits of significantly lowered interrupt latency than standard RISC-V">
  <data key="d0">trades off</data>
</edge>
<edge source="increased size of the ID stage" target="the critical path of the base core design">
  <data key="d0">does not impact</data>
</edge>
<edge source="significantly lowered interrupt latency" target="standard RISC-V">
  <data key="d0">is compared to</data>
</edge>
<edge source="TIME-CRITICAL SYSTEMS" target="AREA EFFICIENCY">
  <data key="d0">SHIFT DESIGN PRIORITIES FROM</data>
</edge>
<edge source="TIME-CRITICAL SYSTEMS" target="SAFETY, SECURITY, AND RELIABILITY">
  <data key="d0">SHIFT DESIGN PRIORITIES TO</data>
</edge>
<edge source="this section" target="the leading solutions to optimize handling asynchronous events in state-of-the-art embedded and real-time MCUs">
  <data key="d0">describes</data>
</edge>
<edge source="CLICs" target="Section II-C">
  <data key="d0">are introduced in</data>
</edge>
<edge source="Solutions" target="interrupt context save/restore techniques">
  <data key="d0">address</data>
</edge>
<edge source="Solutions" target="context switch techniques">
  <data key="d0">address</data>
</edge>
<edge source="Solutions" target="dedicated strategies to optimize redundant context restore with back-to-back interrupts">
  <data key="d0">address</data>
</edge>
<edge source="modified version of the return authorized licensed use" target="California Polytechnic State University San Luis Obispo">
  <data key="d0">is limited to</data>
</edge>
<edge source="dedicated register bank" target="up to eight registers">
  <data key="d0">has</data>
</edge>
<edge source="eight registers" target="minimize context switching">
  <data key="d0">are employed to</data>
</edge>
<edge source="fetching the jump address" target="simultaneously during context save and embed context restore within the return instruction">
  <data key="d0">occurs</data>
</edge>
<edge source="ARM Cortex-M series" target="Nested Vectored Interrupt Controller (NVIC)">
  <data key="d0">integrates</data>
</edge>
<edge source="A state machine 32" target="caller-save register stacking in the background">
  <data key="d0">implements</data>
</edge>
<edge source="value (EXCRETURN)" target="core to start unwinding the stack">
  <data key="d0">notifies</data>
</edge>
<edge source="Interrupt Control Unit (ICU) 33, 34, 35" target="Infineon Aurix MCU-class Tricore family">
  <data key="d0">is part of</data>
</edge>
<edge source="The context of the calling routine" target="memory autonomously">
  <data key="d0">is saved in</data>
</edge>
<edge source="Restoring the context" target="the RET instruction">
  <data key="d0">is embedded in</data>
</edge>
<edge source="Restoring the context" target="the return jump 36">
  <data key="d0">happens in parallel with</data>
</edge>
<edge source="27" target="extensions for the RISC-V CLIC">
  <data key="d0">are the first to propose</data>
</edge>
<edge source="interrupt handling" target="automatic stacking in hardware">
  <data key="d0">is enhanced with</data>
</edge>
<edge source="automatic stacking in hardware" target="the core's Harvard architecture">
  <data key="d0">benefits from</data>
</edge>
<edge source="automatic stacking in hardware" target="simultaneous data and instruction memory access">
  <data key="d0">benefits from</data>
</edge>
<edge source="Register banking" target="a technique adopted by several architectures">
  <data key="d0">is</data>
</edge>
<edge source="Register banking" target="a task's context without pushing/popping register values to the stack">
  <data key="d0">swaps</data>
</edge>
<edge source="Register banking" target="an additional area overhead in the design">
  <data key="d0">has</data>
</edge>
<edge source="A tasks context switch" target="quickly transferring the suspended context to the dedicated register bank">
  <data key="d0">benefits from</data>
</edge>
<edge source="A tasks context switch" target="already restoring the next task to be executed">
  <data key="d0">benefits from</data>
</edge>
<edge source="HW REGISTER BANKING" target="PLICs (GIC)">
  <data key="d0">is in</data>
</edge>
<edge source="HW REGISTER BANKING" target="ARM designs">
  <data key="d0">is the case of</data>
</edge>
<edge source="A similar approach" target="the Renesas M32C80 series 30">
  <data key="d0">is implemented in</data>
</edge>
<edge source="A dual register bank" target="quickly swapping the context without saving/restoring to/from the stack">
  <data key="d0">allows</data>
</edge>
<edge source="The second register bank" target="high-speed interrupts">
  <data key="d0">is reserved for</data>
</edge>
<edge source="THE AURIX FAMILY" target="an SW managed solution">
  <data key="d0">implements</data>
</edge>
<edge source="the SW managed solution" target="a specific organization of the context layout in the system memory">
  <data key="d0">features</data>
</edge>
<edge source="the specific organization of the context layout" target="context save area (CSA) chained in a linked list fashion">
  <data key="d0">is based on</data>
</edge>
<edge source="A more complex approach" target="Huang et al.">
  <data key="d0">is introduced by</data>
</edge>
<edge source="28" target="a valid-based mechanism in HW to block context switch on selected registers">
  <data key="d0">adopts</data>
</edge>
<edge source="28" target="register movement by almost 50">
  <data key="d0">reduces</data>
</edge>
<edge source="valid-based mechanism in HW" target="context switch on selected registers">
  <data key="d0">blocks</data>
</edge>
<edge source="THIS FEATURE" target="SEMI-SHADOWING">
  <data key="d0">is combined with</data>
</edge>
<edge source="SEMI-SHADOWING" target="REGISTER BANKING">
  <data key="d0">is similar to</data>
</edge>
<edge source="SEMI-SHADOWING" target="the top (FLIP) and bottom (FLOP) halves of the RF as RF copies">
  <data key="d0">uses</data>
</edge>
<edge source="the latter approach" target="leveraging RISC-V's RV32E base instruction set by re-using the lower 16 architectural registers of the RF">
  <data key="d0">is similar to</data>
</edge>
<edge source="THE EVALUATION IN 28" target="HW IMPLEMENTATION">
  <data key="d0">lacks</data>
</edge>
<edge source="THE EVALUATION IN 28" target="AREA OVERHEAD ASSESSMENT">
  <data key="d0">lacks</data>
</edge>
<edge source="THE EVALUATION IN 28" target="CONTEXT SWITCHING OVERHEAD BY 24">
  <data key="d0">reduces</data>
</edge>
<edge source="THE EVALUATION IN 28" target="on THE DSPSTONE BENCHMARK">
  <data key="d0">reduces CON- TEXT SWITCHING OVERHEAD BY 24</data>
</edge>
<edge source="CONTEXT SWITCHING OVERHEAD" target="24">
  <data key="d0">is reduced by</data>
</edge>
<edge source="THESE APPROACHES" target="HW- and SW-induced latencies when handling asynchronous events">
  <data key="d0">trade-off</data>
</edge>
<edge source="HSE" target="a hardware scheduling engine">
  <data key="d0">is</data>
</edge>
<edge source="HSE" target="interrupts to running tasks">
  <data key="d0">directly attaches</data>
</edge>
<edge source="HSE" target="a specialized interrupt controller">
  <data key="d0">does not need</data>
</edge>
<edge source="this approach" target="lowering interrupt latency and task context switches dramatically">
  <data key="d0">allows</data>
</edge>
<edge source="this approach" target="flexibility">
  <data key="d0">lacks</data>
</edge>
<edge source="this approach" target="replicating hardware resources per task">
  <data key="d0">requires</data>
</edge>
<edge source="its area overhead" target="for a high number of tasks">
  <data key="d0">grows</data>
</edge>
<edge source="Such works" target="the difference in memory footprint between architectures (MB size RFs) and low-end embedded microcontrollers targeted in this work">
  <data key="d0">highlight</data>
</edge>
<edge source="Such works" target="RF caching rather than register shadowing or banking">
  <data key="d0">typically adopt</data>
</edge>
<edge source="RF caching" target="performance reasons">
  <data key="d0">is adopted for</data>
</edge>
<edge source="Performance reasons" target="lower access latency to the RF">
  <data key="d0">include</data>
</edge>
<edge source="Performance reasons" target="higher thread-level parallelism (TLP)">
  <data key="d0">include</data>
</edge>
<edge source="such techniques" target="the system's predictability">
  <data key="d0">may deteriorate</data>
</edge>
<edge source="RISC-V AIA WITHOUT APLIC" target="MNXTI">
  <data key="d0">has a similar approach to</data>
</edge>
<edge source="RISC-V AIA WITHOUT APLIC" target="MNXTI with the XTOPI CSR">
  <data key="d0">has a similar approach to</data>
</edge>
<edge source="XTOPI CSR" target="the highest-priority, pending, and enabled interrupt for a specific privilege mode">
  <data key="d0">reports</data>
</edge>
<edge source="XTOPI CSR" target="both late arrival and redundant context restore mechanisms">
  <data key="d0">allows</data>
</edge>
<edge source="the authors" target="analyzing FastIRQs impact on timing channels">
  <data key="d0">consider for future work</data>
</edge>
<edge source="the authors" target="analyzing FastIRQs integration with different RISC-V extensions">
  <data key="d0">consider for future work</data>
</edge>
<edge source="C. ROCHANGE, S. UHRIG, AND P. SAINRAT" target="TIME-PREDICTABLE ARCHITECTURES (FOCUS COMPUTER ENGINEERING SERIES)">
  <data key="d0">are authors of</data>
</edge>
<edge source="WILEY" target="in HOBOKEN, NJ, USA in 2014">
  <data key="d0">published</data>
</edge>
<edge source="L. M. PINHO ET AL." target="HIGH-PERFORMANCE AND TIME-PREDICTABLE EMBEDDED COMPUTING">
  <data key="d0">author of</data>
</edge>
<edge source="HIGH-PERFORMANCE AND TIME-PREDICTABLE EMBEDDED COMPUTING" target="HTTP:EU.WILEY.COMWILEYCDA WILEYTITLEPRODUCTCD-1848215932.HTML">
  <data key="d0">available at</data>
</edge>
<edge source="RIVER" target="WHARTON, TX, USA">
  <data key="d0">published in</data>
</edge>
<edge source="RIVER" target="2018">
  <data key="d0">published in year</data>
</edge>
<edge source="3 F. Reghenzani, G. Massari, and W. Fornaciari" target="The Real-Time Linux Kernel: A Survey on PreemptRT, ACM Comput.">
  <data key="d0">authored</data>
</edge>
<edge source="4 M. LIU, D. LIU, Y. WANG, M. WANG, AND Z. SHAO" target="ON IMPROVING REAL-TIME INTERRUPT LATENCIES OF HYBRID OPERATING SYSTEMS WITH TWO-LEVEL HARDWARE INTERRUPTS">
  <data key="d0">authored</data>
</edge>
<edge source="ON IMPROVING REAL-TIME INTERRUPT LATENCIES OF HYBRID OPERATING SYSTEMS WITH TWO-LEVEL HARDWARE INTERRUPTS" target="IEEE TRANS.">
  <data key="d0">published in</data>
</edge>
<edge source="5 P. Mantegazza, E. L. Dozio, and S. Papacharalambous" target="RTAI: Real Time Application Interface">
  <data key="d0">authored</data>
</edge>
<edge source="RTAI: Real Time Application Interface" target="Linux J.">
  <data key="d0">published in</data>
</edge>
<edge source="J. Valvano" target="Introduction to Embedded Systems">
  <data key="d0">authored</data>
</edge>
<edge source="Introduction to Embedded Systems" target="http://web.engr.oregonstate.edu/traylor/ece473 PDFs/minimize_interrupt_response_time.pdf">
  <data key="d0">is available at</data>
</edge>
<edge source="CREATESPACE" target="SCOTTS VALLEY, CA, USA">
  <data key="d0">location</data>
</edge>
<edge source="CREATESPACE" target="AUG. 2016">
  <data key="d0">date</data>
</edge>
<edge source="9 Y. HUANG, L. SHI, J. LI, Q. LI, AND C. J. XUE" target="WCET-AWARE RE-SCHEDULING REGISTER ALLOCATION FOR REAL-TIME EMBEDDED SYSTEMS WITH CLUSTERED VLIW ARCHITECTURE">
  <data key="d0">authored</data>
</edge>
<edge source="WCET-AWARE RE-SCHEDULING REGISTER ALLOCATION FOR REAL-TIME EMBEDDED SYSTEMS WITH CLUSTERED VLIW ARCHITECTURE" target="IEEE TRANS.">
  <data key="d0">published in</data>
</edge>
<edge source="X. Zhou and P. Petrov" target="Rapid and low-cost context-switch through embedded processor customization for real-time and control applications">
  <data key="d0">authored</data>
</edge>
<edge source="Rapid and low-cost context-switch through embedded processor customization for real-time and control applications" target="Proc.">
  <data key="d0">published in</data>
</edge>
<edge source="ASSOCIATION FOR COMPUTING MACHINERY" target="NEW YORK, NY, USA">
  <data key="d0">location</data>
</edge>
<edge source="ASSOCIATION FOR COMPUTING MACHINERY" target="2006">
  <data key="d0">publication year</data>
</edge>
<edge source="ASSOCIATION FOR COMPUTING MACHINERY" target="352">
  <data key="d0">page</data>
</edge>
<edge source="ASSOCIATION FOR COMPUTING MACHINERY" target="10.11451146909.1147001">
  <data key="d0">DOI</data>
</edge>
<edge source="I. Behnke, L. Pirl, L. Thamsen, R. Danicki, A. Polze, and O. Kao" target="Interrupting Real-Time IoT Tasks: How Bad Can It Be to Connect Your Critical Embedded System to the Internet?">
  <data key="d0">authored</data>
</edge>
<edge source="K. Asanovic and D. A. Patterson" target="Instruction Sets Should Be Free: The Case for RISC-V">
  <data key="d0">wrote</data>
</edge>
<edge source="THE RISC-V INSTRUCTION SET MANUAL VOLUME II: PRIVILEGED ARCHITECTURE VERSION 1.9" target="A. WATERMAN, Y. LEE, R. AVIZIENIS, D. A. PATTERSON, AND K. ASANOVIC">
  <data key="d0">authors</data>
</edge>
<edge source="THE RISC-V INSTRUCTION SET MANUAL VOLUME II: PRIVILEGED ARCHITECTURE VERSION 1.9" target="HTTP://WWW2.EECS.BERKELEY.EDU/PUB/STECHRPTS/2014/EECS-2014-146.HTML">
  <data key="d0">available at</data>
</edge>
<edge source="THE RISC-V INSTRUCTION SET MANUAL VOLUME II: PRIVILEGED ARCHITECTURE VERSION 1.9" target="EECS, Berkeley">
  <data key="d0">department</data>
</edge>
<edge source="EECS" target="UNIV.">
  <data key="d0">is part of</data>
</edge>
<edge source="California" target="Berkeley">
  <data key="d0">contains</data>
</edge>
<edge source="Berkeley" target="California">
  <data key="d0">is located in</data>
</edge>
<edge source="Berkeley" target="CA">
  <data key="d0">is located in</data>
</edge>
<edge source="Berkeley" target="Tech">
  <data key="d0">is associated with</data>
</edge>
<edge source="CA" target="USA">
  <data key="d0">is located in</data>
</edge>
<edge source="RISC-V Fast Interrupt Blob" target="https://github.com/riscv/riscv-fast-interrupt/blob/master/clic">
  <data key="d0">is available at</data>
</edge>
<edge source="ADOC 16 M. GAUTSCHI ET AL." target="NEAR-THRESHOLD RISC-V CORE WITH DSP EXTENSIONS FOR SCALABLE IOT ENDPOINT DEVICES">
  <data key="d0">wrote</data>
</edge>
<edge source="NEAR-THRESHOLD RISC-V CORE WITH DSP EXTENSIONS FOR SCALABLE IOT ENDPOINT DEVICES" target="IEEE TRANS.">
  <data key="d0">published in</data>
</edge>
<edge source="OPENHW GROUP" target="CV32E40P USER MANUAL">
  <data key="d0">has</data>
</edge>
<edge source="OPENHW GROUP" target="an organization">
  <data key="d0">is</data>
</edge>
<edge source="39 NUCLEI SYSTEM TECHNOLOGY CO. LTD." target="ECLIC UNIT">
  <data key="d0">has unit</data>
</edge>
<edge source="ECLIC UNIT" target="39 NUCLEI SYSTEM TECHNOLOGY CO. LTD.">
  <data key="d0">is introduced in</data>
</edge>
<edge source="NUCLEI" target="SPEC">
  <data key="d0">ISA</data>
</edge>
<edge source="A. Ottaviano et al." target="ControlPULP: a RISC-V on-chip parallel power controller for many-core HPC processors with FPGA-based hardware-in-the-loop power and thermal emulation">
  <data key="d0">authored</data>
</edge>
<edge source="ControlPULP" target="a RISC-V on-chip parallel power controller">
  <data key="d0">is</data>
</edge>
<edge source="ControlPULP" target="many-core HPC processors">
  <data key="d0">used for</data>
</edge>
<edge source="ControlPULP" target="FPGA-based hardware-in-the-loop power and thermal emulation">
  <data key="d0">features</data>
</edge>
<edge source="Document" target="https://doc.nucleisys.com/nucleispecisaintroduction.html">
  <data key="d0">available at</data>
</edge>
<edge source="Document" target="https://old.hotchips.org/wp-content/uploads/hcarchives/hc16/3tue6hc16sess7pres1bw.pdf">
  <data key="d0">is available at</data>
</edge>
<edge source="Document" target="Infineon Technologies AG">
  <data key="d0">is related to</data>
</edge>
<edge source="PARALLEL PROGRAM." target="FEB. 2024">
  <data key="d0">published in</data>
</edge>
<edge source="PARALLEL PROGRAM." target="10.1007S10766-024-00761-4">
  <data key="d0">has DOI</data>
</edge>
<edge source="FREERTOS" target="real-time operating system for microcontrollers">
  <data key="d0">is</data>
</edge>
<edge source="REAL TIME ENGINEERS LTD." target="ONLINE">
  <data key="d0">is</data>
</edge>
<edge source="21 C.-M. Lin" target="Nested Interrupt Analysis of Low Cost and High Performance Embedded Systems Using GSPN Framework">
  <data key="d0">authored</data>
</edge>
<edge source="Nested Interrupt Analysis of Low Cost and High Performance Embedded Systems Using GSPN Framework" target="IEICE Trans.">
  <data key="d0">published in</data>
</edge>
<edge source="Text" target="https://www.freertos.org/index.html">
  <data key="d0">available at</data>
</edge>
<edge source="RISCV-PLIC-1.0.0.PDF" target="https://github.com/riscv/riscv-plic-spec/blob/master/riscv-plic-1.0.0.pdf">
  <data key="d0">is available at</data>
</edge>
<edge source="J. Yiu" target="The Definitive Guide to ARM Cortex-M3 Cortex-M4 Processors, 3rd ed.">
  <data key="d0">author of</data>
</edge>
<edge source="NEWNES" target="in BOSTON, MA, USA in 2013">
  <data key="d0">published</data>
</edge>
<edge source="HTTPS:DEVELOPER.ARM.COMDOCUMENTATION1001660001" target="25 J. YIU">
  <data key="d0">is available</data>
</edge>
<edge source="ARM Cortex-M processors" target="interrupt latency">
  <data key="d0">have</data>
</edge>
<edge source="V. G. Gaitan, N. C. Gaitan, and I. Ungurean" target="CPU architecture based on a hardware scheduler and independent pipeline registers">
  <data key="d0">authored</data>
</edge>
<edge source="CPU architecture based on a hardware scheduler and independent pipeline registers" target="IEEE Transactions">
  <data key="d0">published in</data>
</edge>
<edge source="Beginner guide on interrupt latency and interrupt latency of the ARM Cortex-M processors" target="https://community.arm.com/arm-community-blogs/b/architectures-and-processors-blog/posts/beginner-guide-on-interrupt-latency-and-interrupt-latency-of-the-arm-cortex-m-processors?pifragment=227142">
  <data key="d0">available at</data>
</edge>
<edge source="LI and J. K. LEE" target="paged register files for improving context switching on embedded processors">
  <data key="d0">support</data>
</edge>
<edge source="30" target="RENESAS">
  <data key="d0">is</data>
</edge>
<edge source="HARDWARE MANUAL" target="RENESAS MCU M16C">
  <data key="d0">is for</data>
</edge>
<edge source="HARDWARE MANUAL" target="https://www.renesas.com/us/en/document/mahm32c87-group-m32c87-m32c87a-m32c87b-hardware-manual">
  <data key="d0">is available at</data>
</edge>
<edge source="SIFIVE INC." target="HARDWARE MANUAL">
  <data key="d0">published</data>
</edge>
<edge source="SIFIVE INC." target="2021">
  <data key="d0">published year</data>
</edge>
<edge source="CORECOMPLEXMANUAL21G1.PDF" target="HTTPS:SIFIVE.CDN.PRISMIC.IOSIFIVE7C22C2EC-8AF4-4B6C-A5FE-9327D91E7808E21CORECOMPLEXMANUAL21G1.PDF">
  <data key="d0">is available at</data>
</edge>
<edge source="STMICROELECTRONICS" target="the text">
  <data key="d0">is mentioned in</data>
</edge>
<edge source="STM32L5-SYSTEM-NESTEDVECTOREDINTERRUPTCONTROLNVIC.PDF" target="https://www.st.com/content/ccc/resource/training/technical/product_training/group/16135d207346f4e83/STM32L5-SYSTEM-NESTEDVECTOREDINTERRUPTCONTROLNVIC.files/STM32L5-SYSTEM-NESTEDVECTOREDINTERRUPTCONTROLNVIC.pdf">
  <data key="d0">is available at</data>
</edge>
<edge source="INFINEON TECHNOLOGIES AG" target="STM32L5-SYSTEM-NESTEDVECTOREDINTERRUPTCONTROLNVIC.PDF">
  <data key="d0">is mentioned in</data>
</edge>
<edge source="INFINEON TECHNOLOGIES AG" target="the file">
  <data key="d0">is associated with</data>
</edge>
<edge source="FAST POWERTRAIN MICROCONTROLLER" target="a microcontroller">
  <data key="d0">is</data>
</edge>
<edge source="FILE" target="https://hitex.co.uk/fileadmin/uk-files/downloads/shieldbuddytc27xdumv2.2.pdf">
  <data key="d0">is available at</data>
</edge>
<edge source="TC27X D-STEP" target="32-bit single-chip microcontroller">
  <data key="d0">is a</data>
</edge>
<edge source="TRICORE V1.6" target="CORE ARCHITECTURE">
  <data key="d0">is</data>
</edge>
<edge source="HTTPS:WWW.INFINEON.COMDGDLTC16 ARCHITECTUREVOL1.PDF?FILEIDDB3A3043372D5CC801373B0F374D5D67" target="INFINEON TECHNOLOGIES AG">
  <data key="d0">is available at</data>
</edge>
<edge source="TASK CONTEXT SWITCHING RTOS" target="U.S. PATENT 7 434 222 B2">
  <data key="d0">is patented by</data>
</edge>
<edge source="U.S. PATENT 7 434 222 B2" target="OCT. 2008">
  <data key="d0">was issued in</data>
</edge>
<edge source="H. ZENG AND K. GHOSE" target="REGISTER FILE CACHING FOR ENERGY EFFICIENCY">
  <data key="d0">authored</data>
</edge>
<edge source="REGISTER FILE CACHING FOR ENERGY EFFICIENCY" target="ISLPED PROC.">
  <data key="d0">published in</data>
</edge>
<edge source="Date" target="6, JUNE 2024">
  <data key="d0">is</data>
</edge>
<edge source="38 M. SADROSADATI ET AL." target="HIGHLY CONCURRENT LATENCY-TOLERANT REGISTER FILES FOR GPUS">
  <data key="d0">authored</data>
</edge>
<edge source="HIGHLY CONCURRENT LATENCY-TOLERANT REGISTER FILES FOR GPUS" target="ACM TRANS.">
  <data key="d0">published in</data>
</edge>
<edge source="Degrees" target="ETH Zurich, Zurich, Switzerland">
  <data key="d0">are from</data>
</edge>
<edge source="Degrees" target="2015 and 2017, respectively">
  <data key="d0">were obtained in</data>
</edge>
<edge source="Degree" target="the Digital Circuits and Systems Group of Prof. Benini">
  <data key="d0">is at</data>
</edge>
<edge source="Degree" target="Physical Engineering">
  <data key="d0">is in</data>
</edge>
<edge source="Degree" target="Politecnico di Turino, Turin, Italy">
  <data key="d0">is from</data>
</edge>
<edge source="Degree" target="2018">
  <data key="d0">was obtained in</data>
</edge>
<edge source="Degree" target="Electrical Engineering">
  <data key="d0">field</data>
</edge>
<edge source="Degree" target="Politecnico di Turino">
  <data key="d0">was obtained from</data>
</edge>
<edge source="Degree" target="Grenoble INP-PHELMA, Grenoble, France">
  <data key="d0">was obtained from</data>
</edge>
<edge source="Degree" target="EPFL Lausanne, Lausanne, Switzerland">
  <data key="d0">was obtained from</data>
</edge>
<edge source="Degree" target="2020">
  <data key="d0">was obtained in</data>
</edge>
<edge source="Degree" target="Stanford University">
  <data key="d0">awarded by</data>
</edge>
<edge source="Degree" target="Stanford, CA, USA">
  <data key="d0">location</data>
</edge>
<edge source="Degree" target="1997">
  <data key="d0">year</data>
</edge>
<edge source="Digital Circuits and Systems Group" target="ETH Zurich">
  <data key="d0">is part of</data>
</edge>
<edge source="ETH Zurich" target="Zurich, Switzerland">
  <data key="d0">is located in</data>
</edge>
<edge source="His research interests" target="real-time computing">
  <data key="d0">include</data>
</edge>
<edge source="His research interests" target="compilers">
  <data key="d0">include</data>
</edge>
<edge source="His research interests" target="operating systems">
  <data key="d0">include</data>
</edge>
<edge source="His research interests" target="power management of HPC processors">
  <data key="d0">include</data>
</edge>
<edge source="His research interests" target="energy-efficient processor architecture">
  <data key="d0">include</data>
</edge>
<edge source="LUCA BENINI" target="the Ph.D.">
  <data key="d0">received</data>
</edge>
<edge source="Dr. Benini" target="the ACM">
  <data key="d0">is a fellow of</data>
</edge>
<edge source="Dr. Benini" target="the Academia Europaea">
  <data key="d0">is a member of</data>
</edge>
</graph></graphml>